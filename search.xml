<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F09%2F10%2Ftest%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>MarkDown语法</category>
      </categories>
      <tags>
        <tag>博客编写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础（九）]]></title>
    <url>%2F2018%2F09%2F09%2Fjava14%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[日积月累集合类 为什么会出现这么多的容器呢？因为每一个容器对数据的存储方式都有不同，我们称之为：数据结构。 Collection接口：add(E e):add方法的参数类型是Object，以便于接受任意类型对象。集合中存储的的地址remove(Object o):从此collection中移除指定元素的单个实例removeAll(Collection&lt;?&gt; c):移除collection中那些包含在指定collection中的所有元素clear():移除此collection中的所有元素contains(Object o):如果此collection包含指定的元素，则返回trueisEmpty():如果此collection中不包含元素，则返回trueretainAll(Collection&lt;?&gt; c):用来取交集并存储。 集合中存储的都是对象的引用（地址） 每一个集合都会有判断和取出方法，就把取出方式定义在集合的内部，这样取出方式就被定义成了内部类。而每一个容器的数据结构不同，所以取出的动作细节也不同，但是都有共性内容判断和取出。那么可以进行共性抽取。那么这些内部类都符合一个规则，该规则就是Iterator。如何获取集合的取出对象呢？通过一个对外提供的方法iterator()，返回在此collection的元素上进行迭代的迭代器。 Iterator接口是对collection进行迭代的迭代器。其实就是集合的取出元素的方式。Iterator接口的方法：hasNext()： 如果仍有元素可以迭代，则返回 true,next()：返回迭代的下一个元素,remove()：从迭代器指向的 collection 中移除迭代器返回的最后一个元素 List Collection List：元素是有序的，元素可以重复，因为该集合体系有索引 ArrayList:底层的数据结构是数组结构。特点：查询速度很快，但是增删很慢。 LinkedList:底层使用的是链表数据结构。特点：增删速度很快，查询稍慢。 vector:底层是数组数据结构。线程同步。被ArrayList替代了。其中有个特殊方法elements()，返回的是Enumeration接口对象（枚举）；枚举就是Vector特有的取出方式，其实枚举和迭代是一样的。 set：元素是无序的，元素不可以重复 List特有方法：凡是可以操作角标的方法都是该体系特有的方法。 增：add(index,element)在列表的指定位置插入指定元素;addAll(index,collection)添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序 删: remove(index) 移除列表中指定位置的元素 改：set(index,element) 用指定元素替换列表中指定位置的元素 查：get(index);subList(from,to);listIterator() List集合特有的迭代器：ListIterator()是Iterator的子接口。 在迭代时，不可以通过集合对象的方法操作集合中的元素。因为会发生ConcurrentModificationExcption异常（当方法检测到对象的并发修改，但不允许这种修改时，抛出此异常。）。 所以，在迭代时，只能用迭代器的方法操作元素，可是Iterator方法是有限的，只能对元素进行判断、取出、删除操作，如果想要其他的操作如添加、修改等，就需要使用其子接口，ListIterator。该接口之能通过List集合的listIterator()方法完成。 Linkedlist特有方法： addFirst():将指定元素插入此列表的开头 addLast():将指定元素插入此列表的结尾 getFirst():返回此列表的第一个元素 getLast():返回此列表的最后一个元素 removeFirst():移除并返回此列表的第一个元素，如果集合中没有元素，会出现NoSuchElementException removeLast():移除并返回此列表的最后一个元素，如果集合中没有元素，会出现NoSuchElementException 在JDK 1.6 出现了以上方法的替代方法 使用LinkedList模拟一个堆栈或者队列数据结构。堆栈：先进后出 如同一个杯子队列：先进先出(FIFO) 如同一个水管队列的实现：通过链表的方法。如如下代码块。堆栈同理。 12345678910111213141516171819202122232425262728293031323334353637383940package Collection;import java.util.LinkedList;//定义一个队列类，类中有构造方法产生链表对象，和对队列操作的方法class Queue &#123; private LinkedList list; Queue() &#123; list = new LinkedList(); &#125; public void myAdd(Object obj) &#123; list.addFirst(obj); &#125; public Object myGet() &#123; return list.removeLast(); &#125; public boolean isNull() &#123; return list.isEmpty(); &#125;&#125;public class LinkeListTest &#123; public static void main(String[] args) &#123;// 创建队列对象 Queue queue = new Queue();// 向队列对象中添加obj，实际上是给链表添加元素 queue.myAdd(&quot;Hello LinkedList---1&quot;); queue.myAdd(&quot;Hello LinkedList---2&quot;); queue.myAdd(&quot;Hello LinkedList---3&quot;); queue.myAdd(&quot;Hello LinkedList---4&quot;);//队列对象经过removeLast方法后，只要不为空，进行输出 while (!queue.isNull()) &#123; System.out.println(queue.myGet()); &#125; &#125;&#125; ArrayList练习：去除ArrayList集合中的重复元素 12345678910111213141516171819202122232425262728293031323334package Collection;/*去除ArrayList集合中重复的元素; * 思路： * 1. 新建一个数组集合用来保存不重复的元素 * 2. 遍历包含重复元素的数组集合，其中每一个元素都与新建的那个数组集合判断是否被包含，没有就加入这个数组集合*/import java.util.ArrayList;import java.util.Iterator;public class ArrayListTest &#123; // 去除重复元素的方法 public static ArrayList singleElement(ArrayList arrayList) &#123; ArrayList newAl = new ArrayList();//返回一个需要去除重复元素的数组集合的迭代器 Iterator it = arrayList.iterator();//循环判断每一个元素 while (it.hasNext()) &#123; Object obj = it.next(); if (!newAl.contains(obj)) newAl.add(obj); &#125; return newAl; &#125; public static void main(String[] args) &#123; ArrayList a1 = new ArrayList(); a1.add(&quot;Hello ArrayList---1&quot;); a1.add(&quot;Hello ArrayList---2&quot;); a1.add(&quot;Hello ArrayList---3&quot;); a1.add(&quot;Hello ArrayList---2&quot;); a1.add(&quot;Hello ArrayList---1&quot;); System.out.println(singleElement(a1)); &#125;&#125; 在迭代时循环中next调用一次，就要hasNext判断一次。 List集合判断元素是否相同，依据的是元素的equels方法 HashSetSet:元素是无序（存入和取出的顺序不一定一致），元素不可以重复 常见子类： HashSet:底层数据结构是哈希表。HashSet是如何保证元素唯一性的呢？是通过元素的两个方法，hashCode和equals来完成。如果元素的HashCode值相同，才会判断equals是否为true。如果元素的HashCode值不同，不会调用equals。 注意对于判断元素是否存在以及删除等操作，依赖的方法是元素的hashCode和equels方法。 TreeSet:可以对Set集合中的元素进行排序。 排序时，当主要条件相同时，一定要判断一下次要条件。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>第14天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础（九）]]></title>
    <url>%2F2018%2F09%2F08%2Fjava13%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[日积月累String类 String s1 = “abc”;//s1是一个类类型变量，”abc”是一个对象 。字符串最大特点：一旦被初始化就不可以被改变。 String类复写了Object类中equals方法，该方法用于判断字符串内容是否相同。 String s1 = “abc”;String s2 = new String(“abc”);s1和s2有什么区别？s1在内存中一个对象，s2在内存中两个对象(new，”abc”)； String类提供的常见操作？”abcd” 获取 字符串中的包含的字符数，也就是字符串的长度。int length()。 数组的length是属性，没有() 根据位置获取位置上某个字符。char charAt(int index) 根据字符获取该字符在字符串中位置。int indexOf(int ch)：返回的是ch在字符串中第一次出现的位置。int indexOf(int ch,int fromIndex):从fromIndex指定位置开始，获取ch在字符串中的位置。如果没有找到返回-1. 判断 字符串中是否包含某一个子串 字符中是否有内容 字符串是否是以指定内容开头 字符串是否以指定内容结尾 字符串内容是 否相同 判断内容是否 相同，并忽略大小写 转换 将字符数组转成字符串 将字符串转成字符数组 将字节数组转成字符串 将字符串转成字节数组 替换 切割 子串 转换 StringBuffer StringBuffer是字符串缓冲区。是一个容器 而且长度可变化，可以直接操作多个数据类型，最终会通过toString()方法变成字符串。能进行增删改查 append(); 123StringBuffer sb = new StringBuffer();StringBuffer sb1 = sh.append(34);sout(sb == sb1)//true insert(index,数据); delete（start,end）; StringBuilder在JDK 1.5 版本之后出现，StringBuffer是线程同步的。StringBuilder是线程不同步的。StringBuilder提高效率，比较安全（减少并发）。 基本数据类型对象包装类 基本数据类型对象包装类的最常见作用：就是用于基本数据类型和字符串类型之间做转换 基本数据类型转成字符串。如基本数据类型+””；或者基本数据类型.toString(基本数据类型值）。字符串转成基本数据类型。如基本数据类型.paseInt(字符串); 十进制转成其他进制：toBinaryString();toHexString();toOctalString();其他进制转成十进制:parseInt(string,radix); 1234567Integer m = 128;Integer n = 128;sout(m==n)//falseInteger a = 127;Integer b = 127;sout(a==b)//true.因为a和b指向了同一个Integer对象。因为当数值在byte范围内容，对于新特性，如果该数值已经存在，则不会在开辟新的空间。 String字符串练习 模拟一个trim方法，去除字符串两端的空格。 思路： 判断字符串第一个位置是否是空格，如果是继续向下判断，直到不是空格为止；结尾处判断空格也是如此 当开始和结尾都怕短到不是空格时，就是要获取的字符串 12345678910111213141516171819202122232425262728293031package StringTest;/** 模拟一个trim方法，去除字符串两端的空格。*/public class TestOne &#123; public static void sop(String str)&#123; //定义一个输出方法 System.out.println(str); &#125; public static void main(String[] args) &#123; String s = &quot; ab cd &quot;; sop(&quot;(&quot;+s+&quot;)&quot;); //对字符串进行myTrim操作 s = myTrim(s); sop(&quot;(&quot;+s+&quot;)&quot;); &#125; public static String myTrim(String str)&#123; int start = 0; int end = str.length()-1; //从第一个位置开始查找空格，直到查到字符，停止查找，并返回当前的start值 while (start&lt;=end &amp;&amp; str.charAt(start)==&apos; &apos;) start++; //从最后一个位置开始从右至左查找空格，直到查到字符，停止查找，并返回当前的end值 while (start&lt;=end &amp;&amp; str.charAt(end)==&apos; &apos;) end--; //返回String对象，通过substring(start,end)方法获取子串，end位置的字符不计入子串。 return str.substring(start,end+1); &#125;&#125; 练习二:将一个字符串进行反转，将字符串中指定部分进行反转，“abcdefg”;abfedcg思路：1.知道如何对数组元素进行反转2.将字符串变成数组，进行反转3.将反转后的数组变成字符串4.只要将反转的部分的开始和结束位置作为参数传递即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package StringTest;/*将一个字符串进行反转，将字符串中指定部分进行反转，“abcdefg”;abfedcg思路：1.知道如何对数组元素进行反转2.将字符串变成数组，进行反转3.将反转后的数组变成字符串4.只要将反转的部分的开始和结束位置作为参数传递即可*/public class TestTwo &#123; public static void sop(String str) &#123; //定义一个输出方法 System.out.println(str); &#125; public static String reverseString(String s) &#123;// 字符串变成数组 char[] chars = s.toCharArray();// 反转数组 reverse(chars);// 将数组变成字符串,使用构造函数 return new String(chars); &#125; //方法的重载 public static String reverseString(String s, int start, int end) &#123; // 字符串变成数组 char[] chars = s.toCharArray();// 反转数组 reverse(chars, start, end); // 将数组变成字符串,使用构造函数 return new String(chars); &#125; private static void reverse(char[] chars, int x, int y) &#123; for (int start = x, end = y - 1; start &lt; end; start++, end--) &#123; swap(chars, start, end); &#125; &#125; //方法的重载 private static void reverse(char[] chars) &#123; for (int start = 0, end = chars.length - 1; start &lt; end; start++, end--) &#123; swap(chars, start, end); &#125; &#125;// 数组反转 private static void swap(char[] chars, int start, int end) &#123; char temp = chars[start]; chars[start] = chars[end]; chars[end] = temp; &#125; public static void main(String[] args) &#123; String s = &quot;abcdefg&quot;; sop(&quot;No reverse--&quot;+s); sop(&quot;absolute reverse---&quot;+reverseString(s)); sop(&quot;part reverse==&quot;+reverseString(s, 2, 6)); &#125;&#125; 练习：获取一个字符串在另一个字符串中出现的次数.”abkkcdkkefkkakk”思路：1.定义计数器2.获取“kk”第一次出现的位置3.从第一次出现位置后剩余的字符串中继续获取kk出现的位置，每获取一次就计数一次4.当获取不到时，计数完成 123456789101112131415161718192021222324252627282930313233343536package StringTest;/*获取一个字符串在另一个字符串中出现的次数.&quot;abkkcdkkefkkakk&quot; * 思路： * 1.定义计数器 * 2.获取“kk”第一次出现的位置 * 3.从第一次出现位置后剩余的字符串中继续获取kk出现的位置，每获取一次就计数一次 * 4.当获取不到时，计数完成*/public class TestThree &#123; public static void sop(String str) &#123; //定义一个输出方法 System.out.println(str); &#125; //定义获取出现重复kk次数的方法 public static int getSubCount(String str, String key) &#123;// 定义一个count用来计数，index用来记录出现kk的索引 int count = 0; int index = 0;//if判断只执行一次，while当条件为true就一直执行；indexOf(key)每次都是从0开始查找；indexOf(key,fromIndex)从指定位置开始查找。更高效 while ((index = str.indexOf(key, index)) != -1) &#123; sop(&quot;index=&quot; + index);// subString()方法：返回一个新的字符串，它是此字符串的一个子字符串。// 该子字符串从指定索引处的字符开始，直到此字符串末尾。str = str.substring(index + key.length()); index = index + key.length();// 计数 count++; &#125; return count; &#125; public static void main(String[] args) &#123; String str = &quot;abkkcdkkefkkakk&quot;; sop(&quot;count=&quot; + getSubCount(str, &quot;kk&quot;)); &#125;&#125; 练习：获取两个字符串中最大相同子串。第一个动作，将短的那个串进行长度一次递减的子串打印 “abcwerthelloyuicdef””cvhellobnm*思路：1.将短的那个子串按照长度递减的方式获取到2.将每获取到的子串去长串中判断是否包含，如果包含，已经找到！ 123456789101112131415161718192021222324252627282930313233343536373839404142package StringTest;/*获取两个字符串中最大相同子串。第一个动作，将短的那个串进行长度一次递减的子串打印 * “abcwerthelloyuicdef” * &quot;cvhellobnm* * 思路： * 1.将短的那个子串按照长度递减的方式获取到 * 2.将每获取到的子串去长串中判断是否包含，如果包含，已经找到！*/public class TestFour &#123; public static void sop(String str) &#123; //定义一个输出方法 System.out.println(str); &#125; // 定义一个获取最大相同子串的方法，比较的是两个字符串，局部变量就是两个字符串 public static String getMaxSubString(String s1, String s2) &#123; String max = s1.length() &gt;= s2.length() ? s1 : s2; String min = max == s1 ? s2 : s1;// 外层循环是控制短串需要进行多少次指针偏移，即要找多少次子串 for (int x = 0; x &lt; min.length(); x++) &#123;// 内层循环是控制当前长度的对应子串有多少个，y为头位置，z为尾标，当z的位置超过子串应有长度// （substring(start,end)方法中end位置字符不计入子串）停止查找 for (int y = 0, z = min.length() - x; z != min.length() + 1; y++, z++) &#123; String temp = min.substring(y, z);// sop(temp);// 如果长串中有包含短串中查找到的子串，返回一个String对象（temp） if (max.contains(temp)) return temp; &#125; &#125; return &quot;&quot;; &#125; public static void main(String[] args) &#123; String s2 = &quot;abcwerthelloyuicdef&quot;; String s1 = &quot;cvhellobnmaf&quot;;// 输出最大相同子串 sop(getMaxSubString(s1, s2)); &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>第13天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础（八）]]></title>
    <url>%2F2018%2F09%2F08%2Fjava12%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[日积月累多线程间通信 线程间通讯：其实就是多个线程在操作同一个资源，但是操作的动作不同。 线程间通信，解决安全问题，同步的两个前提必须满足。 等待唤醒机制。wait():notify():notifyAll():都是用在同步中，因为要对持有监视器（锁）的线程操作。所以要使用在同步中，因为只有同步才具有锁。为什么这些操作线程的方法要定义在Object类中呢？因为这些方法在操作同步中线程时，都必须要标识他们所操作线程只有的锁，只有同一个锁上的被等待线程，可以被同一个锁上notify唤醒，不可以对不同锁中的线程进行唤醒。也就是说，等待和唤醒必须是同一个锁。而锁可以是任意对象，所以可以被任意对象调用的方法定义在Object类中。 当有多个生产者消费者，必须要用while循环，判断标记，唤醒全部线程。因为，让被唤醒的线程再一次判断标记。为什么定义notifyAll，因为需要唤醒对方线程。因为只用notify，容易出现只唤醒本方线程的情况，导致程序中的所有线程都等待。 JDK1.5 中提供了多线程升级解决方案。将同步Synchronized替换成Lock操作。将Object中的wait，notify，notifyAll，替换成Condition对象。该对象能Lock锁，进行获取。 多线程停止 如何停止线程？只有一种，run方法结束。开启多线程运行，运行代码通常是循环结构。只要控制住循环，就可以让run方法结束，也就是线程结束。当没有指定的方式让冻结的线程恢复到运行状态时，这时需要对冻结进行清除。强制让线程恢复到运行状态中来。这样就可以操作标记让线程结束。 守护线程。 Join方法：抢夺cpu执行权。当A线程执行到了B线程的.join方法时，A就会等待，等待B线程都执行完，A才执行。join可以用来临时加入线程执行。 优先级.setPriority() .yield()暂停当前正在执行的线程，让其他线程执行。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>第12天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础（七）]]></title>
    <url>%2F2018%2F09%2F07%2Fjava%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[日积月累多线程 进程：是一个正在执行中的程序。每一个进程执行都有一个执行顺序。该顺序是一个执行路径，或者叫一个控制单元。 线程：就是进程中的一个独立的控制单元。线程在控制着进程的执行。 一个进程中至少有一个线程。 java虚拟机启动的时候会有一个进程java.exe。该进程中至少有一个线程负责java程序的执行。而且这个线程运行的代码存在于main方法中，该线程称之为主线程。其实更细节说明jvm，jvm不止一个线程，还有负责垃圾回收机制的线程。 多线程的意义： 如何在自定义的代码中定义线程：①继承Thread类（1.定义类继承Thread 2.复写Thread类中的run方法（将自定义代码存储在run方法中，让线程运行） 3.调用线程的start方法，该方法有两个作用：启动线程，调用run方法） ②实现Runnable接口 为什么要复写run方法：Thread类用于描述线程。该类就定义了一个功能，用于存储线程要运行的代码。该存储功能就是run方法。也就是说Thread中run方法，用于存储要运行的代码 创建线程 static Thread currentThread():获取当前线程对象。getName():获取线程名称设置线程名称:setName或者构造函数 实现Runnable接口：步骤：1.定义类实现Runnable接口 2.覆盖Runnable接口中的run方法（将线程要运行的代码放在run方法中） 3.通过Thread类建立线程对象 4.将Runnable接口的子类对象作为实际参数传给Thread类的构造函数（为什么要将Runnable接口的子类对象传递给Thread的构造函数？因为，自定义的run方法所属的对象是Runnable接口的子类对象；所以要让线程去指定指定对象的run方法，就必须明确该run方法所属对象。） 5.调用Thread类的start方法开启线程并调用Runnable接口子类的run方法。 实现方式和继承方式有什么区别？实现方式好处在于避免了单继承的局限性。在定义线程时，建议使用实现方式。（继承一个父类的同时实现Runnable接口）两种方式的区别：继承Thread：线程代码存放在Thread子类run方法中。实现Runable：线程代码存放在接口的子类的run方法。 多线程的运行出现了安全问题。问题的原因：当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完；另一个线程参与进来执行，导致共享数据的错误。解决办法：对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程无法参与执行。Java对于多线程的安全问题提供了专业的解决方式，就是同步代码块。synchronized(对象){需要被同步的代码}需要被同步的代码是操作共享数据的代码，对象可以用Object对象。对象如同锁，持有锁的线程可以在同步中执行。没有持有锁的线程即使获取cpu的执行权，也进不去，因为没有获取锁。（如火车的卫生间）同步的前提：①必须要有两个或者两个以上的线程②必须是多个线程使用同一个锁必须保证同步中只能有一个线程在运行。好处：解决了多线程的安全问题弊端：多个线程需要判断锁，较为消耗资源 如何判断程序是否有安全问题？ 明确哪些代码是多线程运行代码 明确共享数据 明确多线程运行代码中哪些语句是操作共享数据的 同步是有同步函数和同步代码块两种写法。同步函数用的是哪一个锁？函数需要被对象调用，那么函数都有一个所属对象引用，就是this，所以同步函数使用的锁是this 如果同步函数被静态修饰后，使用的锁是什么呢？肯定不是this，因为静态方法中也不可以定义this。静态进内存时，内存中没有本类对象，但是一定有该类对应的字节码文件对象, 类名.class，该对象的类型是class。静态的同步方法，使用的锁是该方法所在类的字节码文件对象。类名.class 懒汉式特点在于实例的延时加载，如果多线程访问会出现安全问题，可以加同步，但是有点低效，可以用双重判断提高一点效率，锁是该类的字节码.class。（请写出延时加载的单例设计模式）。 class Single { private static Single s = null; private Single() { } public static Single getInstance() { if(s==null) { synchronized(Single.class) { if(s==null) s=new Single(); } } return s; } } 多线程的死锁程序！]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>第11天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础（六）]]></title>
    <url>%2F2018%2F09%2F07%2Fjava%E7%AC%AC%E5%8D%81%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[日积月累异常finally finally中定义的代码一定是会运行的代码。比如用在数据的关闭，避免占用数据库连接。通常用于关闭资源。 记住一点，catch是用于处理异常，如果没有catch就代表异常没有被处理过，如果该异常时检测时异常，那么必须声明。 异常在子父类覆盖中的体现： 子类在覆盖父类时，如果父类的方法抛出异常，那么子类的覆盖方法，只能抛出父类的异常或者该异常的子类 如果父类抛出多个异常，那么子类在覆盖该方法时，只能抛出父类异常的子集 如果父类或者接口的方法中没有异常抛出，那么子类在覆盖方法时，也不可以抛出异常。如果子类方法发生了异常，就必须要进行try处理。绝对不能抛。 异常练习 有一个圆形和长方形。都可以获取面积，对于面积如果出现非法的数值，视为是获取面积时出现问题。问题通过异常来表示。 异常总结 异常：是对问题的描述，将问题进行封装。 异常体系： Throwable Error Exception RuntimeException 异常体系的特点：异常体系中的所有类以及建立的对象都具有可抛性。也就是说可以被throw和throws关键字所操作。只有异常体系具备这个特点。 throw和throws的用法：throw定义在函数内，用于抛出异常对象。throws定义在函数上，用于抛出异常类，可以抛出多个用逗号隔开。 当函数内容有throw抛出异常对象，并未进行try处理，必须要在函数上声明，都在编译失败。注意，RuntimeException除外。也就是说，函数内如果抛出的RuntimeException异常，函数上可以不用声明。如果函数声明了异常，调用者需要进行处理。处理方法可以throws可以try。异常有两种： 编译时被检测异常；该异常在编译时，如果没有处理（没有抛出，没有try），编译失败 运行时异常（编译时不检测）；在编译时，不需要处理，编译器不检查。该异常的发生，建议不处理，让程序停止。需要对代码进行修正。 finally中定义的通常是关闭资源代码，因为资源必须释放 finally只有一种情况无法执行，那就是当执行到System.exit(0);finally不会执行 自定义异常：定义类继承Exception或者RuntimeException。为了让该自定义类具备可抛性；让该类具备操作异常的共性方法。当要定义自定义的信息时，可以使用父类已经定义好的功能。异常信息传递给父类的构造函数 自定义异常：按照java的面向对象思想，将程序中出现的特有问题进行封装 异常的好处：将问题进行封装。将正常流程代码和问题处理代码向分离，方便于阅读 异常的处理原则：处理方式有两种：try或者throws。调用到抛出异常的功能时，抛出几个，就处理几个。（一个try对应多个catch）。多个catch，父类的catch放到最下面。catch内，需要定义针对性的处理方式。不要简单的定义printStackTrace，输出语句。也不要不写。当捕获到的异常，本功能处理不了时，可以继续在catch中抛出。如果该异常处理不了，但并不属于该功能出现的异常。可以将异常转换后，再抛出和该功能相关的异常。或者异常可以处理，当需要将异常产生的和本功能相关的问题提供出去，当调用者知道，并处理。也可以将捕获异常处理后，转换新的异常。 异常的注意事项：在子父类覆盖时，子类抛出的异常必须是父类的异常的子类或者子集。如果父类或者接口没有异常抛出时，子类覆盖出现异常，只能try不能抛。 包package 包对类文件进行分类管理。给类提供多层命名空间。写在程序文件的第一行。类名的全称的是 包名.类名。包也是一种封装形式。 包与包之间访问，被访问的包中的类以及类中的成员，需要public修饰。 不同包中的子类还可以直接访问父类中protected权限修饰的成员。 public protected default private 为了简化类名的书写，就使用一个关键字，import。import导入的是包中的类。所以import packb.*;与import packb.haha.*;不太一样。建议：不要写通配符*，需要用到包中的哪个类，就写到哪]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>第十天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础（五）]]></title>
    <url>%2F2018%2F09%2F07%2Fjava%E7%AC%AC%E4%B9%9D%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[日积月累内部类 内部类好处：可以不用创建对象就能直接访问相对内部类的外部类的成员 内部类访问规则:①内部类可以直接访问外部类中的成员，包括私有。之所以能直接访问外部类中的成员，是因为内部类中持有一个外部类的引用，格式：外部类名.this②外部类访问内部类，必须要建立内部类对象。 访问格式：当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中直接建立内部类对象。 格式： 外部类名.内部类名 变量名 = 外部类对象.内部类对象；如 Outer.Innter in = new Outer().new Inner()； 当内部类在成员位置上，就可以被成员修饰符所修饰。比如，private:将内部类在外部类中进行封装。 static：内部类就具有静态特性；当内部类被static修饰后，只能直接访问外部类中的static成员，出现了访问局限。在外部其他类中，如何直接访问static内部类的非静态成员呢？new Outer.Inner().function();在外部其他类中，如何直接访问static内部类的静态成员呢？Outer.Inner.function();注意：当内部类中定义了静态成员，该内部类必须是static。当外部类中的静态方法访问内部类时，内部类也必须是static的 什么时候使用内部类？当描述事物时，事物的内部还有事物，该事物用内部类来描述。因为内部事物在使用外部事物的内容。 1234class Body&#123; private class Heart&#123;&#125;&#125; 内部类定义在局部时，①不可以被成员修饰符修饰②可以直接访问外部类中的成员，因为还持有外部类中的引用。但是不可以访问他所在的局部中的变量，只能访问被final修饰的局部变量。 匿名内部类 匿名内部类：匿名内部类其实就是内部类的简写格式。 定义匿名内部类的前提：内部类必须是继承一个类或者实现接口 匿名内部类的格式： new 父类或者接口(){定义子类的内容} 其实匿名内部类就是一个匿名子类对象。这个对象带有内容。 匿名内部类中定义的方法最好不要超过2个。 new Object();与new Object(){};的区别：new Object(); 是创建Object对象。new Object(){}; 是创建Object子类对象。 异常概述 异常：就是程序在运行时出现不正常情况。 异常由来：问题也是现实生活中一个具体的事物，也已通过java的类的形式进行描述。并封装成对象。其实就是java对不正常情况进行描述后的对象体现。 对于问题的划分：两种：一种是严重的问题；一种是非严重的问题。对于严重的，java通过Error类进行描述。对于非严重的，java通过Exception类进行描述。对于Error一般不编写针对性的代码进行处理；对于Exception可以使用针对性的处理方式进行处理。 无论Error或者Exception都具有一些共性内容。比如：不正常情况的信息，引发原因等。 异常的处理java提供了特有的语句处理： 123456789101112try&#123; 需要被检测的代码&#125;catch(异常类 变量)&#123; 处理异常的代码（处理方式）&#125;finally&#123; 一定会执行的语句&#125; 对捕获到的异常对象进行常见方法操作。其实jvm默认的异常处理机制，就是在调用printStackTrace方法。打印异常的堆栈的跟踪信息。 throws异常声明：在功能上通过throws的关键字声明了该功能有可能会出现问题。 对多异常的处理：①声明异常时，建议声明更为具体的异常。这样处理的可以更具体。②处理形式是多加catch，处理对应的异常③函数中有异常抛出就停止运行了；所以不会同时出现多个异常④对方声明几个异常，就对应几个catch块。如果多个catch块中的异常出现继承关系，父类异常catch块放在最下面。⑤建议在进行catch处理时，catch中一定要定义具体的处理方式，不要简单定义一句e.printStackTrace(),也不要简单的就书写一条输出语句。 因为项目中会出现特有的问题，而这些问题并未对java所描述并封装对象。所以对于这些特有的问题可以按照java的对问题封装的思想。将特有的问题，进行自定义的异常封装。 自定义异常。 当在函数内部出现了throw抛出异常对象，那么就必须要给对应的处理动作。要么在内部try catch处理，要么在函数上声明让调用者处理。一般情况，在函数内出现异常，函数上需要声明（throws）。 如何定义异常信息呢？因为父类中已经把异常信息的操作都完成了。所以子类只要在构造时，将异常信息传递给父类通过super语句。那么就可以直接通过getMessage方法获取自定义的异常信息。 自定义异常：必须是自定义类继承Exception。继承Exception原因：异常体系有一个特点：因为异常类和异常对象都被抛出。他们都具备可抛性。这个可抛性是Throwable这个体系中独有的特点。只有这个体系中的类和对象才可以被throws和throw操作 throw和throws的区别。throw使用在函数内。throws使用在函数上。throw后跟的是异常对象。throws后跟的是异常类，可以跟多个；用逗号隔开。 Exception中有一个特殊的子类异常RuntimeException运行时异常。如果在函数内容抛出该异常，函数上可以不用声明，编译一样通过。如果在函数上声明了该异常。调用者可以不用进行处理。编译一样通过。之所以不用在函数中声明，是因为不需要让调用者处理。当该异常发生，希望程序停止。因为在运行时，出现了无法继续运算的情况，希望停止程序后，程序员对代码进行修正。 自定义异常时，如果该异常的发生，无法再继续进行运算，就让自定义异常继承RuntimeException。 对于异常分两种：①编译时被检测的异常②编译时不被检测的异常（运行时异常，RuntimeException以及其子类） throw其实也是语句结束的标识，当抛出异常，程序停止运行了；所以在throw下面不要写其他的方法，因为不会执行。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>第九天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础（四）]]></title>
    <url>%2F2018%2F09%2F06%2Fjava%E7%AC%AC%E5%85%AB%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[日积月累多态 多态：可以理解为事物存在的多种体现形式。如人分为男人女人；动物：猫狗。猫 x = new 猫()；动物 x = new 猫(); 多态的体现：强迫子类重写方法；父类的引用指向了自己的子类对象。父类的引用也可以接受自己的子对象 多态的前提：①必须是类与类之间有关系，要么继承要么实现。②通常还有一个前提：存在覆盖 多态的弊端：提高了扩展性，但是只能使用父类的引用访问父类中的成员 多态的好处：提高了程序的扩展性 多态的应用 1234567Animal a = new Cat();//类型提升，向上转型a.eat();//如果想要调用猫特有方法时，如何操作？//强制将父类中的引用,转成子类类型。向下转型。Cat c = (Cat)a;c.catchMouse();//千万不能将父类对象转成子类类型。能转换的是父类引用指向了自己的子类对象时，该引用可以被提升，也可以被强制转换。多态自始至终都是子类对象在做变化。 多态使用的注意事项： 在多态中成员函数的特点：在编译时期：参阅引用型变量所属的类中是否有调用的方法。如果有，编译通过，如果没有编译失败。在运行时期：参阅对象所属的类中是否有调用的方法。简单总结就是：成员函数在多态调用时，编译看左边，运行看右边。如，Fu f=new Zi(); 在多态中，成员变量的特点：无论编译和运行，都参考左边（引用变量的类） 在多态中，静态成员函数的特点：无论编译和运行，都参考左边 多态的扩展示例 数据库的操作： 连接数据库。JDBC Hibernate 操作数据库。c creat r read u update d delete 关闭数据库连接 dao: data access object object类 Object：是所有对象的直接后者间接父类，传说中的上帝。该类中定义的肯定是所有对象都具备的功能 equals比较地址值。Object类中已经提供了对对象是否相同的比较方法。如果自定义类中也有比较相同的功能，没有必要重新定义。只要沿袭父类中的功能，建立自己特有的比较内容即可。这就是覆盖 toString()。对象都有自己的地址。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>第八天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础（三）]]></title>
    <url>%2F2018%2F09%2F06%2Fjava%E7%AC%AC%E4%B8%83%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[日积月累继承 例如学生和工人的共性都有姓名和年龄，那么可以将共性描述提取出来，单独进行描述；只要让学生和工人与单独描述的这个类有关系，就可以了。 继承：①提高了代码的复用性②让类与类之间产生了关系，有了这个关系，才有了多态的特性 注意：千万不要为了获取其他类的功能，简化代码而继承；必须是类与类之间有所属关系才可以继承。所属关系是is a。 父类是不断从子类中抽取出的共性体现。 Java语言中：java只支持单继承，不支持多继承。因为多继承容易带来安全隐患：当多个父类中定义了相同功能，当功能内容不同时，子类对象不确定要运行哪一个。优化了c++的多继承，java保留了这种机制，并用另一种体现形式来完成表示，多实现。 java支持多层继承。（爷爷-父亲-儿子）也就是一个继承体系，如何使用一个继承体系中的功能呢？想要使用体系，先查阅体系中父类的描述，因为父类中定义的是该体系中共性功能。通过了解共性功能，就可以知道该体系的基本功能。那么这个体系已经可以基本使用了。那么在具体调用时，要创建最子类的对象，为什么呢？一是因为有可能父类不能创建对象，二是创建子类可以使用更多的功能，包括基本的也包括特有的。 简单一句话：查阅父类功能，创建子类对象使用功能。（java中类只能有一个父亲） 聚集关系 聚合：一个球队有多名球员 组合：手是身体的一部分，心脏是身体的一部分。手和心脏就是组合关系。 球员少一个没关系，手（心脏）不能少 子父类中变量的特点 子父类出现后，类成员的特点：类中成员：变量，函数，构造函数。①变量：this是本类的引用，super是父类的引用。如果子父类中出现非私有的同名成员变量时，子类要访问本类中的变量，用this；子类要访问父类中的同名变量，用super。super的使用和this的使用几乎一致。this代表的是本类对象的引用。super代表的是父类对象的引用。 子父类中函数的特点 覆盖（重写）：当子类出现和父类一模一样的函数时，当子类对象调用该函数，会允许子类函数的内容。如同父类的函数被覆盖一样。 当子类继承了父类，沿袭了父类的功能到子类中；但是子类中虽具有该功能，但是功能的内容和父类不一致，这时，没有必要定义新功能，而是覆盖，保留父类的功能定义，并重写父类的功能方法。 提高扩展性 覆盖注意事项：①子类覆盖父类，必须保证子类权限大于等于父类权限，才可以覆盖，否则编译失败②静态只能覆盖静态 重载：只看同名函数的参数列表。重写：子父类方法要一模一样 子父类中的构造函数 在对子类对象进行初始化时，父类的构造函数也在运行；那是因为子类的构造函数默认第一行有一条隐式的语句super（）；super（）：会访问父类中空参数的构造函数，而且子类中所有的构造函数默认第一行都是super（）。 为什么子类一定要访问父类中的构造函数？因为父类中的数据，子类可以直接获取，所以子类对象获取时，需要查看父类是如何对这些数据进行初始化的。所以子类在初始化对象时，需要先访问一下父类中的构造函数。如果要访问父类中指定的构造函数，可以通过手动定义super函数语句来指定。 super语句一定要放在子类构造函数的第一行。 结论：子类的所有的构造函数，默认都会访问父类中空参数的构造函数。因为子类中每一个构造函数内的第一行都有一句隐式super（）。当父类中没有空参数的构造函数时，子类必须手动通过super语句形式来指定要访问的构造函数。当然子类的构造函数第一行也可以手动指定this语句来访问本类中的构造函数。子类中至少会有一个构造函数会访问父类中的构造函数。 final关键字 final：最终。作为一个修饰符。①可以修饰类，函数，变量②被final修饰的类不可以被继承。防止被子类复写。③被final修饰的方法不可以被复写④被final修饰的变量时一个常量，只能赋值一次，既可以修饰成员变量，又可以修饰局部变量⑤内部类定义在类中的局部位置上时，只能访问该局部被final修饰的局部变量。 当在描述事物时，一些数据的出现值是固定得而，那么这是为了增强阅读性，都给这些值起一个名字，方便阅读。而这个值不需要被改变，所以加上final关键字。作为常量，常量的书写规范所有字母都大写，如果多个单词组成。单词间通过_连接。 抽象类 当多个类中出现了相同功能，但是功能主体不同，这时可以进行向上抽取。这时，只抽取功能定义，而不抽取功能功能主体。 抽象：看不懂的功能。 抽象方法一定在抽象类中 抽象方法和抽象类都必须被abstract关键字修饰 抽象类不可以用new创建对象。因为调用抽象方法没意义 抽象类中的抽象方法要被使用，必须由子类复写起所有的抽象方法后，建立子类对象调用。如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类 抽象类和一般类没有太大不同。该如何描述事物，就如何描述事物，只不过，该事物出现了一些看不懂的东西。这些不确定的部分，也是该事物的功能，需要明确出现。但是无法定义主体。通过抽象方法来表示。 抽象类比一般类多了抽象函数。就是类中可以定义抽象方法。抽象类不能实例化。 特殊情况：抽象类中可以不定义抽象方法，这样做仅仅是不让该类建立对象 模范方法模式 什么是模板方法呢？在定义功能时，功能的一部分是确定的，但是有一部分是不确定，而确定的部分在使用不确定的部分；那么这时就将不确定的部分暴露出去，由该类的子类去完成。 接口 接口：初期理解，可以认为是一个特殊的抽象类；当抽象类中的方法都是抽象的，那么该类可以通过接口的形式来表示。 class用于定义类，interface用于定义接口 接口定义时，格式特点： 接口中常见定义：常量，抽象方法 接口中的成员都有固定修饰符。常量：public static final。方法：public abstract 接口中的成员都是public的 类与类之间继承关系，类与接口之间实现关系。继承，子类能直接用父类中的一些东西，不用很辛苦；实现，子类必须重写接口的所有抽象方法，非常辛苦。 接口不能创建对象，因为有抽象方法。需要被子类实现，子类对接口中的抽象方法全都覆盖后，子类才可以实例化，否则子类是一个抽象类。 接口可以被类多实现，也是对多继承不支持的转换形式，java支持多形式。 接口间的关系可以是（多）继承 接口的特点： 接口是对外暴露的规则 接口是程序的功能扩展 接口可以用来多实现 类与接口之间是实现关系，而且类可以继承一个类的同时实现多个接口 接口与接口之间可以有继承关系]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>第七天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础（二）]]></title>
    <url>%2F2018%2F09%2F06%2Fjava%E7%AC%AC%E5%85%AD%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[日积月累静态代码块 格式： 1234static&#123; 静态代码块中的执行语句&#125; 特点：随着类的加载而执行，只执行一次，并优先于主函数执行。用于给类进行初始化的。 设计模式 其实是一种思想，用来解决问题最有效的方法。 java中有23种设计模式： 单例设计模式：解决一个类在内存中只存在一个对象。想要保证对象唯一：①为了避免其他程序过多建立该类对象，先禁止其他程序建立该类对象②还为了想让其他程序可以访问到该类对象，只好在本类中，自定义一个对象③为了方便其他程序对自定义对象的访问，可以对外提供一些访问方式。怎么用代码体现这三步？①将构造函数私有化②在类中创建一个本类对象③提供一个方法可以获取到该对象 对于事物该怎么描述，还怎么描述。当需要将事物的对象保证在内存中唯一时，就将以上三步加上即可。如果方法要被调用，要用类.方法名()获得一个实例化，必须使用static关键字来修饰方法；该方法只能使用静态成员变量。 区分饿汉式和懒汉式：懒汉式对象初始化为null（延时加载）。饿汉式：类一进内存，就已经创建好了对象。懒汉式：类进内存，对象还没有存在，只有调用了获取对象方法时，才建立对象。开发时其实经常用饿汉式，这样比较安全；因为懒汉式被多个人同时调用时，会同时进行，被卡住，但是可以用synchronized关键字进行锁住，并多重判断； 记住原则：定义单例，建议使用饿汉式]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>第六天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础]]></title>
    <url>%2F2018%2F09%2F05%2F9.5.1%2F</url>
    <content type="text"><![CDATA[日积月累构造函数 当一个类中没有定义构造函数时，那么系统会默认给该类加入一个空参数的构造函数 当定义了构造函数之后，不会再给出默认的构造函数 不同的构造函数对不同的对象进行初始化 构造函数主要帮助进行对象初始化 构造函数和一般函数在写法上有不同 构造函数是在对象一建立就运行。给对象初始化 一般方法是对象调用才执行，给是对象添加对象具备的功能 一个对象建立，构造函数只运行一次；而一般方法能被该对象调用多次 什么时候定义构造函数呢？当分析事物时，该事务存在就具备一些特性或者行为，那么这些内容定义在构造函数中 构造代码块 作用：给对象进行初始化。对象一建立就运行，而且优先于构造函数执行。和构造函数的区别：构造代码块是给所有对象进行统一初始化（不同对象共性的初始化内容）。而构造函数是给对应的对象初始化 this关键词 局部变量的名称和成员变量名称相同时，用来区分；用于构造函数间调用，一般函数不能调用构造函数，this用于构造函数 this为什么能解决这个问题？代表对象 this到底代表什么？this就代表本类的对象，到底代表哪一个呢？（可以new很多对象）this代表它所在函数所属对象的引用。简单说：哪个对象在调用this所在的函数，this就代表哪个对象 this的应用：当定义类中功能时，该函数内部要用到调用该函数对象时，这时就用this来表示这个对象。但凡本类中功能内部都使用了本类对象，都用this表示 构造函数间调用只能使用this this语句只能定义在构造函数的第一行，this()。 Static关键字 static静态，用法：是一个修饰符，用于修饰成员（成员变量，成员函数）。static修饰的内容被共享，不再放在堆内存中（在方法区，共享区，数据区），节约了内存开销 当成员被静态修饰后，就多了一个调用方式，除了可以被对象调用外，还可以直接被类名调用。（类名.静态成员） static特点：①随着类的加载而加载，随类的消失而消失。说明他的生命周期最长②优先于对象存在。明确一点：静态是先存在，对象是后存在③被所有对象所共享④可以被类名直接调用 被多个对象共有就可以用静态 实例变量和类变量的区别（静态成员变量）：①类变量随着累的加载而存在于方法区中。实例变量随着对象的建立而存在于堆内存中②生命周期：类变量生命周期最长，随着类的消失而消失。实例变量生命周期随着对象的消失而消失。 静态的使用注意事项：①静态方法只能访问静态成员。非静态方法能既可以访问静态，也可以访问非静态②静态方法中不可以定义this，super关键字。因为静态优先于对象存在，所以静态方法中不可以出现this③主函数是静态的 静态有利有弊：利：对对象的共享数据进行单独空间的存储，节省空间。没有必要每个对象中都存储一份。可以直接被类名调用。弊端：生命周期过长。访问出现局限性。（静态虽好，只能访问静态） main函数 主函数：是一个特殊的函数，作为程序的入口，可以被jvm调用 主函数的定义：public：代表着该函数访问权限是最大的static:代表主函数随着累的加载就已经存在了void：主函数没有具体的返回值main：不是关键字，是一个特殊的单词，能被jvm识别函数的参数：（String[] args)，参数类型是一个数组，该数组中的元素是字符串。字符串类型的数组。 主函数是固定格式的:jvm识别。主函数中唯一能改的地方是args。jvm在调用主函数时，传入的是new String[0]（长度为0）； 静态什么时候使用 要从两方面下手：因为静态修饰的内容有成员变量和函数。什么时候定义静态变量（类变量）呢？当对象中出现共享数据时，该数据被静态所修饰。对象中的特有数据要定义成非静态存在于堆内存中 什么时候定义静态函数呢？当功能内部没有访问到非静态数据（对象的特有数据），那么该功能可以定义成静态的。 静态函数只能调用静态函数 每一个应用程序中都有共性的功能，可以将这些功能进行抽取，独立封装，以便复用。 假如我们定义一个数组工具类，我们可以建立对象使用类中的方法，对数组操作。但是，对象并未封装特有数据；操作数组的每一个方法都没有用到类对象中的特有数据。这时就考虑，让程序更严谨，是不需要对象的。可以将工具类中的方法定义成static的，直接通过类名调用即可。将方法都静态后，可以方便于使用，但是该类还是可以被其他程序建立对象的。为了更加严谨，该类不能建立对象，可以将构造函数设置为私有化，防止被别人使用构造方法。 java说明书 通过文档注释来完成。 @author 张三 @version V1.1]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于ZigBee的温室大棚监测]]></title>
    <url>%2F2018%2F09%2F05%2F9.5%2F</url>
    <content type="text"><![CDATA[项目实现项目需要实现的功能ZigBee传感器 ZigBee需要的传感器获取数据 通过温湿度传感器获取大棚温度和湿度 光照传感器获取大棚内的光照强度 传感器数据发送包到协调器 服务器端 服务器解析由协调器发送来的包得到三种属性值 将三种属性值插入数据库 接收客户端的指令，进行操作 对数据库进行查询操作 对传感器发送指令，并让传感器做出相应的操作 客户端 查询大棚的温湿度、光强 读取天气预报 农作物生长最适宜的温湿度和光强查询]]></content>
      <categories>
        <category>大四课设</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编程基础刷题笔记（一）]]></title>
    <url>%2F2018%2F09%2F04%2F9.4.2%2F</url>
    <content type="text"><![CDATA[日积月累数据库、数据库系统和数据库管理系统三者之间的关系是( )数据库系统包括数据库和数据库管理系统 [数据库系统&gt;数据库管理系统&gt;数据库] 若用一个大小为6的数组来实现循环队列，队尾指针是rear、队头是front。当前rear和front的值分别为0和3，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为2和4 求最短路径的FLOYD算法的时间复杂度为（）。O(n3) 对n(n≥2)个权值均不相同的字符构成哈夫曼树， 下列 关于该 哈弗曼 树的叙述中，错误的是（A）A.该树一定是一棵完全二叉树B.树中一定没有度为1的结点C.树中两个权值最小的结点一定是兄弟结点D.树中任一非叶结点的权值一定不小于下一层任一结点的权值 数据库恢复的基础是利用转储的冗余数据。这些转储的冗余数据包括（ C）?A.数据字典、应用程序、审计档案、数据库后备副本B.数据字典、应用程序、日志文件、审计档案C.日志文件、数据库后备副本D.数据字典、应用程序、数据库后备副本 Which method you define as the starting point of new thread in a class from which n thread can be execution?public void run() 以下哪些不是链表的特征(ACD)？A.数据在内存中一定是连续的B.插入或删除时，无需移动其他元素C.可以随机访问表内的元素D.需要事先估计存储空间]]></content>
      <categories>
        <category>编程基础专项</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java刷题笔记（一）]]></title>
    <url>%2F2018%2F09%2F04%2F9.4.1%2F</url>
    <content type="text"><![CDATA[日积月累以下关于Object类的说法正确的是（A）A.Java中所有的类都直接或间接继承自Object，无论是否明确的指明，无论其是否是抽象类。B.Java中的接口(interface)也继承了Object类C.利用“==”比较两个对象时，Java调用继承自Object的equals方法，判断是否相等。D.如果类的定义中没有重新定义toString()方法，则该类创建的对象无法使用toStrig()方法。 给出以下代码1234567891011public class TestObj&#123; public static void main(String[] args)&#123; Object o=new Object()&#123; public boolean equals(Object obj)&#123; return true; &#125; &#125;; System.out.println(o.equals(“Fred”)); &#125;&#125;请给出结果:() true 关于数据库连接的程序，以下哪个语句的注释是错误的（ ）A.Class.forName(“sun.jdbc.odbc.JdbcOdbcDriver”); //指定MySQL JDBC驱动程序B.String url=“jdbc:odbc:student_access”; 指定数据源为student_accessC.Connection con=DriverManager.getConnection(url); //创建连接指定数据库的对象D.Statement stmt=con.creatStatement();//创建执行SQL语句的Statement对象 如下代码的输出是12345678910111213141516171819202122232425package Test;public class Test &#123; private static void test(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; try &#123; if (arr[i] % 2 == 0) &#123; throw new NullPointerException(); &#125; else &#123; System.out.print(i); &#125; &#125; finally &#123; System.out.print(&quot;e&quot;); &#125; &#125; &#125; public static void main(String[]args) &#123; try &#123; test(new int[] &#123;0, 1, 2, 3, 4, 5&#125;); &#125; catch (Exception e) &#123; System.out.print(&quot;E&quot;); &#125; &#125; &#125; 可以得到的结论是（ eE）]]></content>
      <categories>
        <category>java专项</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库第一章（绪论）]]></title>
    <url>%2F2018%2F08%2F27%2F8.27%2F</url>
    <content type="text"><![CDATA[数据库基础第二章1.试述关系模型的三个组成部分关系模型是由关系数据结构、关系操作集合和关系完整性约束三部分组成。 2.简述关系数据语言的特点和分类关系代数语言关系演算语言：元组关系演算语言和域关系演算语言SQL：具有关系代数和关系演算双重特点的语言。这些关系数据语言的共同特点是，语言具有完备的表达能力，是非过程化的集合操作语言，功能强，能嵌入高级语言中使用 3.定义并理解下列术语，说明他们之间的联系与区别 域，笛卡尔积，关系，元组，属性 域：是一组具有相同数据类型的值的集合 笛卡尔积：是域上的一种集合运算 关系：D1xD2xD3x…xDn的子集在域D1,D2,D3,…,Dn上的关系表示为R(D1,D2,D3…,Dn) 元组：笛卡尔积中每一个元素(d1,d2,….,dn)叫做一个元组 属性： 主码，候选码，外码 主码：若一个关系有多个候选码，则选定其中一个为主码 候选码：关系中的某一属性的值能唯一标识一个元组，而其子集不能，则称该属性组为候选码 外码：在本关系中不是主码，在另一关系中是主码 关系模式，关系，关系数据库 关系模式：关系模式是型，关系是值。关系模式是对关系的描述 关系：关系是元组的集合，是关系模式在某一时刻的状态和内容 关系数据库：关系数据库的值是这些关系模式在某一时刻对应的关系的集合 4.试述关系模型的完整性规则。在参照完整性中，什么情况下外码属性的值可为空实体完整性规则是指若属性A是基本关系R的主属性，则属性A不能为空值。若属性F是基本关系R的外码，它与基本关系S的主码Ks相对应，则对于R中每个元组在F上的值必须为：或者取空值（F上的每个属性值均为空值）；或者等于S中某个元组的主码值。即属性F本身不是主属性，则可以取空值，否则不能取空值。 5.试述等值连接和自然连接的区别和联系连接运算符是“=”的连接运算称为等值连接。它是从关系R与S的广义笛卡尔积中选取A，B属性值相等的那些元组自然连接是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并在结果中把重复的属性列去掉 6.关系代数的基本运算有哪些？如何用这些基本的运算来表示其他运算？并，差，笛卡尔积，投影和选择5种运算为基本的运算。其他三种运算，即交，连接和除，均可以用这5种基本运算来表达。 第一章1.试述关系模型的概念，定义并解释以下术语：关系，属性，域，元组，码，分量，关系模式关系模型是最重要的一种数据模型。关系：一个关系对应通常说的一张表元组：表中的一行即为一个元组属性：表中的一列即为一个属性，给每一个属性起一个名称即属性名码：也称码键。表中的某个属性组，它可以唯一确定一个元组域：域是一组具有相同数据类型的值的集合分量：元组中的一个属性值关系模式：对关系的描述，一般表示为R(D1,D2,…Dn) 2.试述数据库系统的三级模式结构，并说明这种结构的优点是什么数据库系统的三级模式结构：外模式，模式，内模式。外模式：是数据库用户能看见和使用的局部数数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示模式：是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。模式描述的是数据的全局逻辑结构。外模式涉及的是数据的局部逻辑结构，通常是模式的子集内模式：亦称存储模式，是数据在数据库系统内部的表示，即对数据的物理结构和存储方式的描述。数据库系统的三级模式是对数据的三个抽象级别，它把数据的具体组织留给DBMS管理，使用户能逻辑抽象地处理数据而不必关心数据在计算机内的表示和存储。为了能在内部实现这三个抽象层次的联系和转换，数据库系统在咋还三级模式之间提供了两层映像：外模式/模式映像和模式/内模式映像。正是这两层映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性。 第三章1.试述SQL的特点①综合统一。SQL语言集数据定义语言DDL，数据操纵语言DML，数据控制语言DCL的功能于一体②高度非过程化③面向集合的操作方式④以同一种语法结构提供两种使用方式。SQL语言既是自含式语言，又是嵌入式语言 2.什么是基本表？什么是视图？两者的区别和联系是什么？基本表是本身独立存在的表，在SQL中一个关系就对应一个表。视图是从一个或几个基本表导出的表。视图本身不堵你存储在数据库中，是一个虚表。即数据库中只存放视图的定义而不存放视图对应的数据，这些数据仍放在导出视图的基本表中。视图在概念上与基本表等同，用户可以如同基本表那样使用视图，可以在视图上再定义视图。 3.试述视图的优点①视图能简化用户的操作②视图使用户能以多种角度看待同一数据③视图对重构数据库提供了一定程度的逻辑独立性④视图能对机密数据提供安全保护 第四章1.什么是数据库的安全性数据库的安全性是指保护数据库以防止不合法的使用所造成的数据泄露，更改或破坏 2.试述实现数据库安全性控制的常用方法和技术实现数据库安全性控制的常用方法和技术有：①用户标识和鉴别：该方法由系统提供一定的方式让用户标识自己的名字或身份。每次用户要求进入系统时，由系统进行核对，通过鉴定后才提供系统的使用权②存取控制：通过用户权限定义和合法权检查，确保只有合法权限的用户访问数据库，所有未被授权的人员无法存取数据。③视图机制：为不同的用户定义视图，通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动地对数据提供一定程度的安全保护④审计：建立审计日志，把用户对数据库的所有操作自动记录下来放入审计日志中，DBA可以利用审计跟踪的信息，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等。⑤数据加密：对存储和传输的数据进行加密处理，从而使得不知道解密算法的人无法获取数据的内容 第五章1.什么是数据库的完整性数据库的完整性是指数据的正确性和相容性 2.数据库的完整性概念和数据库的安全性概念有什么区别和联系数据的完整性和安全性是两个不同的概念，但是有一定的联系。前者是为了防止数据库中存在不符合语义的数据；防止错误信息的输入和输出，即所谓的垃圾进垃圾出所造成的无效操作和错误结果。后者是为了保护数据库防止恶意的破坏和非法的存取。也就是说，安全性措施的防范对象是非法用户和非法操作，完整性措施的防范对象是不合语义的数据。 3.什么是数据库的完整性约束条件？可分为哪几类？完整性约束条件是指数据库中的数据应该满足的语义约束条件。一般可以分为六类：静态列级约束、静态元组约束、静态关系约束、动态列级约束、动态元组约束、动态关系约束 4.DBMS的完整性控制机制应具有哪些功能？DBMS的完整性控制机制应该具有三个方面的功能：①定义功能，即提供定义完整性约束条件的机制②检查功能，即检查用户发出的操作请求是否违背了完整性约束条件③违约反应，如果发现用户的操作请求使数据违背了完整性约束条件，则采取一定的动作来保证数据的完整性 第七章1.试述数据库设计过程一、需求分析；二、概念结构设计；三、逻辑结构设计；四、数据库的物理设计；五、数据库实施；六、数据库运行和维护 2.试述数据库设计各个阶段上的设计描述一、需求分析：准确了解与分析用户需求（包括数据与处理）二、概念结构设计：通过对用户需求进行综合、归纳与抽象，形成一个独立于具体DBMS的概念模型三、逻辑结构设计：将概念模型转换为某个DBMS所支持的数据模型，并对其优化四、数据库物理设计：为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）五、数据库实施：设计人员运用DBMS提供的数据语言、工具及宿主语言，根据逻辑设计和物理设计的结果建立数据库，编制与调试应用程序，组织数据入库，并进行试运行六、数据库运行和维护：在数据库系统运行过程中对其进行评价、调整与修改 第十一章1.在数据库中为什么要用并发控制数据库是共享资源，通常有许多个事务同时运行。当多个事务并发地存取数据库时就会产生同时读取和/或修改同一数据的情况。若对并发操作不加控制就可能会存取和存储不正确的数据，破坏数据库的一致性。所以数据库管理系统必须提供并发控制机制 2.并发操作可能会产生哪几类数据不一致？用什么方法能避免各种不一致的情况并发操作带来的数据不一致性包括三类：丢失修改、不可重复读、脏数据。丢失修改：两个事务T1和T2读入同一数据并修改，T2提交的结果破坏了（覆盖了）T1提交的结果，导致T1的修改被丢失不可重复读：事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果脏数据：事务T1修改某一数据后，将其写会磁盘，事务T2读取统同一数据，T1由于某种原因撤销更改，T2读到的数据就是不正确的数据 避免不一致性的方法和技术就是并发控制。最常用的技术是封锁技术。也可以用其他技术，例如在分布式数据库系统中可采用时间戳方法来进行并发控制 3.什么是封锁？基本的封锁类型有几种？试述他们的含义封锁就是事务T在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁。加锁后事务T对该数据对象就有了一定的控制，在事务T释放它的锁之前，其他的事务不能更新此数据对象。封锁是实现并发控制的一个非常重要的技术 封锁的技术有两种：读锁（S）和写锁（X）；若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放了A的锁。若事务T对数据对象A加上S锁，则事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁 第十章1.登记日志文件时为什么必须先写日志文件，后写数据库？把对数据的修改写到数据库中和把表示这个修改的日志记录写到日志文件中是两个不同的操作。有可能在这两个操作之间发生故障，即这两个写操作只完成了一个。如果先写了数据库修改，而在运行记录中没有登记这个修改，则以后就无法恢复这个修改了。如果先写日志文件，但没有修改数据库，按日志文件恢复时只不过是多执行一次不必要的UNDO操作，并不会影响数据库的正确性。 2.针对不同的故障，试给出恢复的策略和方法事务故障的恢复：事务故障是指事务在运行至正常种终止点前被终止，这时恢复子系统应利用日志文件撤销（UNDO）此事务对数据库进行的修改。事务故障的恢复是由系统自动完成的，对用户是透明的。恢复步骤： 反向扫描日志文件，查找该事务的更新操作 对事务的更新操作进行逆操作 继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理 系统故障的恢复：系统故障造成数据库不一致状态的原因有两个，一是未完成事务对数据库的更新可能已写入数据库，二是已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库。因此恢复操作就是要撤销故障发生时未完成的事务，重做已完成的事务。恢复步骤： 正向扫描日志文件，找出在故障发生前已经提交的事务将其事务标识记入重做队列。同时找出故障发生时尚未完成的事务，将其事务标识记入撤销队列 对撤销队列中的各个事务进行撤销处理 对重做队列的各个事务进行重做处理 介质故障的恢复：发生介质故障后，磁盘上的物理数据和日志文件被破坏，这是严重的一种故障，恢复方法是重装数据库，然后重做已完成的事务。恢复步骤： 装入最新的数据库后备副本，使数据库恢复到最近一次转储的一致性状态 装入相应的日志文件副本，重做已完成的事务]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Strength]]></title>
    <url>%2F2018%2F08%2F23%2F8.23.3%2F</url>
    <content type="text"><![CDATA[健身基础全身各块肌肉，较好的训练动作每块肌肉一个专属动作： 最佳整体胸肌增长，哑铃平板卧推 最佳背阔肌宽度增长，宽握高位下拉（宽距引体） 最佳整体三角肌增长，哑铃推举 最佳二头肌增长，窄距反握引体向上 最佳三头肌增长，双杠臂屈伸 最佳股四头肌训练，颈前深蹲 最佳腘绳肌和臀部肌肉增长，罗马尼亚硬拉 最佳斜方肌增长，杠铃耸肩 最佳整体腹部训练，卷腹 最佳核心力量训练，平板支撑 最佳整体肌肉增长，深蹲 增肌9要点要点： 1个小时（训练控制在1小时内） 2个部位 3个动作 4组 一日5餐 6个部位（胸肩背腿腹臀） 7天（一个周期7天） 8RM 9个星期（开始休息1星期）]]></content>
      <categories>
        <category>fit</category>
      </categories>
      <tags>
        <tag>body</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（四十之Android网络应用）]]></title>
    <url>%2F2018%2F08%2F23%2F8.23.2%2F</url>
    <content type="text"><![CDATA[安卓基础Android完全支持JDK本身的TCP,UDP网络通信API，也可以使用ServerSocket、Socket来建立基于TCP/IP协议的网络通信，还可以使用DatagramSocaket、Datagrampacket、MulticastSocket来建立基于UDP协议的网络通信。Android也支持JDK提供的URL、URLConnection等网络通信API。 不仅如此，Android还内置了HttpClient，这样可以非常方便地发送HTTP请求，并获取HTTP响应，通过内置HttpClient，Android简化了与网站之间的交互。令人遗憾的是，Android并未内置对Web Service的支持，为了弥补这种不足，可以利用ksoap2-android项目在Android应用中调用远程Web Service。 基于TCP协议的网络通信TCP/IP通信协议是一种可靠的网络协议，它在通信的两端各建立一个Socket，从而在通信的两端之间形成了网络虚拟链路。一旦建立了它，两端的程序就可以通过它进行通信。Java对基于TCP协议的网络通信提供了良好的封装，Java使用Socket对象来代表两端的通信接口，并通过Socket产生IO流来进行网络通信。 TCP协议基础IP协议是Internet上使用的一个关键协议，它的全称是Internet Protocol，即Internet协议，简称IP协议。通过使用IP协议，使Internet成为一个允许连接不同类型的计算机和不同的操作系统的网络。要使两台计算机彼此之间进行通信，两台计算机必须使用同一种“语言”，IP协议只保证计算机能发送和接受分组数据。IP协议负责将消息从一个主机传送到另一个主机上，消息在传送的过程中被分割成一个个小包。尽管计算机通过安装IP软件，保证了计算机之间可以发送和接收数据，但IP协议还不能解决数据分组在传输过程中可能出现的问题。因此，若要解决可能出现的问题，连接上Internet的计算机还需要安装TCP协议来提供可靠并且无差错的通信服务。TCP协议被称为一种端对端协议。这是因为它为两台计算机之间的连接起了重要作用：当一台计算机需要与另一台远程计算机连接时，TCP协议会让它们建立一个连接——用于发送和接收数据的虚拟链路。TCP协议负责收集这些信息包，并将其按适当的次序放好发送，在接收端收到后再将其正确地还原。TCP协议保证了数据包在传送中准确无误。TCP协议使用重发机制：当一个通信实体发送一个消息给另一个通信实体之后，需要收到另一个通信实体的确认信息，如果没有收到另一个通信实体的确认信息，则会再次重发刚才发送的消息。 使用ServerSocket创建TCP服务器端Java中能接收其他通信实体连接请求的类是ServerSocket，ServerSocket对象用于监听来自客户端的Socket连接，如果没有连接，它将一直处于等待状态。ServerSocket包含一个监听来自客户端连接请求的方法： Socket accept()：如果接收到一个客户端Socket的连接请求，该方法将返回一个与连接客户端Socket对应的Socket；否则该方法将一直处于等待状态，线程也被阻塞 ServerSocket(int port)：用指定的端口port来创建一个ServerSocket。该端口有效整数值：0~65535 ServerSocket(int port,int backlog）：增加一个用来改变连接队列长度的参数backlog ServerSocket(int port,int backing,InetAddress localAddr)：在机器存在多个IP地址的情况下，允许通过localAddr这个参数来指定将该ServerSocket绑定到指定的IP地址 当ServerSocket使用完毕后，调用close（）方法来关闭该ServerSocket。 使用Socket进行通信客户端通常使用Socket的构造器来连接到指定服务器，Socket通常可提供如下两个构造器。 Socket(InetAddress/String remoteAddress,int port)：创建连接到指定远程主机、远程端口的Socket，该构造器没有指定本地地址、本地端口，默认使用本地主机的默认IP地址，默认使用系统动态分配的端口 Socket(InetAddress/String remoteAddress,int port,InetAddress localAddr,int localPort)：创建连接到指定远程主机、远程端口的Socket，并指定本地IP地址和本地端口，适用于本地主机有多个IP地址的情形 Socket提供了如下两个方法来获取输入流和输出流： InputStream getInputStream()：返回该Socket对象对应的输入流，让程序通过该输入流从Socket中取出数据 OutputStream getOutputStream()：返回该Socket对象对应的输入流，让程序通过该输入流向Socket中输入数据 Android已经不允许在UI线程中建立网络连接，需要启动新线程来建立网络连接。 加入多线程使用传统的BufferedReader的readLine()方法读取数据时，在该方法成功返回之前，线程被阻塞，程序无法继续执行。考虑到这个原因，服务器应该为每个Socket单独启动一条线程，每条线程负责与一个客户端进行通信。客户端读取服务器的线程同样会被阻塞，所以系统应该单独启动一条线程，该线程专门负责读取服务器数据。 每个客户端应该包含两条线程：一条负责生成主界面，响应用户动作，并将用户输入的数据写入Socket对应的输出流中；另一条负责读取Socket对应输入流中的数据（从服务器发送过来的数据），并负责将这些数据在程序界面上显示出来 使用URL访问网络资源URL(Uniform Resource Locator)对象代表统一资源定位器，它是指向互联网“资源”的指针。资源可以是简单的文件或目录，也可以是对更复杂的对象的引用，例如对数据库或搜索引擎的查询。通常情况，URL可以有协议名、主机、端口和资源组成，即满足如下格式：protocol://host:port/resourceName我们可以把URL理解成URI的特例，Java的URI不能用于定位任何资源，它的唯一作用就是解析。URL包含一个可打开到达资源的输入流。 URL类提供了多个构造器用于创建URL对象，一旦获得URL对象之后，可以调用如下常用方法来访问该URL对应的资源： String getFile()：获取此URL的资源名 String getHost()：获取此URL的主机名 String getPath()：获取此URL的路径部分 int getPort()：获取此URL的端口号 String getProtocol()：获取此URL的协议名称 String getQuery()：获取此URL的查询字符串部分 URLConnection openConnection()：返回一个URLConnection对象，它表示到URL所引用的远程对象的连接 InputStream openStream()：打开与此URL的连接，并返回一个用于读取该URL资源的InputStream 使用URL读取网络资源URL对象提供的openStream()可以读取该URL资源的InputStream，通过该方法可以非常方便地读取远程资源。 使用URLConnection提交请求URL的openConnection()方法将返回一个URLConnection对象，该对象表示应用程序和URL之间的通信连接。程序可以通过URLConnection实例向该URL发送请求，读取URL引用的资源。通常创建一个和URL的连接，并发送请求、读取此URL引用的资源需要如下几个步骤。 通过调用URL对象的openConnection()方法来创建URLConnection对象 设置URLConnection的参数和普通请求属性 如果只是发送GET请求，那么使用connect方法建立和远程资源之间的实际连接即可；如果需要发送POST方式的请求，则需要获取URLConnection实例对应的输出流来发送请求参数 远程资源变为可用，程序可以访问远程资源的头字段，或者通过输入流读取远程资源的数据 在建立和远程资源的实际连接之前，程序可以通过如下方法来设置请求头字段 setAllowUserInteraction：设置该URLConnection的allowUserInteraction请求头字段的值 setDoInput：设置该URLConnection的doInput请求头字段的值 setDoOutput：设置该URLConnection的doOutput请求头字段的值 setIfModifiedSince：设置该URLConnection的ifMOdifiedSince请求头字段的值 setUseCaches：设置该URLConnection的useCaches请求头字段的值，除此之外，还可以使用如下方法来设置或者增加通用的头字段 setRequestProperty(String key,String value)：设置该URLConnection的key请求头字段的值为value addRequestProperty(String key,String value)：为该URLConnection的key请求头字段增加value值，该方法并不会覆盖原请求头字段的值，而是将新值追加到原请求头字段中 当远程资源可用之后，程序可以使用以下方法来访问头字段和内容 Object getContent()：获取该URLConnection的内容 String getHeaderField(String name)：获取指定响应头字段的值 getInputStream()：返回该URLConnection对应的输入流，用于获取URLConnection响应的内容 getOutputStream()：返回该URLConnection对应的输出流，用于向URLConnection发送请求参数 PS：如果既要使用输入流来读取URLConnection响应的内容，也要使用输出流发送请求参数，一定要先使用输出流，再使用输入流 使用HttpURLConnectionHttpURLConnection继承了URLConnection，因此也可用于向指定网站发送GET请求、POST请求。在URLConnection的基础上提供了如下便捷的方法 int getResponseCode()：获取服务器的响应代码 String getResponseMessage()：获取服务器的响应信息 String getRequestMethod()：获取发送请求的方法 void setRequestMethod(String method)：设置发送请求的方法 为了实现多线程下载，步骤如下： 创建URL对象 获取指定URL对象所指向资源的大小（由getContentLength()方法实现），此处用到HttpURLConnection类 在本地磁盘上创建一个与网络资源相同大小的空文件夹 计算每条线程应该下载网络资源的哪个部分（从哪个字节开始，到哪个字节结束） 依次创建、启动多条线程来下载网络资源的指定部分 使用Apache HttpClient在一般情况下，如果只是需要向Web站点的某个简单页面提交请求并获取服务器响应，则完全可以使用前面所介绍的HttpURLConnection完成。但在大多数情况下，Web网页可能没这么简单，这些页面不是通过一个简单的URL就可以访问的，可能需要用户登录，而且具有相应的权限才可以访问该界面。为了更好地处理向Web站点请求，包括处理Session、Cookie等细节问题，Apache开源组织提供了一个HttpClient项目，它是一个简单的HTTP客户端，可以用于发送HTTP请求，接收HTTP响应。但不会缓存服务器的响应，不能执行HTML页面中嵌入的JavaScript代码；也不会对页面内容进行解析和处理。（HttpClient是一个增强的HttpURLConnection）使用HttpClient发送请求、接收响应，步骤： 创建HttpClient对象 如果需要发送GET请求，则创建HttpGet对象；如果需要发送POST请求，则创建HttpPost对象 如果需要发送请求参数，则可调用HttpGet、HttpPost共同的setParams(HttpParams params)方法来添加请求参数；对于HttpPost对象而言，也可调用setEntity(HttpEntity entity)方法来设置请求参数 调用HttpClient对象的execute(HttpUriRequest request)方法发送请求，执行该方法返回一个HttpResponse 调用HttpResponse的getAllHeaders()、getHeaders(String name)等方法可获取服务器的响应头；调用HttpResponse的getEntity()方法可获取HttpEntity对象，该对象包装了服务器的响应内容。程序可通过该对象获取服务器的响应内容 程序只要第一次通过HttpClient登录系统，接下来即可通过该HttpClient访问被保护的资源。 使用WebView浏览网页WebView的用法与普通ImageView组件的用法基本相似，它提供了大量方法来执行浏览器操作，例如如下常用方法： void goBack()：后退 void goForward()：前进 void loadUrl(String url)：加载指定URL对应的网页 boolean zoomln()：放大网页 boolean zoomOut()：缩小网页 通过WebView的loadUrl()方法来加载显示指定URL对应的页面 使用WebView加载HTML代码WebView提供了一个loadData(String data,String mimeType,String encoding)方法，该方法用于加载并显示HTML代码。但在实际使用过程中，当它加载包含中文的HTML内容时，WebView将会显示乱码。不过loadDataWithBaseURL(String baseUrl,String data,String mimeType,String encoding,String historyUrl)方法，该方法是loadData(String data,String mimeType,String encoding)方法的增强版，他不会产生乱码。 参数： data：指定需要加载的HTML代码 mimeType：指定HTML代码的MIME类型，对于HTML代码可指定为text/html encoding：指定HTML代码编码所使用的字符集，比如GBK 使用WebView中的JavaScript调用Android方法很多时候，WebView加载的页面是带有JavaScript脚步的，比如页面上有一个按钮，用户单击按钮时将会弹出一个提示框，或打开一个列表框。由于该按钮是HTML页面上的按钮，它只能激发一段JavaScript脚步，这就要让JavaScript脚步来调用Android方法。在WebView的JavaScript中调用Android方法只要如下三个步骤： 调用WebView关联的WebSettings的setJavaScriptEnabled(true)启用JavaScript调用功能 调用WebView的addJavascriptInterface(Object object,String name)方法将object对象暴露给JavaScript脚步 在JavaScript脚本中通过刚才暴露的name对象调用Android方法 JavaScript脚本可以直接调用Java对象的方法 使用Web Service进行网络编程为了让Android应用与远程服务器进行交互，可以借助于Java的RMI技术，但这要求远程服务器程序必须采用Java实现；也可以借助于CORBA技术，但是这种技术显得过于复杂。除此之外，Web Service是一种不错的选择。 Web Service平台概述Web Service平台主要涉及的技术有SOAP（Simple Object Access Protocol，简单对象访问协议）,WSDL（Web Service Description Language，Web Service描述语言）,UDDI（Universal Description,Description and Integration，统一描述、发现和整合协议） SOAP是一种具有扩展性的XML消息协议。SOAP允许一个应用程序向另一个应用程序发送XML消息，SOAP消息是从SOAP发送者传至SOAP接收者的单路消息，任何应用程序均可作为发送者或接收者。SOAP仅定义消息结构和消息处理的协议，与底层的传输协议独立。因此，SOAP协议能通过HTTP,JMS,SMTP协议传输 &lt;Envelope…/&gt;根元素，SOAP消息对应的XML文档以该元素作为根元素 可选的&lt;Header../&gt;元素，包含SOAP消息的头信息 必须的&lt;Body../&gt;元素，包含所有的调用和响应信息 WSDL使用XML描述Web Service，包括访问和使用Web Service所必须的信息，定义该Web Service的位置、功能及如何通信等描述信息 WHAT部分：用于定义Web Service所提供的操作或者方法。由WSDL中&lt;type../&gt;,&lt;message../&gt;和&lt;portType../&gt;元素定义 HOW部分：用于定义如何访问Web Service，包括数据格式详情和访问Web Service操作的必要协议 WHERE部分：用于定义Web Service位于何处。该部分使用&lt;service…/&gt;元素定义 UDDI是一套信息注册规范，它基于Web，是分布式。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>TCP协议基础</tag>
        <tag>使用ServerSocket创建TCP服务器端</tag>
        <tag>使用Socket进行通信</tag>
        <tag>加入多线程</tag>
        <tag>使用URL读取网络资源</tag>
        <tag>使用Apache Httpclient</tag>
        <tag>使用Web View</tag>
        <tag>使用Web Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（三十九之多媒体应用开发）]]></title>
    <url>%2F2018%2F08%2F23%2F8.23%2F</url>
    <content type="text"><![CDATA[安卓基础音频和视频的播放使用MediaPlayer播放音频当程序控制MediaPlayer对象装载音频完成之后，程序可以调用MediaPlayer的如下三个方法进行播放控制： start()：开始或恢复播放 stop() pause() 为了让MediaPlayer来装载指定音频文件，MediaPlayer提供了如下简单的静态方法： static MediaPlayer create(Context context,Uri uri)：从指定Uri来装载音频文件，并返回新创建的MediaPlayer对象 static MediaPlayer create(Context context,int resid)：从resid资源ID对应的资源文件中装载音频文件，并返回新创建的MediaPlayer对象 上面两个方法不适用于MediaPlayer循环播放多个音频文件，因为每次都会返回新创建的MediaPlayer对象。此时可通过MediaPlayer的setDataSource()方法来装载指定的音频文件。MediaPlayer提供了如下方法： setDataSource(String path)：指定装载path路径下所代表的文件 setDataSource(FileDescriptor fd,long offset,long length)：指定装载fd所代表的文件中从offset开始、长度为length的文件内容 setDataSource(FileDescriptor fd)：指定装载fd所代表的文件 setDataSource(Context context,Uri uri)：指定装载uri所代表的文件 执行了上面的setDataSource（）方法后，MediaPlayer并未真正去装载那些音频文件，还需要调用MediaPlayer的prepare（）方法去真正装载音频文件。 MediaPlayer还提供了一些绑定事件监听器的方法，用于监听MediaPlayer播放过程中所发生的特定事件。绑定事件监听器的方法如下： setOnCompletionListener(MediaPlayer.OnCompletionListener listener)：为MediaPlayer的播放完成事件绑定事件监听器 setOnErrorListener(MediaPlayer.OnErrorListener listener)：为MediaPlayer的播放错误事件绑定事件监听器 setOnPreparedListener(MediaPlayer.OnpreparedListener listener)：当MediaPlayer调用prepare()方法时触发该监听器 setOnSeekCompleteListener(MediaPlayer.OnSeekCompleteListener listener)：当MediaPlayer调用seek()方法时触发该监听器 1.播放应用的资源文件，播放应用的资源文件需要两步（音频资源文件一般放在Android应用中的/res/raw目录下）： 调用MediaPlayer的creat（Context Context,int resid）方法装载指定的资源文件 调用MediaPlayer的start(),pause(),stop()等方法控制播放即可 2.播放应用的原始资源文件： 调用Context的getAssets（）方法获取应用的AsserManager 调用AssetManager对象的openFd（String name）方法打开指定的原始资源文件，该方法返回一个AssetFileDescriptor对象 调用AssetFileDescriptor的getFileDescriptor（）、getStartOffset（）、getLength（）方法来获取音频文件的FileDescriptor、开始位置、长度等。 创建MediaPlayer对象，并调用MediaPlayer对象的setDataSource(FileDescriptor fd,long offset,long length)方法来装载音频资源 调用MediaPlayer对象的prepare（）方法准备音频 调用MediaPlayer的start（），pause（），stop（）方法控制播放 3.播放外部存储器上的音频文件 创建MediaPlayer对象，并调用MediaPlayer对象的setDataSource（String path）方法装载指定的音频文件 调用MediaPlayer对象的prepare（）方法准备音频 调用MediaPlayer的start（），pause（），stop（）方法控制播放 4.播放来自网络的音频文件 方式：①直接使用MediaPlayer的静态create（Context context，Uri uri）方法②调用MediaPlayer的setDataSource(Context context,Uri uri)方法装载指定Uri对应的音频文件 以第二种方式播放来自网络的音频文件的步骤如下： 根据网络的音频文件所在的文字创建Uri对象 创建MediaPlayer对象，并调用MediaPlayer对象的setDataSource(Context context,Uri uri)方法装载Uri对应的音频文件 调用MediaPlayer对象的prepare（）方法准备音频 调用MediaPlayer的start（），pause（），stop（）方法控制播放 MediaPlayer除了调用prepare（）方法来准备声音之外，还可以调用prepareAsync（）来准备声音。prepareAsync（）是异步的，他不会阻塞当前的UI进程 MediaPlayer的状态图： 音乐特效控制Android播放音乐的均衡器靠AudioEffect及其子类完成的。它的子类如下： AcousticEchoCanceler：取消回声控制器 AutomaticGainControl：自动增益控制器 NoiseSuppressor：噪声压制控制器 BassBoost：重低音控制器（setStrength（short strength）方法来设置重低音的强度） Equalizer：均衡控制器（getNumberOfPresets()方法获取该均衡器所有预设的音场并提供了getPresetName()方法获取预设音场名称。获取Equalizer对象后，可调用它的getNumberOfBands()方法获取该均衡器支持的总频率，再调用getCenterFreq(short band)方法根据索引来获取频率。当用户想为某个频率的均衡器设置参数值时，可调用setBandLevel(Short band,short level)方法进行设置 PresetReverb：预设音场控制器（调用setPreset(short preset)方法设置使用预设置的音场。 Visualizer：示波器（它不用于控制音乐播放效果，他只是显示音乐的播放波形。为了实时显示该示波器的数据需要为该组件设置一个OnDataCaptureListener监听器，该监听器将负责更新波形显示组件的界面） 上述前三个子类的用法很简单，只要调用它们的静态create（）方法创建相应的实例，然后调用它们的isAvailable（）方法判断是否可用，再调用setEnabled（boolean enable）方法启动相应效果即可。 后四个类，都需要调用构造器来创建实例。创建实例时，同样需要传入一个audioSession参数，为了启用他们，同样需要调用AudioEffect基类的setEnabled（true）方法。 使用SoundPool播放音效MediaPlayer存在如下缺点： 资源占用量较高，延迟时间较长 不支持多个音频同时播放 Android系统SoundPool提供了一个Builder内部类，该内部类专门用于创建SoundPool。SoundPool提供了如下4个load()重载方法： int load(Context context,int resId,int priority)：从resId所对应的资源加载声音 int load(FileDescriptor fd,long offset,long length,int priority)：加载fd所对应的文件中从offset开始、长度为length的声音 int load(AssetFileDescriptor afd,int priority)：从afd所对应的文件中加载声音 int load(String path,int priority)：从path对应的文件去加载声音 该priority参数目前没有任何作用，Android建议将该参数设为1，保持和未来的兼容性。上面4个方法加载声音之后，都会返回该声音的ID，以后程序就可以通过该声音的ID来播放指定声音了。SoundPool提供的播放指定声音的方法如下： int play(int soundID,float leftVolume,float rightVolume,int priority,int loop,float rate)：该方法的第一个参数指定播放哪个声音；priority指定播放声音的优先级，数值越大，优先级越高；loop指定是否循环，0为不循环，-1为循环；rate指定播放的比率，数字可从0.5到2,1为正常比率。 归纳起来，使用SoundPool播放声音的步骤如下： 调用SoundPool.Builder的构造器创建SoundPool.Builder对象，并可通过该Builder对象为SoundPool设置属性 调用SoundPool的构造器创建SoundPool对象 调用SoundPool对象的load()方法从指定资源、文件中加载声音。最好使用HashMap&lt;Integer,Integer&gt;来管理所加载的声音 调用SoundPool的play()方法播放声音 实际使用SoundPool播放声音时有如下几点需要注意：SoundPool虽然可以一次性加载多个声音，但由于内存限制，因此避免使用SoundPool来播放歌曲或者做游戏背景音乐，只有那些短促、密集的声音才考虑用SoundPool进行播放。 使用VideoView播放视频使用步骤： 在界面布局文件中定义VideoView组件，或者在程序中创建VideoView组件 调用VideoView的如下两个方法来加载指定视频 setVideoPath(String path) setVideoUri(Uri uri) 调用VideoView的start(),stop(),pause()方法来控制视频播放 实际上与VideoView结合使用的还有一个MediaController类，它提供一个友好的图形控制界面。 1234567//获得对象MediaController mController = new MediaController(this);//设置videoView与mController建立关联videoView.setVideoPath(video.getAbsolutePath());videoView.setMediaController(mController);mController.setMediaPlayer(videoView);videoView.requestFocus(); 使用MediaRecorder录制音频使用步骤： 创建MediaRecorder对象 调用MediaRecorder对象的setAudioSoruce()方法设置声音来源，一般传入MediaRecorder.AudioSource.MIC参数指定录制来自麦克风的声音 调用MediaRecorder对象的setOutputFormat()方法设置所录制的音频文件格式 调用MediaRecorder对象的setAudioEncoder(),setAudioEncodingBitRate(int bitRate),setAudioSamplingRate(int samplingRate)方法设置所录制的声音编码格式、编码位率、采样率等，这些参数将可以控制所录制的声音品质、文件大小。一般来说，声音品质越好，声音文件越大 调用MediaRecorder的setOutputFile(String path)方法设置所录制的音频文件的保存位置 调用MediaRecorder的prepare()方法准备录制 调用MediaRecorder对象的start()方法开始录制 录制完成，调用MediaRecorder对象的stop()方法停止录制，并调用release()方法释放资源 ps：第三步和第四步不能反；需要录制声音的权限和向外部存储器写入数据的权限 MediaRecorder的状态图： 控制摄像头拍照使用Android5.0的Camera v2拍照Android5.0的Camera v2涉及如下API： CameraManager：摄像头管理器 CameraCharacteristics：摄像头特性 CameraDevice：代表系统摄像头 CameraCaptureSession：这是一个非常重要的API，当程序需要预览、拍照时，都需要先通过该类的实例创建Session。该对象控制预览的方法为setRepeatingRequest()；控制拍照的方法为capture() CameraRequest和CameraRequest.Builder：当程序调用setRepeatingRequest()方法进行预览时，或调用capture()方法进行拍照时，都需要传入CameraRequest参数 录制视频短片MediaRecorder还可用于录制视频。为了让MediaRecorder录制时采集图像，应该在调用setAudioSource(int audio_source)方法时再调用setVideoSource(int video_source)方法来设置图像来源 Android 5.0 新增的屏幕捕捉Android 5.0 新增了MediaProjectionManager管理器，该管理器可以非常方便地实现了屏幕捕捉功能。使用步骤： 以MEDIA_PROJECTION_SERVICE为参数，调用Context.getSystemService()方法即可获取MediaProjectionManager实例 调用MediaProjectionManager对象的createScreenCaptureIntent()方法创建一个屏幕捕捉的Intent 调用startActivityForResult()方法启动第2步得到的Intent，这样即可启动屏幕捕捉的Intent 重写onActivityResult()方法，在该方法中通过MediaProjectionManager对象来获得MediaProjection对象，在该对象中即可获取被捕捉的屏幕]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>使用MediaPlayer播放音频</tag>
        <tag>音乐特效控制器</tag>
        <tag>使用SoundPool播放音乐</tag>
        <tag>使用VideoView播放视频</tag>
        <tag>使用MediaRecorder录制音频</tag>
        <tag>Android 5.0 的Camera v2拍照</tag>
        <tag>屏幕捕捉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（三十八之使用Service与BroadcastReceiver）]]></title>
    <url>%2F2018%2F08%2F22%2F8.22.2%2F</url>
    <content type="text"><![CDATA[安卓基础接受广播消息BroadcastReceiver本质上就是一个全局监听器，用于监听系统全局的广播消息。由于BroadcastReceiver是一个全局监听器，因此它可以非常方便地实现系统中不同组件之间的通信。 BroadcastReceiverBroadcastReceiver用于接受程序（包括用户开发的程序和系统内建的程序）所发出的Broadcast Intent，与应用程序启动Activity、Service相同的是，程序启动BroadcastReceiver也只需要两步： 创建需要启动的BroadcastReceiver的Intent 调用Context的sendBroadcast()或sendOrderedBroadcast()方法来启动指定的BroadcastReceiver 与Activity、Service具有完整的生命周期不同，BroadcastReceiver本质上只是一个系统级的监听器——它专门负责监听各程序所发出的Broadcast。前面介绍的各种OnXxxListener只是程序级别的监听器，这些监听器运行在指定程序所在进程中，当程序退出时，OnXxxListener监听器也就随之关闭了。但BroadcastReceiver属于系统级的监听器，他拥有自己的进程，只要存在与之匹配的Intent被广播出来，BroadcastReceiver就会被激发。实现BroadcastReceiver的方法十分简单，只要重写BroadcastReceiver的onReceive(Context context,Intent intent)方法即可。一旦实现了BroadcastReceiver，接下来就应该指定该BroadcastReceiver能匹配的Intent，此时有两种方式： 使用代码进行指定，调用BroadcastReceiver的Context的registerReceiver(BroadcastReceiver receiver,IntentFilter filter)方法指定 在AndroidManifest.xml中配置。例如如下代码： 12345&lt;receiver android:name=&quot;.IncomingSMSReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 每次系统Broadcast事件发生后，系统就会创建相应的BroadcastReceiver实例，并自动触发它的onReceive()方法，onReceive()方法执行完之后，BroadcastReceiver实例就会被销毁。如果BroadcastReceiver的onReceive（）方法不能再10秒内执行完成，Android会认为该程序无响应。所以不要在BroadcastReceiver的onReceive（）方法里执行一些耗时的操作；否则就会弹出ANR（Application No Response）对话框。**如果确实需要根据Broadcast来完成一项比较耗时的操作，则可以考虑通过Intent启动一个Service来完成该操作。不应考虑使用新线程去完成耗时的操作，因为BroadcastReceiver本身的生命周期就很短，可能出现的情况是子线程可能还没有结束，BroadcastReceiver就已经退出了。虽然该进程内还有用户启动的新线程，但由于该进程内不包含任何活动组件，因此系统可能在内存紧张时优先结束该进程。这样就可能导致BroadcastReceiver启动的子线程不能执行完成。 发送广播只要调用Context的sendBroadcast(Intent intent)方法即可，这条广播将会启动intent参数对应的BroadcastReceiver。 有序广播Broadcast分为两种： Normal Broadcast(普通广播)：Normal Broadcast是完全异步的，可以在同一时刻（逻辑上）被所有接受者接收到，消息传递的效率比较高。缺点是接受者不能将处理结果传递给下一个接收者，并且无法终止Broadcast Intent的传播 Ordered Broadcast(有序广播)：Ordered Broadcast的接受者将按预先声明的优先级高低依次接收Broadcast。优先级别声明在&lt;intent-filter…/&gt;元素的android:priority属性中，数越大优先级别越高，取值范围为-1000~1000；也可以调用IntentFilter对象的setPriority（）设置优先级别。Ordered Broadcast接收者可以终止Broadcast Intent的传播，Broadcast Intent传播一旦终止，后面的接收者就无法接收到Broadcast。另外，OrderedBroadcast的接受者可以将数据传递给下一个接收者。 对于Ordered Broadcast而言，调用BroadcastReceiver的abortBroadcast()方法即可终止Broadcast；优先接受到Broadcast的接收者可以通过setResultExtras(Bundle)方法将处理结果存入Broadcast中，然后传给下一个接收者，下一个接收者通过代码Bundle bundle = getResultExtras(true)可以获取上一个接收者存入的数据。 实例比如程序有一个Activity和Service，而且Service是通过startService（）方法气动的，正常情况下，这个Activity与通过startService（）方法启动的Service之间无法通信，但借助BroadcastReceiver的帮助，程序就可以实现两者之间的通信。 PS：对于BroadcastReceiver程序实现过程：①当实现sendBroadcast（intent）方法 ②与之intent对应绑定的BroadcastReceiver会被自动调用。 接收系统广播消息除了可以接收用户发送的广播之外，还可以接收系统广播。Android的大量系统事件会对外发送标准广播。下面是Android常见的广播Action常量： ACTION_TIME_CHANGED：系统时间被改变 ACTION_DATE_CHANGED：系统日期被改变 ACTION_TIMEZONE_CHANGED：系统时区被改变 ACTION_BOOT_COMPLETED：系统启动完成 ACTION_PACKAGE_ADDED：系统添加包 ACTION_PACKAGE_CHANGED：系统包的改变 ACTION_PACKAGE_REMOVED：系统包的删除 ACTION_PACKAGE_RESTARTED：系统的包被重启 ACTION_PACKAGE_DATA_CLEARED：系统的包数据被清空 ACTION_BATTERY_CHANGED：电池电量改变 ACTION_BATTERY_LOW：电池电量低 ACTION_POWER_CONNECTED：系统连接电源 ACTION_POWWER_DISCONNECTED：系统与电源断开 ACTION_SHUTDOWN：系统被关]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>BroadcastReceiver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（三十七之使用Service与BroadcastReceiver）]]></title>
    <url>%2F2018%2F08%2F22%2F8.22%2F</url>
    <content type="text"><![CDATA[安卓基础Service的生命周期Service生命周期图： 与多次调用startService()方法启动Service，就多次回调Service的onStartCommand()方法不同的是，多次调用bindService()方法并不会重复绑定，且只会回调一次onBind()方法。 当Activity调用bindService()绑定一个已启动的Service时，系统只是把Service内部IBinder对象传给Activity，并不会把该Service生命周期完全“绑定”到该Activity，因而当Activity调用unBindService()方法取消与该Service的绑定时，也只是切断该Activity与Service之间的关联，并不能停止该Service组件。 使用IntentServiceIntentService是Service的子类。Service本身存在两个问题： Service不会专门启动一个单独的进程，Service与它所在应用位于同一个进程中。 Service不是一条新的线程，因此不应该在Service中直接处理耗时任务。 如果开发者需要在Service中处理耗时任务，建议在Service中另外启动一条新的线程来处理该耗时任务。直接在其他程序组件中启动子线程来处理耗时任务不行吗？这种方式也不可靠，由于Activity可能会被用户退出，而BroadcastReceiver的生命周期本来就很短。可能出现：在子线程还没有结束的情况下，Activity就已经被用户退出了，或者BroadcastReceiver已经结束了。在Activity已经退出、BroadcastReceiver已经结束的情况下，此时他们所在的进程就变成了空进程（没有任何活动组件的进程），系统需要内存时可能会优先终止该进程。如果宿主进程被终止，那么该进程内的所有子线程也会被终止，这样就可能导致子线程无法执行完成。而IntentService正好可以弥补Service的上面的两个不足：IntentService将会使用队列来管理请求Intent，每当客户端代码通过Intent请求启动IntentService时，IntentService会将该Intent加入队列中，然后开启一条新的worker线程来处理该Intent。对于异步的startService()请求，IntentService会按次序依次处理队列中的Intent，该线程保证同一时刻只处理一个Intent。由于IntentService使用新的worker线程处理Intent请求，因此IntentService不会阻塞主线程，所以IntentService自己就可以处理耗时任务。归纳起来，IntentService有如下特征： IntentService会创建单独的worker线程来处理所有的Intent请求 IntentService会创建单独的worker线程来处理onHandleIntent()方法实现的代码，因此开发者无须处理多线程问题 当所有请求处理完成后，IntentService会自动停止，因此开发者无须调用stopSelf()方法来停止该Service 为Service的onBind()方法提供了默认实现，默认实现的onBind()方法返回null 为Service的onStartCommand()方法提供了默认实现，该实现将请求Intent添加到队列中 扩展IntentService实现Service无须重写onBind()和onStartCommand()方法，只要重写onHandleIntent()方法即可，在该方法中定义该Service需要完成的任务。 如果用继承Service子类的MyService来执行耗时操作，会导致UI线程阻塞（ANR异常）。 电话管理器（TelephonyManager）TelephonyManager是一个管理手机通话状态、电话网络信息的服务类，该类提供了大量getXxx()方法获取网络状态和SIM卡的相关信息。在程序中获取TelephonyManager：TelephonyManager tManager = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE) TelephonyManager还提供了一个listen(PhoneStateListener listener,int events)方法来监听通话状态。程序中要首先取得TelephonyManager对象，再创建一个PhoneStateListener，它是一个通话状态监听器，该监听器可用于对TelephonyManager进行监听。 ##短信管理器（SmsManager） SmsManager提供了一系列sendXxxMessage()方法用于发送短信，发送普通文本内容调用sendTextMessage()方法即可。 123456//获取SmsManagersManager = SmsManager.getDefault()//创建一个PendingIntent对象PendingIntent pi = PengingIntent.getActivity(MainActivity.this,0,new Intent(),0)//发送短信sManager.sendTextManage(number.getText().toString(),null,content.getText().toString(),pi,null) PendingIntent是对Intent的包装，一般通过调用PendingIntent的getActivity()、getService（）、getBroadcastReceiver（）静态方法来获取PendingIntent对象。与Intent对象不同的是，PendingIntent通常会传给其他应用组件，从而有其他应用程序来执行PendingIntent所包装的“Intent”。 音频管理器（AudioManager）程序如果需要管理系统音量，或者让系统静音，这就可借助于Android提供的AudioManager来实现。程序一样是调用getSystemService()方法来获取系统的音频管理器。 AudioManagerAudioManager对象调整手机指定类型的声音的方法： adjustStreamVolume(int streamType,int direction,int flags)。其中第一个参数streamType指定声音类型，它的值如下： STREAM_ALARM：闹钟 STREAM_DTMF：DTMF音调的声音 STREAM_MUSIC：音乐 STREAM_NOTIFICATION：系统提示 STREAM_RING：电话铃声 STREAM_SYSTEM：手机系统 STREAM_VOICE_CALL：语音电话 第二个参数对声音进行增大或者减小；第三个参数是调整声音时的标志，指定为FLAG_SHOW_UI，则调整声音时显示音量进度条。 setMicrophoneMute(boolean on)：设置是否让麦克风静音 setMode(int mode)：设置声音模式，值可为：NORMAL,RINGTONE,IN_CALL setRingerMode(int ringerMode)：设置手机的电话铃声模式。值可为： RINGER_MODE_NORMAL：正常的手机铃声 RINGER_MODE_SILENT：手机铃声静音 RINGER_MODE_VIBRATE：手机振动 setSpeakeerphoneOn(boolean on)：设置是否打开扩音器 setStreamMute(int streamType,boolean state)：将手机的指定类型的声音调整为静音。 setStreamVolume(int streamType,int index,int flags)：直接设置手机的指定类型的音量值。 振动器（Vibrator）有时候程序需要启动振动器，比如手机静音时使用振动提示用户；当玩游戏时，当系统碰撞、爆炸时使用振动带给用户更逼真的体验。系统获取Vibrator也是调用了context的getSystemService()方法。 Vibrator简介Vibrator的使用： vibrate(long milliseconds)：控制手机振动milliseconds毫秒 vibrate(long[] pattern,int repeat)：指定手机以pattern指定的模式振动。例如指定pattern为new int[400,800,1200,1600]，也就是在400ms、800ms、1200ms、1600ms这些时间点交替启动、关闭手机振动器；其中repeat指定pattern数组的索引，指定对pattern数组中从repeat索引开始的振动进行循环 cancel()：关闭手机振动 程序控制手机振动需要得到相应的权限，在AndroidManifest.xml文件中加授权代码：` ` 手机闹钟服务（AlarmManager）AlarmManager通常用来开发手机闹钟。但是，它的本质是一个全局定时器，AlarmManager可以在指定时间或者指定周期启动其他组件（包括Activity，Service，BroadcastReceiver）。 AlarmManager在Android应用程序中也是通过Context的getSystemService()方法来获取AlarmManager对象的。获得AlarmManager对象后，可调用如下方法来设置定时启动指定组件： set(int type,long triggerAtTime,PendingIntent operation):设置在triggerAtTime时间启动由operation参数指定的组件。其中第一个参数指定定时服务的类型，该参数有如下值： ELAPSED_REALTIME:指定从现在开始时间过了一定时间后启动operation所对应的组件。 ELAPSED_REALTIME_WAKEUP：指定从现在开始时间过了一定时间后启动operation所对应的组件。即使系统处于休眠状态也会启动相应组件 RTC：指定当系统调用System.currentTimeMillis()方法的返回值与triggerAtTime相等时启动operation所对应的组件 RTC_WAKEUP：指定当系统调用System.currentTimeMillis()方法的返回值与triggerAtTime相等时启动operation所对应的组件。即使系统处于休眠状态也会执行operation所对应的组件 setInexactRepeating(int type,long triggerAtTime,long interval,PendingIntent operation):设置一个非精确的周期性任务。 setRepeating(int type,long triggerAtTime,long interval,PendingIntent operation)：设置一个周期性执行的定时任务 cancel(PendingIntent operation)：取消AlarmManager的定时任务 AlarmManager新增的如下两个方法支持精确激发： setExact(int type,long triggerAtMillis,PendingIntent operation)：设置闹钟将在精确的时间被触发 setWindow(int type,long windowStartMillis,long windowLengthMillis,PendingIntent operation)：设置闹钟将在精确的时间段内被触发 其他（System.currentTimeMillis()方法）在开发过程中，通常很多人都习惯使用new Date()来获取当前时间。new Date()所做的事情其实就是调用了System.currentTimeMillis()。如果仅仅是需要或者毫秒数，那么完全可以使用System.currentTimeMillis()去代替new Date()，效率上会高一点。如果需要在同一个方法里面多次使用new Date()，通常性能就是这样一点一点地消耗掉。System.currentTimeMillis()+3600*1000)可以这样解读：System.currentTimeMillis()相当于是毫秒为单位，但是，后头成了1000，就变成了以秒为单位。那么，3600秒=1小时，所以输出为当前时间的1小时后；我们可以这样控制时间：System.currentTimeMillis()+time*1000)，里面传入的time是以秒为单位，当传入60，则输出：当前时间的一分钟后。 Calendar.getInstance()是获取一个Calendar对象并可以进行时间的计算，时区的指定；Calendar的对象和new Date()对象可以相互转化：Calendar calendar = Calendar.getInstance();Date date = calendar.getTime(); 更换壁纸（WallpaperManager）它提供了clear()方法来清除壁纸，还提供了如下方法来设置系统的壁纸： serBitmap(Bitmap bitmap)：将壁纸设置为bitmap所代表的位图 setResource(int resid)：将壁纸设置为resid资源所代表的图片 setStream(InputStream data)：将壁纸设置为data数据所代表的图片 markdown语法中转义字符123456789101112\\ 反斜杠\` 反引号\* 星号\_ 下划线\&#123;\&#125; 大括号\[\] 中括号\(\) 小括号\# 井号\+ 加号\- 减号\. 英文句号\! 感叹号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Service的生命周期</tag>
        <tag>IntentService</tag>
        <tag>PendingIntent</tag>
        <tag>电话管理器（TelephonyManager）</tag>
        <tag>短信管理器（SmsManager）</tag>
        <tag>音频管理器（AudioManager）</tag>
        <tag>振动器Vibrator</tag>
        <tag>手机闹钟服务AlarmManager</tag>
        <tag>System.currentTimeMillis()</tag>
        <tag>markdown转义字符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（三十六之使用Service与BroadcastReceiver）]]></title>
    <url>%2F2018%2F08%2F21%2F8.21.2%2F</url>
    <content type="text"><![CDATA[安卓基础Service与Activity十分相似，都代表可执行的程序；区别在于：Service一直在后台运行，它没有用户界面，不会到前台来。一旦Service被启动起来，它就与Activity一样，它完全有自己的生命周期。程序中Activity与Service的选择标准是，如果某个程序组件需要在运行时间向用户呈现某种界面，或者该程序需要与用户交互，就需要使用Activity。否则就使用Service。 ServiceService组件也是可执行的程序，它也有自己的生命周期。 创建配置Service步骤： 定义一个继承Service的子类 在AndroidManifest.xml文件中配置该Service Service和Activity都是从Context派生出来的，因此他们都可调用Context里定义的如getResources(),getContentResolver()等方法。 Service生命周期图： Service生命周期方法： IBinder onBind(Intent intent)：该方法是Service子类必须实现的方法。该方法必须返回一个IBinder对象，应用程序可以通过该对象与Service组件通信。 void onCreate()：在该Service第一次被创建后将会立即回调该方法 void onDestroy()：在该Service被关闭之前回调该方法 void onStartCommand(Intent intent,int flags,int startId)：该方法的早期版本是void onStart(Intent intent,int startId)，每次客户端调用startService(Intent intent)方法启动该Service时都会回调该方法 boolean onUnbind(Intent intent)：当该Service上绑定的所有客户端都断开连接时将会回调该方法 在AndroidManifest.xml中配置Service组件： 配置一个Service组件 -->12&lt;service android:name=&quot;&quot;&gt;&lt;/service&gt; 配置Service无须指定android:label属性——Service没有界面，指定标签意义不大。 在Android系统中运行Service有如下两种方式。 通过Context的startService()方法：访问者与Service之间没有关联，即使访问者退出了，Service仍然运行 通过Context的bindService()方法：访问者与Service之间绑定在一起，访问者退出，Service也就终止了 启动和停止Service调用Context里定义的statService(),stopService()方法即可启动，关闭Service。每当Service被创建时会回调onCreate()方法，每次Service被启动时都会回调onStartCommand()方法——多次启动一个已有的Service组件将不会再回调onCreate()方法，但每次启动时都会回调onStartCommand()方法。 绑定本地Service并与之通信当程序通过startService(),stopService()启动，关闭Service时，Service与访问者之间基本上不存在太多的关联，因此Service和访问者之间也无法进行通信、交换数据。如果Service和访问者之间需要进行方法调用或交换数据，则应该使用bindService()和unbindService()方法启动、关闭Service。 Context的bindService()方法的完整方法签名为：bindService(Intent service,ServiceConnection conn,int flags)，该方法的三个参数为： service:通过Intent指定要启动的Service。 conn：该参数是一个ServiceConnection对象，该对象用于监听访问者与Service之间的连接情况。当访问者与Service之间连接成功时回调该ServiceConnection对象的onServiceConnected(ComponentName name,IBinder service)方法，该binder对象即可实现与被绑定Service之间的通信；当Service所在的宿主进程由于异常中止或其他原因终止，导致该Service与访问者之间断开连接时回调该ServiceConnection对象的onServiceDisconnected(ComponentName name)方法。 flags：指定绑定时是否自动创建Service(如果Service还未创建）。该参数可指定为0（不自动创建）或BIND_AUTO_CREATE（自动创建） 在开发子类时提供的一个IBinder onBinder(Intent intent)方法，在绑定本地Service的情况下，onBind(Intent intent)方法所返回的IBinder对象将会传给ServiceConnection对象里onServiceConnected(ComponentName name,IBinder service)方法的service参数，这样访问者就可以通过该IBinder对象与Service进行通信了。IBinder对象相当于Service组件的内部钩子，该钩子关联到绑定的Service组件，当其他程序组件绑定到该Service时，Service将会把该IBinder对象返回给其他程序组件，其他程序组件通过该IBinder对象即可与Service组件进行实时通信。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>创建配置Service</tag>
        <tag>启动停止Service</tag>
        <tag>绑定本地Service并与之通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（三十五之使用ContentProvider实现数据共享）]]></title>
    <url>%2F2018%2F08%2F21%2F8.21%2F</url>
    <content type="text"><![CDATA[安卓基础###使用ContentProvider管理多媒体内容 Android为多媒体提供的ContentProvider的Uri如下： MediaStore.Audio.Media.EXTERNAL_CONTENT_URI MediaStore.Audio.Media.INTERNAL_CONTENT_URI MediaStore.Images.Media.EXTERNAL_CONTENT_URI MediaStore.Images.Media.INTERNAL_CONTENT_URI MediaStore.Video.Media.EXTERNAL_CONTENT_URI MediaStore.Video.Media.INTERNAL_CONTENT_URI 其中EXTERNAL标识在外部存储器，INTERNAL标识在内部存储器；Audio，Images，Video分别标识音频，图片，视频。 对外部存储修改，需要在AndroidManifest.xml文件中增加配置： 1234&lt;!-- 授予读取外部存储设备的访问权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;&lt;!-- 授予写入外部存储设备的访问权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; 监听ContentProvider的数据改变当ContentProvider将数据共享出来之后，ContentResolver会根据业务需要去主动查询ContentProvider所共享的数据。有时候，应用程序需要实时监听ContentProvider所共享数据的改变，并随着ContentProvider的数据的改变而提供响应，这就需要利用ContentObserver了。 ContentObserver监听ContentProvider数据改变的监听器需要继承ContentObserver类，并重写该基类所定义的onChange(boolean selfChange)方法———当它所监听的ContentProvider数据改变时，该onChange()方法将会被触发。为了监听指定ContentProvider的数据变化，需要通过ContentResolver向指定Uri注册ContentObserver监听器。 registerContentObserver(Uri uri,boolean notifyForDescendents,ContentObserver observer) uri:该监听器所监听的ContentProvider的Uri notifyForDescendents：如果该参数设为true，假如注册监听的Uri为content://abc,那么Uri为content://abc/xyz,content://abc/xyz/foo的数据发生改变时也会触发该监听器；如果该参数设为false，假如注册监听器为content://abc，那么只有content://abc的数据发生改变时才会触发该监听器 observer：监听器实例 PS：ContentResolver用于操作ContentProvider提供的数据；ContentObserver用于监听ContentProvider的数据改变；而ContentProvider则是所有ContentProvider组件的基类]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ContentProvider</tag>
        <tag>ContentObserver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（三十四之使用ContentProvider实现数据共享）]]></title>
    <url>%2F2018%2F08%2F20%2F8.20%2F</url>
    <content type="text"><![CDATA[安卓基础为了在应用程序之间交换数据，Android提供了ContentProvider，它是不同应用之间进行数据交换的标准API。 ContentProvider也是Android应用的四大组件之一，与Activity、Service、BroadcastReceiver相似，他们都要在AndroidManifest.xml文件中配置。 数据共享标准：ContentProviderContentProvider以某种Uri的形式对外提供数据，允许其他应用访问或修改数据；其他应用程序是哟个ContentResolver根据Uri去访问操作指定数据。 可以将ContentProvider与ContentResolver简单的类比；可以把ContentProvider当成Android系统内部的“网站”，这个网站以固定的Uri对外提供服务；而ContentResolver则可以当成Android系统内部的HttpClient，它可以向指定Uri发送“请求”（实际上是调用ContentResolver的方法），这种请求最后委托给ContentProvider处理，从而实现对“网站”（ContentProvider）内部数据进行操作。 ContentProvider简介开发一个ContentProvider步骤： 定义自己的ContentProvider类，该类需要继承Android提供的ContentProvider基类 向Android系统注册，在AndroidManifest.xml中注册ContentProvider，就像注册Activity一样。 继承了ContentProvider之外，还要提供如下方法： public boolean onCreate()：ContentProvider创建时被调用，其他应用第一次访问ContentProvider时，该ContentProvider被创建出来，并立即回调该onCreate()方法 public Uri insert(Uri uri,ContentValues values)：根据该Uri插入values对应的数据 public int delete(Uri uri,String selection,String[] selectionArgs)：根据Uri删除selection条件所匹配的全部记录 public int update(Uri uri,ContentValues values,String selection,String[] selectionArgs)：根据Uri修改selection条件所匹配的全部记录 public Cursor query(Uri uri,String[] projection,String selection,String[] selectionArgs,String sortOrder)：根据Uri查询出selection条件所匹配的全部记录，其中projection就是一个列名列表，表明只选择出指定的数据列 public String getType(Uri uri)：该方法用于返回当前Uri所代表的数据的MIME类型。如果该Uri对应的数据可能包括多条记录，那么MIME类型字符串应该以vnd.android.cursor.dir/开头；如果该Uri对应的数据只包含一条记录，那么MIME类型字符串应该以vnd.android.item/开头 Uri简介ContentProvider的Uri例如如下：content://org.crazyit.providers.dictprovider/words它可以分为如下三个部分： content://：这个部分是Android的ContentProvider规定的，就像上网的协议默认是http:// org.crazyit.providers.dictprovider：这是ContentProvider的authorities。系统是由这个部分来找到操作哪个ContentProvider的。只要访问指定的ContentProvider，这个部分就是固定的 words：资源量部分（数据部分）。访问不同资源时，这里动态改变。 为了将一个字符串转换成Uri，Uri工具类提供了parse()静态方法。例如，如下代码即可将字符串转换为Uri：Uri uri=uri.parse(&quot;content://org.crazyit.prociders.dictprovider/word&quot;) 使用ContentResolver操作数据Context提供了如下方法来获取ContentResolver对象: getContentResolver() 获取ContentResolver对象后，调用如下方法操作数据 insert(Uri uri,ContentValues values)：向Uri对应的ContentProvider中插入values对应的数据 delete(Uri uri,String where,String[] selectionArgs)：删除Uri对应的ContentProvider中where提交匹配的数据 update(Uri uri,ContentValues values,String where,String[] selectionArgs)：更新Uri对应的ContentProvider中where提交匹配的数据 query(Uri uri,String[] projection,String selection,String[] selectionArgs,String sortOrder)：查询Uri对应的ContentProvider中where提交匹配的数据 开发ContentProviderContentProvider需要与ContentResolver结合学习 ContentProvider与ContentResolver的关系Uri是ContentResolver和ContentProvider进行数据交换的标识。ContentResolver对指定的Uri执行CRUD等数据操作，但Uri并不是真正的数据中心，因为这些CRUD操作会委托给该Uri对应的ContentProvider来实现。通常来说，假如A应用通过ContentResolver执行CRUD操作，这些CRUD操作都需要指定Uri参数，Android系统就根据该Uri找到对应的ContentProvider（该ContentProvider通常属于B应用），ContentProvider则负责实现CRUD方法，完成对底层数据的增删改查等操作，这样就可以让A应用访问、修改B应用的数据了。 上图是ContentResolver、Uri、ContentProvider三者关系。通过这种关系即可实现让A应用访问、使用B应用底层的数据。 开发ContentProvider子类开发ContentProvider步骤： 开发一个ContentProvider子类，该子类需要实现query(),insert(),update()和delete()等方法 在AndroidManifest.xml中注册该ContentProvider，指定android:authorities属性 ContentProvider子类实现的CRUD方法，并不是给该应用本身调用，而是供其他应用来调用。 配置ContentProviderAndroid要求Activity、Service、ContentProvider、BroadcastReceiver都必须进行显式配置. 1234&lt;provider android:name=&quot;.FristProvider&quot; android:authorities=&quot;org.crazyit.providers.firstprovider&quot; android:exported=&quot;true&quot; 从上面的配置可以看出，配置ContentProvider时通常指定如下属性。 name:指定该ContentProvider的实现类的类名 authorities:指定该ContentProvider对应的Uri android:exporter:指定该ContentProvider是否允许其他应用调用。true代表可以被调用。 当其他ContentResolver向该Uri执行CRUD方法时： ContentResolver调用方法时参数将会传给该ContentProvider的CRUD方法 ContentResolver调用方法的返回值，也就是ContentProvider执行CRUD的返回值 使用ContentResolver调用方法Context提供了getContentResolver()方法。这表明Activity、Service等组件都可以通过getContentResolver()方法获取ContentResolver对象。 ContentResolver调用query(),insert(),update(),delete()方法，实际上就是调用uri参数对应的ContentProvider的query(),insert(),update(),delete()方法 创建ContentProvider的说明为了确定该ContentProvider实际能处理的Uri，以及确定每个方法中Uri参数所操作的数据，Android系统提供了UriMatcher工具类。UriMatcher工具类主要提供了如下两个方法： void addURI(String authority,String path,int code)：用于向UriMatcher对象注册Uri。其中authority和path组合成一个Uri，而code则代表该Uri对应的标识码 int match(Uri uri)：根据前面注册的Uri来判断指定的Uri对应的标识码。如果找不到匹配的，该方法返回-1。 除此之外，Android还提供了一个ContentUris工具类，它是一个操作Uri字符串的工具类，提供了如下两个工具方法。 withAppendedId(uri，id)：用于为路径加上ID部分 parseId(uri)：用于从指定Uri中解析出所包含的ID值 在实际项目中，都会通过采用工具类来定义各种常量的方式进行处理。 操作系统的ContentProvider例如联系人信息、系统的多媒体信息。 使用ContentProvider管理联系人Android系统用于管理联系人的ContentProvider的几个Uri如下。 ContactsContract.Contacts.CONTENT_URI：管理联系人 ContactsContract.CommonDataKinds.Phone.CONTENT_URI：管理联系人的电话 ContactsContract.CommonDataKinds.Email.CONTENT_URI：管理联系人的Email]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ContentProvider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（三十三之Android数据存储与IO）]]></title>
    <url>%2F2018%2F08%2F19%2F8.19%2F</url>
    <content type="text"><![CDATA[安卓基础轻量型数据库，不足以用来充当服务器 SQLiteDatabase简介通过SQLiteDatabase对象来管理、操作数据库。SQLiteDatabase提供了如下静态方法来打开一个文件对应的数据库。 static SQLiteDatabase openDatabase(String path,SQLiteDatabase.CursorFactory factory,int flags)：打开path文件所代表的SQLite数据库 static SQLiteDatabase openOrCreateDatabase(File file,SQLiteDatabase.CursorFactory factory)：打开或者创建file文件所代表的SQLite数据库 static SQLiteDatabase openOrCreateDatabase(String path,SQLiteDatabase.CursorFactory factory)：打开或者创建path文件所代表的SQLite数据库 在程序中获取了SQLiteDatabase对象后，调用如下方法来操作数据库： execSQL(String sql,Object[] bindArgs)：执行带占位符的sql语句 execSQL(String sql)：执行sql语句 insert(String table,String nullColumnHack,ContentValues values)：向指定表中插入数据 update(String table,ContentValues values,String whereClause,String[] whereArgs)：更新指定表中的特定数据 delete(String table,String whereClause,String[] whereArgs)：删除指定表中的特定数据 Cursor query(String tabel,String[] columns,String whereClause,String[] whereArgs,String groupBy,String having,String orderBy)：对指定数据表执行查询 Cursor query(String tabel,String[] columns,String whereClause,String[] whereArgs,String groupBy,String having,String orderBy,String limit)：对指定数据表执行查询。limit参数控制最多查询几条记录（用于控制分页的参数） Cursor query(boolean distinct,String tabel,String[] columns,String whereClause,String[] whereArgs,String groupBy,String having,String orderBy,String limit)：对指定数据表执行查询；第一个参数是控制是否除去重复值 rawQuery(String sql,String[] selectionArgs)：执行带占位符的sql查询 beginTransaction()：开始事务 endTransaction()：结束事务 PS：whereArgs用于为wherClause自居传入参数。whereClause是执行数据库方法需要满足的条件 上面的查询方法都返回一个Cursor对象，类似JDBC中的Resultset，Cursor提供了如下方法来移动查询结果的记录指针。 move(int offset)：将记录指针向上（正数）或向下移动指定行数 boolean moveToFirst()：将记录指定移动到第一行 boolean moveToLast()：移动到最后 boolean moveToNext()：移动到下一行 boolean moveToPosition(int position)：将记录指针移动到指定行 boolean moveToPrevious()：移动到上一行 用SQLiteDatabase进行数据库操作的步骤：1.获取SQLiteDatabase对象，它代表了与数据库的连接。2.调用SQLiteDatabase的方法执行SQL语句。3.操作SQL语句的执行结果，比如用SimpleCursorAdapter封装Cursor4.关闭SQLiteDatabase，回收资源。 SQLiteOpenHelper类在实际项目中更常用SQLiteOpenHelper开发子类，并通过子类的getReadableDatabase(),getWritableDatabase()方法打开数据库。 SQLiteOpenHelper包含如下常用的方法： synchronized SQLiteDatabase getReadableDatabase():以读写的方式打开数据库对应的SQLiteDatabase对象 synchronized SQLiteDatabase getWritableDatabase():以写的方式打开数据库对应的SQLiteDatabase对象 abstract void onCreate(SQLiteDatabase db):第一次创建数据库回调该方法 abstract void onUpgrade(SQLiteDatabase db,int oldVersion,int newVersion):当数据库版本更新回调该方法 synchronized void close():关闭所有打开的SQLiteDatabase对象 重写抽象方法： onCreate(SQLiteDatabase db):生成数据库表结构 onUpgrade(SQLiteDatabase db,int oldVersion,int new Version):当用户创建SQLiteOpenHelper对象时，必须指定一个version参数，该参数就是所使用的数据库版本。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>SQLite数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（三十二之Android数据存储与IO）]]></title>
    <url>%2F2018%2F08%2F18%2F8.18.2%2F</url>
    <content type="text"><![CDATA[安卓基础使用SharedPreferences应用程序少量的数据保存，这些数据的格式很简单，都是很普通的字符串、标量类型的值等，对于这种数据，Android提供了SharedPreferences进行保存 SharedPreferences与Editor简介SharedPreferences保存的数据主要是简单类型的key-value对。SharedPreferences接口主要负责读取应用程序的Preferences数据，它提供了如下方法： boolean contains(String key)：判断SharedPreferences是否包含特定key的数据 abstract Map&lt;String,?&gt; getAll()：获取SharedPreferences数据里全部的key-value对 boolean getXxx(String key,xxx defValue)：获取SharedPreferences数据里指定key对应的value。如果key不存在，返回默认值defValue。其中xxx可以是boolean、float、int、long、String等各种基本类型的值。 通过SharedPreferences的内部接口，SharedPreferences调用edit()方法即可获取它所对应的Editor对象。Editor提供了如下方法向SharedPreferences写入数据。 SharedPreferences.Editor clear()：清空SharedPreferences中所有数据 SharedPreferences.Editor putXxx(String key,xxx value)：向SharedPreferences存入指定key对应的数据 SharedPreferences.Editor remove(String key)：删除SharedPreferences里指定key对应的数据项 boolean commit()：当Editor编辑完成后，调用该方法提交修改 程序无法直接创建SharedPreferences实例，只能通过Context提供的getSharedPreferences(String name,int mode)方法获取SharedPreferences实例（SharedPreferences是一个接口） File存储Android支持用FileInputStream、FileOutputStream这些IO流访问手机存储器上的文件。 ### openFileOutput和openFileInput Context提供热如下两个方法打开应用程序的数据文件夹里的文件IO流。 FileInputStream openFileInput(String name)：打开应用程序的数据文件夹下的name文件对应的输入流 FileOutputStream openFileOutput(String name,int mode)：打开应用程序的数据文件夹下的name文件对应的输出流 读写SD卡上的文件步骤： 调用Environment的getExternalStorageState()方法判断是否插入内存卡Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)如果返回true即是插入了SD卡 调用getExternalStorageDirectory()方法来获取外部存储器 使用FileInputStream,FileOutputStream,FileReader,FileWriter读写SD卡里的文件 必须插入SD卡，模拟器需要创建通过mskdcard 在AndroidManifest.xml中添加读写SD卡的权限，创建与删除文件权限：&lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;写入数据权限uses-premission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; ps：File.getCanonicalPath（）方法用来获取文件（文件夹）路径；使用时需要进行try/catch抛出IOException异常]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>使用SharedPreferences</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（三十一之Android应用的资源）]]></title>
    <url>%2F2018%2F08%2F18%2F8.18%2F</url>
    <content type="text"><![CDATA[安卓基础属性动画资源（Property Animation)它只是一个抽象类，通常使用它的子类：AnimatorSet、ValueAnimator、ObjectAnimator、TimeAnimator。定义属性动画的XML资源文件用以下三个元素中的任意一个作为根元素。 &lt;set../&gt;：它是父元素，可以用于包含这三种元素作为子元素 &lt;objectAnimator…/&gt;：用于定义ObjectAnimator动画 &lt;animator…/&gt;：用于定义ValueAnimator动画 ObjectAnimator colorAnim = (ObjectAnimator) AnimatorInflater.loadAnimator(MainActivity.this,R.animator.color_anima使用AnimatorInflater工具类加载了指定动画资源文件，并将该动画资源文件转化为ObjectAnimator对象。 使用原始XML资源Android应用推荐用XML文件保存一些初始化的配置信息、应用相关的数据资源。这种资源就叫原始XML资源。 定义原始XML资源原始XML资源一般保存在/res/xml/路径下，需要开发者手动创建xml子目录。为了在Java代码中获取实际的XML文档，可以通过Resource的如下两个方法实现： XmlResourceParser getXml(int id)：获取XML文档，并使用一个XmlPullParser来解析该XML文档，该方法返回一个解析器对象。（XmlResourceParser是XmlPullParser的子类） InputStream openRawResource(int id)：获取XML文档对应的输入流 使用原始XML文件使用布局（Layout）资源使用菜单（Menu）资源样式（Style）和主题（Theme）资源样式资源Android的样式资源文件在/res/values/目录下，根元素是&lt;resources…/&gt;元素，该元素内可包含多个&lt;style../&gt;子元素，每个&lt;style…/&gt;子元素定义一个样式。 &lt;style../&gt;元素内可包含多个&lt;item../&gt;子元素，每个&lt;item../&gt;子元素定义一个格式项。 主题资源它的XML文件也通常放在/res/values/目录下，主题资源的XML文件同样以&lt;resources…/&gt;元素作为根元素，同样使用&lt;style../&gt;元素来定义主题。主题与样式的区别主要体现在： 主题不能作用于单个的View组件，主体应该对整个应用中的所有Activity起作用，或对指定的Activity起作用 主题定义的格式应该是改变窗口外观的格式，例如窗口标题，窗口边框等 如果想让应用中全部窗口使用该主题，那么只要在AndroidManifest.xml文件中&lt;application../&gt;元素加android:theme属性即可。如果只想让程序中的某个Activity拥有这个主题，那么可以修改&lt;activity…/&gt;元素，同样通过android:theme指定主题即可。 Android提供的几种内置的主题资源，同样支持继承。 属性(Attribute)资源它的XML文件也通常放在/res/values/目录下，主题资源的XML文件同样以&lt;resources…/&gt;元素作为根元素，该元素包含如下两个子元素： attr子元素：定义一个属性 declare-styleable子元素：定义一个styleable对象，每个styleable对象就是一组attr属性的集合 使用原始资源Android的原始资源可以放在如下两个地方： 位于/res/raw/目录下，Android SDK会处理该目录下的原始资源，Android SDK会在R清单类中为该目录下的资源生成一个索引项 位于/assets/目录下，该目录下的资源是一个更彻底的原始资源。Android应用通过AssetManager来管理该目录下的原始资源 AssetManager是一个专门管理/assets/目录下原始资源的管理器类，AssetManager提供了如下两个常用方法来访问Assets资源。 InputStream open(String fileName)：根据文件名来获取原始资源对应的输入流 AssetFileDescriptor openFd(String fileName)：根据文件名来获取原始资源对应的AssetFileDesciptor。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>应用资源概述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（三十之Android应用的资源）]]></title>
    <url>%2F2018%2F08%2F17%2F8.17%2F</url>
    <content type="text"><![CDATA[安卓基础数组资源(Array)Andriod采用位于/res/values目录下的arrays.xml文件来定义数组资源，定义数组也是用&lt;resources…/&gt;，该元素可包含如下三种子元素： &lt;array…/&gt;：普通类型的数组 &lt;string-array…/&gt;：字符串数组 &lt;integer-array…/&gt;：整型数组 图片资源为了在程序中获得实际的Drawable对象，Resources提供了Drawable getDrawable(int id)方法，该方法根据Drawable资源在R资源清单中的ID来获取实际的Drawable对象 StateListDrawable资源StateListDrawable可以包含多个Drawable对象，主要用来根据组件状态变化，展现Drawable变化 StateListDrawable对象的XML文件的根元素为&lt;selector…/&gt;，该元素可以包含多个&lt;item…/&gt;元素，该元素有如下属性： android:color,android:drawable android:state-xxx：指定一个特定状态，如：active,checkable可勾选,checked已选择,enabled,first开始状态,focused已得到焦点,last结束状态,middle中间状态,pressed,selected已被选中状态,window_focused LayerDrawable资源也可以包含一个Drawable数组，系统按索引最大的Drawable对象绘制在最上面。LayerDrawable对象的XML文件的根元素为&lt;layer-list…/&gt; 可以利用这个资源来绘制拖动条，将索引大的覆盖索引小的。 ShapeDrawable资源用来定义一个基本的几何图形。定义ShapeDrawable的XML文件的根元素是&lt;shape…/&gt;元素，该元素可以指定如下属性： android:shape=[“rectangle”|”oval”|”line”|”ring”]：指定哪种类型的几何图形 ClipDrawable资源代表从其他位图上截取的一个“图片片段”。在XML文件中定义ClipDrawable对象使用&lt;clip…/&gt;元素。 可指定如下三个属性： android:drawable：指定截取的源Drawable对象 android:clipOrientation：指定截取方向，可设置水平截取或垂直截取 android:gravity：指定截取时的对齐方式 使用ClipDrawable对象时，调用setLevel(int level)方法来设置截取的区域大小，当Level为0时，截取的图片片段为空；当level为10000时，截取整个图片。 AnimationDrawable资源它代表一个动画，有逐帧动画和补间动画。定义补间动画的XML资源文件以&lt;set…/&gt;元素作为根元素，该元素可以指定如下4个元素： alpha：设置透明度的改变 scale：设置图片进行缩放变化 translate：设置图片进行位移变化 rotate：设置图片进行旋转 定义动画的XML文件放在/res/anmi/路径下，需要开发者自行创建 定义补间动画的思路：先设置一张图片的开始状态，并设置该图片的结束状态，再设置动画的持续时间。 AnimationDrawable对象的元素都可以指定一个android:interpolator属性，该属性指定动画的变化速度，如： linear_interpolator：匀速变化 accelerate_interpolator：加速变化 decelerate_interpolator：减速变化 如果程序想让&lt;set…/&gt;元素下所有的变化效果使用相同的动画速度，则可指定android：shareInterpolator=”true” 为了在Java代码中获取实际的Animation对象，可调用AnimationUtils的方法：loadAnimation(Context ctx,int resId)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>应用资源概述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（三十之Android应用的资源）]]></title>
    <url>%2F2018%2F08%2F16%2F8.16.2%2F</url>
    <content type="text"><![CDATA[安卓基础## 应用资源概述 安卓应用资源分为两类 无法通过R资源清单访问的原生资源，保存在assets目录下 可通过R资源清单访问的资源，保存在res目录下 资源的类型及存储方式使用资源 在Java代码中使用资源清单项 在Java代码中访问实际资源 通过资源清单项获取实际资源 getXxx(int id)：根据资源清单ID来获取实际资源 getAssets() ：获取访问/assets/目录下资源的AssetManager对象 在XML文件中使用资源 字符串、颜色、尺寸资源字符串资源、颜色资源、尺寸资源，它们对应的XML文件都将位于/res/values/目录下 颜色值的定义Android颜色值支持常见的4种形式 #RGB #ARGB #RRGGBB #AARRGGBB 上面4种形式中，A、R、G、B都代表一个十六进制的数 定义字符串、颜色、尺寸资源文件]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>应用资源概述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（二十九之使用Intent和IntentFilter进行通信）]]></title>
    <url>%2F2018%2F08%2F15%2F8.16%2F</url>
    <content type="text"><![CDATA[安卓基础Intent对象简述使用Intent启动不同组件的方法： 组件类型 启动方法 Activity startActivity(Intent intent) startActivityForResult(Intent intent,int requestCode) Service ComponentName startService(Intent service) boolean bindService(Intent service,ServiceConnection conn,int flags) BroadcastReceiver sendBroadcast(Intent intent) sendBroadcast(Intent intent,String receiverPermission) sendOrderedBroadcast(Intent intent,String receiverPermission,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras) sendOrderedBroadcast(Intent intent,String receiverPermission) BroadcastReceiver sendStickyBroadcast(Intent intent) sendStickyOrderedBroadcast(Intent intent,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras) Intent对象大致包含Component、Action、Category、Data、Type、Extra、Flag这7种属性，其中Component用于明确指定需要启动的目标组件，而Extra则用于“携带”需要交换的数据 Intent的属性及Intent-filter配置启动组件，取决于Intent的各属性 Component属性指定了Component属性的Intent是显式Intent，没有指定的是隐式Intent——隐式Intent没有指出明确的对象，只要是符合筛选条件就行。 Intent的Component属性需要接受一个ComponentName对象。 当程序通过Intent的Component属性（明确指定了启动哪个组件）启动特定组件时，被启动组件几乎不需要使用&lt;intent_filter…/&gt;元素进行配置 Action、Category属性与intent-filter配置&lt;intent-filter…/&gt;元素是AndroidManifest.xml文件中&lt;activity…/&gt;元素的子元素，&lt;activity…/&gt;元素用于为应用程序配置Activity，&lt;activity../&gt;的&lt;intent-filter…/&gt;子元素则用于配置该Activity所能“响应”的Intent。 当&lt;activity../&gt;元素的&lt;intent-filter…/&gt;子元素里包含多个&lt;action../&gt;子元素时，就表明该Activity能响应Action属性值为其中任意一个字符串的Intent。 一个Intent对象最多只能包含一个Action属性，程序调用Intent的setAction(String str)方法设置Action属性值；一个Intent对象可以包括多个Category属性，程序调用Intent的addCategory(String str)方法来为Intent添加Category属性。 Activity到底启动哪个Activity，需要看&lt;intent-filter…/&gt;中元素的配置。（可以想成启动符合条件的Activity） 指定Action、Category调用ActivityIntent不仅可以启动本应用程序内程序组件，也可以启动Android系统的其他应用的程序组件。 Data、Type属性与intent-filter配置Data属性通常用于向Action属性提供操作的数据。Type属性用于指定该Data属性所指定Uri对应的MIME的类型。 Data属性与Type属性会相互覆盖： Intent先设置Data属性，那么Type属性将会覆盖Data属性 Intent先设置Type属性，那么Data属性将会覆盖Type属性 如果希望Intent有两种属性，调用Intent的setDataAndType()方法 在AndroidManifest.xml中为组件声明Data、Type属性都通过&lt;data../&gt;元素 使用Intent创建Tab页使用TabActivity创建Activity布局，添加Tab页使用了TabHost.TabSpec提供的如下方法： setContent(int viewId)：直接将指定View组件设置成Tab页的Content setContent(Intent intent)：直接将指定Intent对应的Activity设置成Tab页的Content]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Intent对象简述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（二十八之Activity的生命周期与加载模式）]]></title>
    <url>%2F2018%2F08%2F15%2F8.15.2%2F</url>
    <content type="text"><![CDATA[安卓基础Activity在Android应用中，以Activity栈形式管理，当前运行的Activity位于栈顶。随着不同应用的运行，每个Activity都有可能从活动状态转变为非活动状态，也可能从非活动状态转为活动状态。 Activity的生命周期Activity大致会经历下面4种状态： 运行状态：当前Activity位于前台，用户可见，可以获得焦点 暂停状态：其他Activity位于前台，该Activity依然可见，只是不能获得焦点 停止状态：该Activity不可见，失去焦点 销毁状态：该Activity结束，或Activity所在的进程被结束 Activity与Servlet的相似性和区别相似性： Activity,Servlet的职责都是向用户呈现界面 开发者开发Activity和Servlet都继承系统的基类 Activity、Servlet开发出来都需要配置 Activity开发用于Android、Servlet用于Web 开发者无须创建Activity和Servlet的实例，无须调用它们的方法。它们的方法都由系统以回调的方式来调用 Activity、Servlet都有各自的生命周期，他们的生命周期都由外部负责管理 Activity、Servlet都不会直接相互调用，因此都不能直接进行数据交换。Servlet的数据交换需要借助于Web应用提供的requestScope、sessionScope等。Activity之间的数据交换借助于Bundle。 差别： Activity是Android窗口的容器，因此Activity最终以窗口形式显示出来。而Servlet并不会生成应用界面，只是向浏览者生成文本响应 Activity运行于Android应用中，因此Activity的本质还是通过各种界面组件来搭建界面；而Servlet则主要以IO流向浏览者生成文本响应，浏览者看到的界面其实是由浏览器负责生成的 Activity之间的跳转主要通过Intent对象来控制；而Servlet之间的跳转主要由用户的请求来控制 ## Fragment 把Fragment理解成Activity片段。Fragment拥有自己的生命周期，也可以接受它自己的输入事件 Fragment概述Fragment必须被“嵌入”Activity中使用，因此，虽然Fragment也拥有自己的生命周期，但Fragment的生命周期会受它所在的Activity的生命周期控制。例如：当Activity暂停时，在Activity中的Fragment都会被暂停；当Activity被销毁时，在Activity中的Fragment都会被销毁。只有当该Activity处于活动状态时，程序员才可以通过方法独立地操作Fragment。 Fragment有如下特征: Fragment总是作为Activity界面的组成部分。Fragment调用getActivity（）方法获取它所在的Activity，Activity调用FragmentManager的findFragmentById（）或findFragmentByTag（）方法获取Fragment 在Activity运行过程中，可调用FragmentManager的add（）、remove（）、replace（）方法动态地添加、删除或者替换Fragment 一个Activity可以同时组合多个Fragment，一个Fragment也可以被多个Activity复用 Fragment可以响应自己的输入事件，并拥有自己的生命周期，但他们的生命周期直接被其所属的Activity的生命周期控制 创建Fragment需要实现如下三个方法： onCreate（）：系统创建Fragment对象后回调该方法，在实现代码中只初始化想要在Fragment中保持的必要组件，当Fragment被暂停或停止后可以恢复 onCreateView（）：当Fragment绘制界面组件时会回调该方法。该方法必须返回一个View，该View也就是该Fragment所显示的View onPause（）：当用户离开该Fragment时将会回调该方法 Fragment的生命周期与Activity类似，Fragment的生命周期也存在与Activity一样的4个状态。 Fragment与Activity对比生命周期：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Activity的生命周期</tag>
        <tag>Activity与Servlet</tag>
        <tag>Fragment概述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（二十七）]]></title>
    <url>%2F2018%2F08%2F15%2F8.15%2F</url>
    <content type="text"><![CDATA[安卓基础启动、关闭ActivityActivity启动其他Activity有两种方法： startActivity(Intent intent)：启动其他的Activity startActivityForResult(Intent intent,int requestCode)：以指定的请求码（requestCode）启动Activity，而且程序将会获取新启动的Activity返回的结果（通过重写onActivityResult(..)方法来获取） 一个Activity通过Intent来表达自己“意图”——想要启动哪个组件，被启动的组件既可以是Activity组件，也可以是Service组件。 Android关闭Activity准备了如下两种方法： finish()：结束当前Activity finishActivity(int requestCode)：结束以startActivityForResult(Intent intent,int requestCode)方法启动的Activity ps：finish()方法是将Activity移出栈，onDestroy()方法是销毁Activity。 使用Bundle在Activity之间交换数据当一个Activity启动另一个Activity时，需要传一些数据进去，这就像Servlet跳转另一个Servlet时，习惯把需要交换的数据放入requestScope、sessionScope中。对于Activity之间交换数据，我们主要将需要交换的数据放入Intent中即可。Intent提供了多个重载的方法来“携带”额外的数据： putExtras(Bundle data)：向Intent中放入需要“携带”的数据包 Bundle getExtras()：取出Intent中所“携带”的数据包 putExtra(String name,Xxx value)：向Intent中按Key-value对的形式存入数据 getXxxExtra(String name)：从Intent中按Key取出指定类型的数据 上面方法中Bundle就是一个简单的数据携带包，该Bundle对象包含了多个方法来存入数据。 putXxx(String key,Xxx data)：向Bundle中放入Int、Long等各种类型的数据 putSerializable(String key,Serializable data)：向Bundle中放入一个可序列化的对象。 为了取出Bundle数据携带包里的数据，Bundle提供了如下方法： getXxx(String key)：从Bundle中取出Int、Long等各种类型的数据。 getSerializable(String key,Serializable data)：从Bundle中取出一个可序列化的对象。 ps： @Override public void onCreate(Bundle savedInstanceState, PersistableBundle persistentState) { super.onCreate(savedInstanceState, persistentState); } 与 @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); } 有两个参数的方法不能关联到Layout界面。既不能显示布局，也不能完成Intent跳转。 启动其他Activity并返回结果这种请求用于：应用程序的第一个界面需要用户进行选择——但需要选择的列表数据比较复杂，必须启动另一个Activity让用户选择。当用户在第二个Activity中选择完成后，程序返回第一个Activity，第一个Activity必须能显示用户在第二个Activity中选择的结果。在这种场景下，也是用Bundle进行数据交换的。 为了获取被启动的Activity所返回的结果： 当前Activity需要重写onActivityResult(int requestCode,int resultCode,Intent intent)，而被启动的Activity返回结果时，该方法触发，其中requestCode和resultCode分别是请求码和结果码 被启动的Activity需要调用setResult()方法设置处理结果 Activity的回调机制在开发通用性质的应用框架时，程序架构完成整个应用的通用功能、流程，但在某个特定的点上，需要一段业务相关的代码——通用的程序架构无法实现这段代码，那么程序架构会在这个点上留一个“空”。对于Java程序来说，程序架构在某个点上留下的“空”，可以以如下两种方式存在。 以接口形式存在 以抽象方法（非抽象的方法）的形式存在：这就是Activity的实现方式。开发者直接重写已经被定义的方法，通用的程序架构就会回调该方法来完成业务相关的处理]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>启动、关闭Activity</tag>
        <tag>使用Bundle在Activity之间交换数据</tag>
        <tag>启动其他Activity并返回结果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（二十六之深入理解Activity与Fragment）]]></title>
    <url>%2F2018%2F08%2F14%2F8.14.2%2F</url>
    <content type="text"><![CDATA[安卓基础Activity是Android应用中最重要的组成单元之一(其他三个是Service、BroadcastReceiver和ContentProvider)，而Activity是Android应用最常见的组件之一。在实际应用中，往往包括多个Activity，不同的Activity向用户呈现了不同的操作界面。Android应用的多个Activity组成Activity栈，当前活动的Activity位于栈顶。实际上Activity对于Android应用的作用有点类似于Servlet对于Web应用的作用——一个Web应用通常需要N个Servlet组成（JSP的本质依然是Servlet）；那么一个Android应用通常也需要N个Activity组成。对于Web应用而言，Servlet（把JSP也统一成Servlet）主要负责与用户交互，并向用户呈现应用状态；对于Android应用而言，Activity大致也具有相同的功能。 建立、配置和使用ActivityActivity与开发Servlet类似，开发Activity也需要继承Activity基类。有时也要继承Activity的子类。创建一个Activity也需要实现一个或多个方法，其中最常见的就是实现onCreate（Bundle status）方法，该方法会在Activity被创建时被回调；setContentView（View view）方法来显示要展示的View；findViewById（int id）方法来获取程序界面中的组件。 实例：用LauncherActivity开发启动Activity的列表ListActivity是用来界面中只显示一个列表，LauncherActivity继承了ListActivity，它开发出来的列表界面与普通列表界面有所不同。它开发出来的列表界面中的每个列表项都对应于一个Intent，因此当用户单击不同的列表项时，应用程序会自动启动对应的Activity。使用LauncherActivity时，需要为它设置Adapter——ArrayAdapter、SimpleAdapter、BaseAdapter。与使用普通的ListActivity不同的是，继承LauncherActivity时通常应该重写Intent intentForPosition(int position)方法，该方法根据不同列表项返回不同的Intent（用于启动不同的Activity）。 123456789101112131415161718192021222324252627package com.example.otheractivity;import androidx.appcompat.app.AppCompatActivity;import android.app.LauncherActivity;import android.content.Intent;import android.os.Bundle;import android.widget.ArrayAdapter;public class MainActivity extends LauncherActivity &#123; //定义两个Activity的名称 String[] names = &#123;&quot;设置程序参数&quot;,&quot;查看英雄&quot;&#125;; //定义两个Activity的实现类 Class&lt;?&gt;[] clazzs = &#123;PreferenceActivityTest.class,ExpandableListActivityTest.class&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_expandable_list_item_1,names); //设置窗口显示的列表所需的Adapter setListAdapter(adapter); &#125; //根据列表项返回指定Activity对应的Intent @Override protected Intent intentForPosition(int position) &#123; return new Intent(MainActivity.this,clazzs[position]); &#125;&#125; 实例：使用ExpandableListActivity实现可扩展开的Activity为继承自ExpandableListActivity的Activity传入一个ExpandableListAdapter对象，ExpandableListActivity将会生成一个显示可扩展开列表的窗口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.example.otheractivity;import android.app.ExpandableListActivity;import android.os.Bundle;import android.os.PersistableBundle;import android.view.Gravity;import android.view.View;import android.view.ViewGroup;import android.widget.AbsListView;import android.widget.BaseExpandableListAdapter;import android.widget.ExpandableListAdapter;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.TextView;public class ExpandableListActivityTest extends ExpandableListActivity &#123; @Override public void onCreate(Bundle savedInstanceState, PersistableBundle persistentState) &#123; super.onCreate(savedInstanceState, persistentState); ExpandableListAdapter adapter = new BaseExpandableListAdapter() &#123; int[] logos = new int[]&#123;R.drawable.adc,R.drawable.ap,R.drawable.top&#125;; private String[] armTypes = new String[]&#123;&quot;薇恩&quot;,&quot;泽拉斯&quot;,&quot;菲奥娜&quot;&#125;; private String[][] armSkins =new String[][]&#123;&#123;&quot;原画&quot;,&quot;猎天使魔女&quot;,&quot;苍穹之光&quot;,&quot;摄魂猎手&quot;&#125;, &#123;&quot;原画&quot;,&quot;圣金巫灵&quot;&#125;, &#123;&quot;原画&quot;,&quot;夜鸦&quot;,&quot;皇家守卫&quot;,&quot;女校长&quot;,&quot;泳池派对&quot;&#125;&#125;; @Override public int getGroupCount() &#123; return armTypes.length; &#125; @Override public int getChildrenCount(int i) &#123; return armSkins[i].length; &#125; //获取指定组位置处的组数据 @Override public Object getGroup(int i) &#123; return armTypes[i]; &#125; //获取指定组位置、指定子列表项处的子列表项数据 @Override public Object getChild(int i, int i1) &#123; return armSkins[i][i1]; &#125; @Override public long getGroupId(int i) &#123; return i; &#125; @Override public long getChildId(int i, int i1) &#123; return i1; &#125; @Override public boolean hasStableIds() &#123; return true; &#125; //该方法决定每个组选项的外观 @Override public View getGroupView(int i, boolean b, View view, ViewGroup viewGroup) &#123; LinearLayout ll = new LinearLayout(ExpandableListActivityTest.this); ll.setOrientation(LinearLayout.HORIZONTAL); ImageView logo = new ImageView(ExpandableListActivityTest.this); logo.setImageResource(logos[i]); ll.addView(logo); TextView textView = getTextView(); textView.setText(getGroup(i).toString()); ll.addView(textView); return ll; &#125; //该方法决定每个子选项的外观 @Override public View getChildView(int i, int i1, boolean b, View view, ViewGroup viewGroup) &#123; TextView textView = getTextView(); textView.setText(getChild(i,i1).toString()); return textView; &#125; @Override public boolean isChildSelectable(int i, int i1) &#123; return true; &#125; private TextView getTextView()&#123; AbsListView.LayoutParams lp = new AbsListView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,64); TextView textView = new TextView(ExpandableListActivityTest.this); textView.setLayoutParams(lp); textView.setGravity(Gravity.CENTER_VERTICAL|Gravity.LEFT); textView.setPadding(36,0,0,0); return textView; &#125; &#125;; //设置该窗口显示列表 setListAdapter(adapter); &#125;&#125; 实例：PreferenceActivity结合PreferenceFragment实现参数设置界面当我们开发一个Android应用程序时，不可避免地需要进行选项设置，这些选项设置会以参数的形式保存，习惯上我们会用Preference进行保存。一旦Activity继承了PreferenceActivity，那么该Activity完全不需要自己控制Preferences的读写，PreferenceActivity会为我们处理一切。PreferenceActivity与普通Activity不同，它不再使用普通的界面布局文件，而是使用选项设置的布局文件。选项设置的布局文件以PreferenceScreen作为根元素——它表明定义一个参数设置的界面布局。Android不再推荐直接让PreferenceActivity加载选项设置的布局文件，而是建议将PreferenceActivity与PreferenceFragment结合使用，其中PreferenceActivity只负责加载选项设置列表的布局文件，PreferenceFragment才负责加载选项设置的布局文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.example.otheractivity;import android.os.Bundle;import android.os.PersistableBundle;import android.preference.PreferenceActivity;import android.preference.PreferenceFragment;import android.widget.Button;import android.widget.Toast;import java.util.List;public class PreferenceActivityTest extends PreferenceActivity &#123; @Override public void onCreate(Bundle savedInstanceState, PersistableBundle persistentState) &#123; super.onCreate(savedInstanceState, persistentState); //该方法应用于为该界面设置一个标题按钮 if (hasHeaders())&#123; Button button = new Button(this); button.setText(&quot;设置操作&quot;); //将按钮添加到该界面上 setListFooter(button); &#125; &#125; //重写该方法，负责加载界面布局文件 @Override public void onBuildHeaders(List&lt;Header&gt; target) &#123; //加载选项设置列表的布局文件 loadHeadersFromResource(R.xml.preference_headers,target); &#125; //重写该方法，验证各PreferenceFragment是否有效 @Override protected boolean isValidFragment(String fragmentName) &#123; return true; &#125; public static class Prefs1Fragment extends PreferenceFragment&#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); addPreferencesFromResource(R.xml.preferences); &#125; &#125; public static class Prefs2Fragment extends PreferenceFragment&#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); addPreferencesFromResource(R.xml.display_prefs); //获取传入该Fragment的参数 String website = getArguments().getString(&quot;website&quot;); Toast.makeText(getActivity(),&quot;网站域名是：&quot;+website,Toast.LENGTH_LONG).show(); &#125; &#125;&#125; preference_headers.xml源码 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;preference-headers xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;header android:fragment=&quot;com.example.otheractivity.PreferenceActivityTest$Prefs1Fragment&quot; android:title=&quot;程序选项设置&quot; android:summary=&quot;设置应用相关选项&quot;/&gt; &lt;header android:fragment=&quot;com.example.otheractivity.PreferenceActivityTest$Prefs2Fragment&quot; android:title=&quot;界面选项设置&quot; android:summary=&quot;设置显示界面的相关选项&quot;&gt; &lt;extra android:name=&quot;website&quot; android:value=&quot;www.crazyit.org&quot;/&gt; &lt;/header&gt; &lt;header android:title=&quot;使用Intent&quot; android:summary=&quot;使用Intent启动某个Activity&quot;&gt; &lt;intent android:action=&quot;android.intent.action.VIEW&quot; android:data=&quot;http://www.crazyit.org&quot;/&gt; &lt;/header&gt;&lt;/preference-headers&gt; preferences.xml源码 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;PreferenceScreen xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;RingtonePreference android:ringtoneType=&quot;all&quot; android:title=&quot;设置铃声&quot; android:summary=&quot;选择铃声（测试RingtonePreference）&quot; android:showDefault=&quot;true&quot; android:key=&quot;ring_key&quot; android:showSilent=&quot;true&quot;&gt; &lt;/RingtonePreference&gt; &lt;PreferenceCategory android:title=&quot;个人信息设置组&quot;&gt; &lt;EditTextPreference android:key=&quot;name&quot; android:title=&quot;填写用户名&quot; android:summary=&quot;填写您的用户名（测试EditTextPreference）&quot; android:dialogTitle=&quot;您所使用的用户名为：&quot;/&gt; &lt;ListPreference android:key=&quot;gender&quot; android:title=&quot;性别&quot; android:summary=&quot;选择您的性别（测试ListPreference）&quot; android:dialogTitle=&quot;ListPreference&quot; android:entries=&quot;@array/gender_name_list&quot; android:entryValues=&quot;@array/gender_value_list&quot;/&gt; &lt;/PreferenceCategory&gt; &lt;PreferenceCategory android:title=&quot;系统功能设置组&quot;&gt; &lt;CheckBoxPreference android:key=&quot;autoSave&quot; android:summaryOn=&quot;自动保存：开启&quot; android:summaryOff=&quot;自动保存：关闭&quot; android:defaultValue=&quot;true&quot;/&gt; &lt;/PreferenceCategory&gt;&lt;/PreferenceScreen&gt; display_prefs.xml源码 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;PreferenceScreen xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;PreferenceCategory android:title=&quot;背景灯光组&quot;&gt; &lt;ListPreference android:key=&quot;light&quot; android:title=&quot;灯光强度&quot; android:summary=&quot;请选择灯光强度（测试ListPreference）&quot; android:dialogTitle=&quot;请选择灯光强度&quot; android:entryValues=&quot;@array/light_value_list&quot; android:entries=&quot;@array/light_strength_list&quot;/&gt; &lt;/PreferenceCategory&gt; &lt;PreferenceCategory android:title=&quot;文字显示组&quot;&gt; &lt;SwitchPreference android:key=&quot;autoScroll&quot; android:title=&quot;自动滚屏&quot; android:summaryOn=&quot;自动滚屏：开&quot; android:summaryOff=&quot;自动滚屏：关&quot; android:defaultValue=&quot;true&quot;/&gt; &lt;/PreferenceCategory&gt;&lt;/PreferenceScreen&gt; arrays.xml源码 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;string-array name=&quot;gender_name_list&quot;&gt; &lt;item&gt;男&lt;/item&gt; &lt;item&gt;女&lt;/item&gt; &lt;/string-array&gt; &lt;string-array name=&quot;gender_value_list&quot;&gt; &lt;item&gt;男&lt;/item&gt; &lt;item&gt;女&lt;/item&gt; &lt;/string-array&gt; &lt;string-array name=&quot;light_value_list&quot; &gt; &lt;item&gt;50&lt;/item&gt; &lt;item&gt;100&lt;/item&gt; &lt;item&gt;150&lt;/item&gt; &lt;/string-array&gt; &lt;string-array name=&quot;light_strength_list&quot; &gt; &lt;item&gt;50&lt;/item&gt; &lt;item&gt;100&lt;/item&gt; &lt;item&gt;150&lt;/item&gt; &lt;/string-array&gt;&lt;/resources&gt; 其他当在AndroidManifest.xml中配置Activity时，若使用&lt;activity name=””未出现新建的Activity，则观察是否给Activity加了Public class。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>建立、配置和使用Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（二十五之Android的事件处理）]]></title>
    <url>%2F2018%2F08%2F14%2F8.14%2F</url>
    <content type="text"><![CDATA[安卓基础其他实际上不推荐将业务逻辑实现写在事件监听器中，包含业务逻辑的事件监听器将导致程序的显示逻辑和业务逻辑耦合，从而增加程序后期的维护难度。如果确实有多个事件监听器需要实现相同的业务逻辑功能，则可以考虑使用业务逻辑组件来定义逻辑功能，再让事件监听器来调用业务逻辑组件的业务逻辑方法。 Activity本身作为事件监听器类可以直接在Activity类中定义事件处理器的方法。这种形式非常简洁，但这种做法有两个缺点： 造成程序结构的混乱，Activity的主要职责应该是完成界面初始化工作，但此时还需要包含事件处理器方法，从而引起混乱。 如果Activity界面类需要实现监听器接口，让人感觉比较怪异。 匿名内部类作为事件监听器大部分事件监听器只是临时使用一次，所以使用匿名内部类最为合适。 直接绑定到标签对于很多Android界面组件标签而言，他们都支持onClick属性，该属性的属性值就是一个形如xxx（View source）方法的方法名。 基于回调的事件处理从模型来看，基于回调的事件处理模型更加简单 回调机制和监听机制对于基于监听的事件处理模型来说，事件源和事件监听器是分离的，当事件源上发生特定事件时，该事件交给事件监听器负责处理；对于基于回调的事件处理模型来说，事件源和事件监听器是统一的，当事件源发生特定事件时，该事件还是由事件源本身负责处理。 基于回调的事件传播几乎所有基于回调的事件处理方法都有一个boolean类型的返回值，该返回值用于标识该方法是否能完全处理该事件。 如果处理事件的回调方法返回true，表明该处理方法已完全处理该事件，该事件不会传播出去 如果处理事件的回调方法返回false，表明该处理方法并未完全处理该事件，该事件会传播出去 返回值全为false时，当组件上发生某个按键被按下的事件时，Android系统最先触发的是该按键上绑定的事件监听器，然后才触发该组件上提供的事件回调方法，最后还会传播到该组件的Activity。 其他通过为View提供事件处理的回调方法，可以很好地把事件处理方法封装在该View内部，从而提高程序的内聚性——基于回调的事件处理更适合应付那种事件处理逻辑比较固定的View，比如跟随手指的View。 响应系统设置的事件在开发Android应用时，有时候可能需要让应用程序随系统设置而进行调整，比如判断系统的屏幕方向、判断系统方向的方向导航设备等。 Configuration类简介Configuration类专门用于描述手机设备上的配置信息，这些配置信息既包括用户特定的配置项，也包括系统的动态设备配置。程序可调用Activity的如下方法来获取系统的Configuration对象：Configuration cfg = getResources().getConfiguration(); 重写onConfigurationChanged方法响应系统设置更改如果程序需要监听系统设置的更改，则可以考虑重写Activity的onConfigurationChanged(Configuration newConfig)方法，该方法是一个基于回调的事件处理方法：当系统设置发生更改时，该方法会被自动触发。 实例：监听屏幕方向的改变（该界面就只有一个按钮，用来动态的修改系统屏幕的方向）MainActivity.java源码 1234567891011121314151617181920212223242526272829303132333435package com.example.changecfg;import androidx.appcompat.app.AppCompatActivity;import android.content.pm.ActivityInfo;import android.content.res.Configuration;import android.os.Bundle;import android.view.View;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void ChangeCfg(View view) &#123; Configuration config = getResources().getConfiguration(); if (config.orientation == Configuration.ORIENTATION_LANDSCAPE)&#123; MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); &#125; if (config.orientation == Configuration.ORIENTATION_PORTRAIT)&#123; MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE); &#125; &#125; @Override public void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); String screen = newConfig.orientation == Configuration.ORIENTATION_PORTRAIT?&quot;竖屏&quot;:&quot;横屏&quot;; Toast.makeText(this,&quot;系统的屏幕方向发生改变&quot;+&quot;\n修改后的屏幕方向为：&quot;+screen,Toast.LENGTH_LONG).show(); &#125;&#125; AndroidManifest.xml增加的源码 12&lt;activity android:name=&quot;.MainActivity&quot; android:configChanges=&quot;orientation|screenSize&quot;&gt; 在AndroidManifest中的配置代码指定了Activity可以监听屏幕方向改变的事件，当程序改变手机屏幕时，Activity中的onConfigurationChanged()方法就会被回调。 Handler消息传递机制出于性能优化考虑，Android的UI操作并不是线程安全的，这意味着如果有多个线程并发操作UI组件，则可能导致线程安全问题。为了解决这个问题，Android中制定了一条规则：只允许UI线程修改Activity里的UI组件。 当一个程序第一次启动时，Android会同时启动一条主线程（Main Thread），主线程主要负责处理与UI相关的事件，如用户的按键事件、用户接触屏幕的事件及屏幕绘图事件，并把相关的事件分发到对应的组件进行处理。所以，主线程通常又被叫做UI线程。 Android的消息传递机制是另一种形式的“事件处理”，这种机制主要是为了解决Android应用的多线程问题——Android平台只允许UI线程修改Activity里的UI组件，这样就会导致新启动的线程无法动态改变界面组件的属性值。但在实际Android应用开发中，尤其是涉及动画的游戏开发中，需要让新启动的线程周期性地改变界面组件的属性值，这就需要借助于Handler的消息传递机制了。 Handler类简介Handler类的主要作用有两个： 在新启动的线程中发送消息 在主线程中获取、处理消息 为了让主线程能“适时”地处理新启动的线程所发送的消息，显然只能通过回调的方式来实现——开发者只要重写Handler类中处理消息的方法，当新启动的线程发送消息时，消息会发送到与之关联的MessageQueue，而Handler会不断地从MessageQueue中获取并处理消息——这将导致Handler类中处理消息的方法被回调。 在自动播放图片实例中，定时器通过Timer周期性地执行指定任务，Timer可调度TimerTask对象，TimerTask对象的本质就是启动一条新线程，由于Android不允许在新线程中访问Activity里的界面组件，因此程序只能在新线程中发送一条消息，通知系统更新ImageView组件。 Handler、Loop、MessageQueue的工作原理Looper、MessageQueue、Handler各自的作用如下： Looper：每个线程只有一个Looper，它负责管理MessageQueue，会不断地从MessageQueue中取出消息，并将消息分给对应的Handler处理 MessageQueue：由Looper负责管理。它采用先进先出的方式来管理Message Handler：它能把消息发送给Looper管理的MessageQueue，并负责处理Looper分给它的消息 在线程中使用Handler的步骤如下： 调用Looper的prepare（）方法为当前线程创建Looper对象，创建Looper对象时，它的构造器会创建与之配套的MessageQueue 有了Looper之后，创建Handler子类的实例，重写handleMessage（）方法，该方法负责处理来自其他线程的消息 调用Looper的Loop（）方法启动Looper 实例：使用新线程计算质数 Ps：尽量避免在UI线程中执行耗时操作，因为这样可能导致一个“著名”的异常：ANR异常。只要在UI线程中执行需要消耗大量时间的操作，都会引发ANR，因为这会导致Android应用程序无法响应输入事件和Broadcast。 由于在新线程中创建Handler时必须先创建Looper因此程序先调用Looper的prepare（）方法为当前线程创建了一个Looper实例，并创建了配套的MessageQueue。新线程中有了Looper对象之后，接下来程序创建了一个Handler对象，该Handler可以处理其他线程发送过来的消息。程序最后还调用了Looper的loop（）方法。 异步任务（AsyncTask）为了避免UI线程失去响应的问题，Android建议将耗时操作放在新线程中完成，但新线程也可能需要动态更新UI组件，比如需要从网上获取一个网页，然后在TextView中将其源码显示出来，此时就应该将连接网络、获取网络数据的操作放在新线程中完成。但获取网络数据之后，新线程不允许直接更新UI组件。为了解决新线程不能更新UI组件的问题，Android提供了如下几种方法： 使用Handler实现线程之间的通信 Activity.runOnUiThread(Runnable) View.post(Runnable) View.postDelayed(Runnable,long) 后面三种方式比较烦琐，异步任务可以简化操作。异步任务，不需要借助线程和Handler即可实现。AsyncTask&lt;Params,Progress,Result&gt;是一个抽象类，通常用于被继承，继承时要指定如下三个泛型参数： Params：启动任务执行的输入参数的类型 Progress：后台任务完成的进度值的类型 Result：后台执行任务完成后返回结果的类型 使用AsyncTask只要如下三步即可： 创建AsyncTask的子类，并为三个泛型参数指定类型。如果某个泛型参数不需要指定类型，则可将它指定为Void 实现AsyncTask的如下方法 doInBackground(params)：重写该方法就是后台线程将要完成的任务。该方法可以调用publishProgress（Progress.. values）方法更新任务的执行进度 onProgressUpdate(progress.. values)：在doInBackground（）方法中调用publishProgress（）方法更新任务的执行进度后，将会触发该方法 onPreExceute()：该方法将在执行后台耗时操作前被调用。通常该方法用于完成一些初始化的准备工作，比如在界面上显示任务进度条等 onPostExecute(Result result)：当doInBackground（）完成后，系统会自动调用onPostExecute（）方法，并将doInBackground（）方法的返回值传给该方法 调用AsyncTask子类的实例的excute(Params.. params)开始执行耗时任务 使用AsyncTask时必须遵守如下规则 必须在UI线程中创建AsyncTask的实例 必须在UI线程中调用AsyncTask的execute（）方法 AsyncTask的onPreExecute(),onPostExecute(Result result),doInBackground(Params.. params),onProgressUpdate(Progress.. values)方法，不应该由程序员代码调用，而是由Andriod系统负责调用 每个AsyncTask只能被执行一次，多次调用将会引发异常 实现AsyncTask的子类，实现该子类时出现的如下4个方法： doInBackground()：完成实际的下载任务 onPreExecute()：在下载开始的时候显示一个进度条 onProgressUpdate()：随着下载进度的改变更新进度条的进度值 onPostExecute()：当下载完成之后，将下载的代码显示出来]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android事件处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（二十四）]]></title>
    <url>%2F2018%2F08%2F13%2F8.13.2%2F</url>
    <content type="text"><![CDATA[安卓基础Android事件处理概述Android提供了两套事件处理机制： 基于监听的事件处理 基于回调的事件处理 对于Android基于监听的事件崔而言，主要做法就是为Android界面组件绑定特定的事件监听器。ps：Android还允许用户在界面布局文件中为UI组件的android:onClick属性指定事件监听方法，通过这种方式指定事件监听方法时，开发者需要在Activity中定义该事件监听方法（该方法必须有一个View类型的形参，该形参代表被单击的UI组件），当用户单击该UI组件时，系统将会激发android:onClick属性所指定的方法。对于Android基于回调的事件处理而言，主要做法就是重写Android组件特定的回调方法，或者重写Activity的回调方法。一般来说，基于回调的事件处理可以用于一些具有通用性的事件，基于回调的事件处理代码会显得比较简洁。 基于监听的事件处理基于监听的事件处理是一种更“面向对象”的事件处理，这种处理方式与Java的AWT、Swing的处理方式几乎完全相同。 监听的处理模型在事件监听的处理模型中，主要涉及如下三类对象。 Event Source（事件源）：事件发生的场所，通常就是各个组件 Event（事件）：事件封装了界面组件上发生的特定事情（通常就是一次用户操作）。如果程序需要获得界面组件上所发生事件的相关信息，一般通过Event对象取得 Event Listener（事件监听器）：负责监听时间原所发生的事件，并对各种事件做出相应的响应 Java是面向对象的语言，方法不能独立存在，方法用来组织起来事件响应的动作，所以必须以类的形式组织这些方法，所以事件监听器的核心就是它所包含的方法-这些方法也被称为事件处理器（Event Handler）。 每个组件均可以针对特定的事件指定一个事件监听器，每个事件监听器也可监听一个或多个事件源。 用于监听的事件处理模型的步骤是： 获取普通界面组件（事件源），也就是被监听的对象 实现事件监听器类，该监听器类是一个特殊的Java类，必须实现一个XxxListener接口 调用事件源的setXxxListener方法将事件监听器对象注册给一个普通组件（事件源） Android为不同的界面组件提供了不同的事件监听器接口，这些接口通常以内部类的形式存在。以View为例，它包含如下几个内部接口： View.OnClickListener：单击 View.OnCreateContextMenuListener：创建上下文菜单 View.OnFocusChangeListener：焦点改变事件 View.OnKeyListener：按键事件 View.OnLongClickListener：长按事件 View.OnTouchListener：触摸事件]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android事件处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（二十三）]]></title>
    <url>%2F2018%2F08%2F13%2F8.13.1%2F</url>
    <content type="text"><![CDATA[安卓基础使用ActionBar显示选项菜单项Android不再要求手机必须提供MENU按键，这样可能导致用户无法打开选项菜单。为了解决这个问题，Android已经提供了ActionBar作为解决方案，ActionBar可以将选项菜单显示成Action Item。Menuitem新增了如下方法： setShowAsAction(int actionEnum)：该方法设置是否将该菜单项显示在ActionBar上，作为Action Item。 该方法支持如下参数值： SHOW_AS_ACTION_ALWAYS：总是将该MenuItem显示在ActionBar上 SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW：将该Action View折叠成普通菜单项 SHOW_AS_ACTION_IF_ROOM：当ActionBar位置足够时才显示MenuItem SHOW_AS_ACTION_NEVER：不将该MenuItem显示在ActionBar上 SHOW_AS_ACTION_WITH_TEXT：将该MenuItem显示在ActionBar上，并且显示该菜单项的文本 Android允许在XML菜单资源文件中为&lt;item…/&gt;元素指定如下属性 android：showAsAction：该属性的作用类似于setShowAsAction(int actionEnum)方法。因此该属性也能支持类似上面的属性值。 启用程序图标导航为了将应用程序图标转变为可以点击的图标，可以调用ActionBar的如下方法： setDisplayHomeAsUpEnable(boolean showHomeAsUp)：设置是否将应用程序图标转变为可点击的图标，并在图标上添加一个向左的箭头 setDisplayOptions(int options)：通过传入int类型常量来控制该ActionBar的显示选项 setDisplayShowHomeEnabled(boolean showHome)：设置是否显示应用程序图标 setHomeButtonEnabled(boolean enabled)：设置是否将应用程序图标变为可点击的按钮 添加Action ViewActionBar上除了可以显示普通的Action Item之外，还可以显示普通的UI组件。为了在ActionBar上添加Action View，可以用来如下两种方式。 定义Action Item时使用android:actionViewClass属性指定Action View的实现类 定义Action Item时使用android:actionLayout属性指定ActionView对应的视图资源 使用ActionBar实现Tab导航为了使用ActionBar实现Tab导航，按如下步骤进行即可 调用ActionBar的setNavigationMode(ActionBar.NAVIGATION_MODE_TABS)方法设置使用Tab导航方式 调用ActionBar的addTab()方法添加多个标签，并为每个Tab标签添加事件监听器 在实际项目中为了更好地展现Tab导航效果，ActionBar通常会与Fragment结合使用。 FragmentFragment是Android3.0新增的API，Fragment相当于Activity片段，通常我们使用单独的Activity组合多个Fragment，这样即可在一个Activity中创建多个用户界面。除此之外，也可以让多个Activity复用同一个Fragment。总之，Fragment相当于Activity的模块化区域。（多对多）Fragment拥有自己的生命周期，它可以接收、处理属于它自己的事件，并允许Activity运行期间动态地添加、删除Fragment。Fragment允许定义自己的布局，也可以通过生命周期回调定义自己的行为。与开发Activity类似的是，开发者自定义的Fragment也需要继承Fragment，并重写它的生命周期方法，通常会重写Fragment的onCreatView()生命周期方法。ps：viewPager用来给Fragment添加滑动功能；可以使用下面这个方法viewPager.setOffscreenPageLimit(3)设置缓存view 的个数为3。通常我们的ViewPager只会缓存当前页面的前后俩个页面，如果我切换到最后一个页面，则只会缓存前面的一个页面，会导致页面数据的重新加载。我们可以通过上面第三行的方法设置缓存页面的个数。当然，这只使用与页面较少的情况。 Android3.0以前的Fragment支持该Fragment不是继承android.app.Fragment，而是继承android.support.v4.app.Fragment。除此之外，Android还为该android.support.v4.app.Fragment提供了如下配套类。 FragmentActivity：只有该类提供的getSupportFragmentManager()方法才能获取Fragment管理器 ViewPager：它是Fragment容器，可以同时管理多个Fragment，并允许多个Fragment切换时提供动画效果 FragmentPagerAdapter：Adapter类，用于为ViewPager提供多个Fragment。通常用于被扩展 PagerTitleStrip：与ViewPager结合使用，用于在ViewPager上显示“导航条”。 使用ActionBar实现下拉式导航为了使用ActionBar实现下拉式导航，按如下步骤进行即可 调用ActionBar的actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_LIST)方法设置使用下拉列表的导航方式。 调用ActionBar的setListNavigationCallbacks(SpinnerAdapter adapter,ActionBar.OnNavigationListener callback)方法添加多个列表项，并为每个列表项设置事件监听器。其中第一个参数Adapter负责提供多个列表项，第二个参数为事件监听器。 其他AnalogClock在XML中是虚拟时钟。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ActionBar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（二十二）]]></title>
    <url>%2F2018%2F08%2F05%2F8.5.1%2F</url>
    <content type="text"><![CDATA[安卓基础使用活动条(ActionBar)活动条（ActionBar）是Android3.0的重要更新之一。ActionBar显示在屏幕的顶部。ActionBar可显示应用的图标和Activity标题。除此之外，ActionBar的右边还可以显示活动项（Action Item）。 ActionBar提供了如下功能： 显示选项菜单的菜单项（将菜单项显示成ActionItem） 使用程序图标作为返回Home主屏或向上的导航操作 提供交互式View作为ActionView 提供基于Tab的导航方式，可用于切换多个Fragment 提供基于下拉的导航方式 启用ActionBar最新的Android版本已经默认启用了ActionBar。因此只要在AndroidManifest.xml文件的SDK配置中指定该应用的目标版本高于11（Android3.0的版本号），默认就会启用ActionBar。 如果希望关闭ActionBar，则可以设置该应用的主题为Xxx.NoActionBar。在实际项目中，通常推荐使用代码控制ActionBar的显示、隐藏。ActionBar提供了如下方法来控制显示、隐藏。 show()：显示ActionBar hide()：隐藏ActionBar 下面是一个简单的实例，通过点击按钮实现显示或者隐藏：MainActivity.java源代码：123456789101112131415161718192021222324package com.example.actionbartest;import android.os.Bundle;import android.view.View;import androidx.appcompat.app.ActionBar;import androidx.appcompat.app.AppCompatActivity;public class MainActivity extends AppCompatActivity &#123; ActionBar actionBar; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); actionBar=getSupportActionBar(); &#125; public void showActionBar(View view) &#123; actionBar.show(); &#125; public void hideActionBar(View view) &#123; actionBar.hide(); &#125;&#125; ps：activity_main.xml比较简单就不给源代码了。在MainActivity.java中，尤其要注意MainActivity继承AppCompatActivity，使得actionBar对象必须通过getSupportActionBar()来实例化。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ActionBar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（二十一）]]></title>
    <url>%2F2018%2F08%2F05%2F8.5%2F</url>
    <content type="text"><![CDATA[安卓基础菜单Android应用中的菜单默认是看不见的，只有当用户按下手机上的“MENU”键时，系统才会显示该应用关联的菜单，这种菜单叫选项菜单（Option Menu）。从3.0系统开始，Android推荐ActionBar来代替菜单。 选项菜单和子菜单（SubMenu）Android系统的菜单支持主要通过4个接口来体现；Menu接口只是一个父接口，该接口下有如下两个接口。 SubMenu：它代表一个子菜单。可以包含1~N个MenuItem（形成菜单项） ContextMenu：它代表一个上下文菜单。可以包含1~N个MenuItem（形成菜单项） Android的不同菜单有如下特征： 选项菜单：选项菜单不支持勾选标记，并且只显示菜单的“浓缩（condensed）”标题 子菜单（SubMenu）：不支持菜单项图标，不支持嵌套子菜单 上下文菜单（ContextMenu）：不支持菜单快捷键和图标 Menu接口定义了如下方法来添加子菜单或菜单项 MenuItem add(int titleRes)：添加一个新的菜单项 MenuItem add(int groupId,int itemId,int order,int titleRes)：添加一个新的处于groupId组的菜单项 MenuItem add(int groupId,int itemId,int order,CharSequence title)：添加一个新的处于groupId组的菜单项 MenuItem add(CharSequence title)：添加一个新的菜单项 SubMenu addSubMenu(int titleRes)：添加一个新的子菜单 SubMenu addSubMenu(int groupId,int itemId,int order,int titleRes)：添加一个新的处于groupId组的子菜单 SubMenu addSubMenu(CharSequence title)：添加一个新的子菜单 SubMenu addSubMenu(int groupId,int itemId,int order,CharSequence title)：添加一个新的处于groupId组的子菜单 ps：add（）方法用于添加菜单项，addSubMenu（）方法用来添加子菜单 SubMenu继承了Menu，它就代表一个子菜单，额外提供了如下方法 SubMenu setHeaderIcon(Drawable icon)：设置菜单头的图标 SubMenu setHeaderIcon(int iconRes)：设置菜单头的图标 SubMenu setHeaderTitle(int titleRes)：设置菜单头的标题 SubMenu setHeaderTitle(CharSequence title)：设置菜单头的标题 SubMenu setHeaderView(View view)：使用View来设置菜单头 通过Menu、SubMenu、MenuItem来为Android应用添加菜单或子菜单。添加的步骤如下： 重写Activity中onCreateOptionsMenu(Menu menu)方法，在该方法里调用Menu对象的方法来添加菜单项或子菜单 如果希望应用程序能响应菜单项的单击事件，那么重写onOptionsItemSelected(MenuItem mi)方法即可。 下面给出一个为Android应用添加菜单和子菜单的例子的源码：activity_main.xml的源码： 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:gravity=&quot;center_horizontal&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;试试菜单项&quot;/&gt; &lt;EditText android:id=&quot;@+id/txt&quot; android:gravity=&quot;center_horizontal&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;输入测试文字&quot;/&gt;&lt;/LinearLayout&gt; MainActivity的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.example.menutest;import androidx.appcompat.app.AppCompatActivity;import android.graphics.Color;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.view.SubMenu;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; //定义“字体大小”的菜单项 final int FONT_10 = 0x111; final int FONT_12 = 0x112; final int FONT_14 = 0x113; final int FONT_16 = 0x114; final int FONT_18 = 0x115; //定义“恢复默认”的菜单项 final int PLAIN_ITEM = 0x11b; //定义“字体颜色”的菜单项 final int FONT_RED = 0x116; final int FONT_BLUE = 0x117; final int FONT_GREEN = 0x118; private EditText txt; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); txt = (EditText)findViewById(R.id.txt); &#125; @Override //当用户点击MENU键时触发该方法 public boolean onCreateOptionsMenu(Menu menu) &#123; //实例化一个菜单项对象 SubMenu fontMenu = menu.addSubMenu(&quot;字体大小&quot;); fontMenu.setIcon(R.drawable.ic_launcher_background); fontMenu.setHeaderIcon(R.drawable.ic_launcher_background); //设置菜单头的标题 fontMenu.setHeaderTitle(&quot;设置字体大小&quot;); //给菜单项添加子菜单 fontMenu.add(0,FONT_10,0,&quot;10号字体&quot;); fontMenu.add(0,FONT_12,0,&quot;12号字体&quot;); fontMenu.add(0,FONT_14,0,&quot;14号字体&quot;); fontMenu.add(0,FONT_16,0,&quot;16号字体&quot;); fontMenu.add(0,FONT_18,0,&quot;18号字体&quot;); //给menu添加一个菜单项 menu.addSubMenu(0,PLAIN_ITEM,0,&quot;恢复默认&quot;); SubMenu colorMenu = menu.addSubMenu(&quot;字体颜色&quot;); colorMenu.setIcon(R.drawable.ic_launcher_background); colorMenu.setHeaderIcon(R.drawable.ic_launcher_background); colorMenu.setHeaderTitle(&quot;设置字体颜色&quot;); colorMenu.add(0,FONT_RED,0,&quot;红色&quot;); colorMenu.add(0,FONT_BLUE,0,&quot;蓝色&quot;); colorMenu.add(0,FONT_GREEN,0,&quot;绿色&quot;); return super.onCreateOptionsMenu(menu); &#125; @Override //选项菜单的菜单项被单击后的回调方法 public boolean onOptionsItemSelected(MenuItem item) &#123; //判断单击的是哪个菜单项，并有针对性地做出响应 switch (item.getItemId())&#123; case FONT_10: txt.setTextSize(10*2); break; case FONT_12: txt.setTextSize(12*2); break; case FONT_14: txt.setTextSize(14*2); break; case FONT_16: txt.setTextSize(16*2); break; case FONT_18: txt.setTextSize(18*2); break; case FONT_RED: txt.setTextColor(Color.RED); break; case FONT_BLUE: txt.setTextColor(Color.BLUE); break; case FONT_GREEN: txt.setTextColor(Color.GREEN); break; case PLAIN_ITEM: Toast.makeText(MainActivity.this,&quot;您点击了恢复默认&quot;,Toast.LENGTH_SHORT).show(); txt.setTextColor(Color.BLACK); txt.setTextSize(18); break; &#125; return true; &#125;&#125; 使用监听器来监听菜单事件为菜单项绑定监听器的方法为： setOnMenuItemClickListener(MenuItem.OnMenuItemClickListener menuItemClickListener)：在这种方式下，我们可以采用简单的方法来添加菜单项，无须为每个菜单项指定ID。 不过这种方式要为每个菜单项绑定监听器，会是代码更加臃肿。 创建多选菜单项和单选菜单项调用如下方法实现： setCheckable(boolean checkable)：设置该菜单项是否可以被勾选，此方法使菜单项默认是多选菜单项 如果希望一组菜单里的菜单项都设为可勾选的菜单项，则可调用如下方法： setGroupCheckable(int group,boolean checkable,boolean exclusive)：设置group组里的所有菜单项是否可勾选；如果将exclusive设为true，那么他们就是一组单选菜单项 除此之外，Android还未MenuItem提供了如下方法来设置快捷键 setAlphabeticShortcut(char alphaChar)：设置字母快捷键 setNumericShortcut(char numericChar)：设置数字快捷键 setShortcut(char numericChar,char alphaChar)：同时设置两种快捷键 设置与菜单项关联的Activity有些时候，应用程序需要单击某个菜单项时启动其他Activity（包括其他Service）。对于这种需求，Android甚至不需要开发者编写任何事件处理代码，只要调用MenuItem的setIntent(Intent intent)方法即可——该方法将该菜单项与指定Intent关联在一起，当用户单击该菜单项时，该Intent所代表的组件将会被启动。 上下文菜单（ContextMenu）开发上下文菜单需要重写onCreateContextMenu(ContextMenu menu,View source,ContextMenu.ContextMenuInfo menuInfo)方法。其中source参数代表触发上下文菜单的组件。 开发上下文菜单的步骤如下： 重写Activity的onCreateContextMenu(ContextMenu menu,View source,ContextMenu.ContextMenuInfo menuInfo)方法 调用Activity的registerForContextMenu(View view)方法为view组件注册上下文菜单 如果希望应用程序能为菜单项提供响应，则可以重写onContextItemSelected(MenuItem mi)方法，或为指定菜单项绑定事件监听器 实例一个为一个TextView添加上下文菜单源码（长按View弹出菜单）：activity_main.xml: 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/txt&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!可通过上下文菜单修改背景色&quot; android:textSize=&quot;20sp&quot; android:background=&quot;@color/colorAccent&quot;/&gt;&lt;/LinearLayout&gt; MainActivity.java源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.example.contextmenutest;import androidx.appcompat.app.AppCompatActivity;import android.graphics.Color;import android.os.Bundle;import android.view.ContextMenu;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; final int MENU1 = 0x111; final int MENU2 = 0x112; final int MENU3 = 0x113; private TextView txt; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); txt = (TextView)findViewById(R.id.txt); registerForContextMenu(txt); &#125; @Override public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) &#123; menu.add(0,MENU1,0,&quot;红色&quot;); menu.add(0,MENU2,0,&quot;蓝色&quot;); menu.add(0,MENU3,0,&quot;绿色&quot;); menu.setGroupCheckable(0,true,true); menu.setHeaderIcon(R.mipmap.ic_launcher); menu.setHeaderTitle(&quot;选择背景色&quot;); &#125; @Override public boolean onContextItemSelected(MenuItem item) &#123; switch (item.getItemId())&#123; case MENU1: txt.setBackgroundColor(Color.RED); break; case MENU2: txt.setBackgroundColor(Color.BLUE); break; case MENU3: txt.setBackgroundColor(Color.GREEN); break; &#125; return true; &#125;&#125; 使用XML文件定义菜单Android提供了两种创建菜单的方式，一种是在Java代码中创建，一种是使用XML资源文件定义。在Java中定义菜单有如下不足： 在Java代码中定义菜单、菜单项，必然导致程序代码臃肿 需要程序员采用硬编码方式为每个菜单项分配ID，为每个菜单组分配ID，这种方式将导致应用可扩展性、可维护性降低。 使用XML资源文件来定义，这种方式可以提供更好的解耦。 菜单资源文件一般在res目录下新建的menu子目录，并在该子目录下提供menu_main.xml菜单资源文件。菜单资源的根元素通常是&lt;menu…/&gt;,&lt;menu…/&gt;元素无须指定任何属性。&lt;menu…/&gt;元素内可包含如下子元素。 &lt;item…/&gt;元素：定义菜单项 &lt;group…/&gt;子元素：将多个&lt;item…/&gt;定义的菜单项包装成一个菜单组 &lt;group…/&gt;子元素用于控制整租菜单的行为，该元素可指定如下常用属性。 checkableBehavior：指定该组菜单的选择行为。可指定为none（不可选）、all（多选）和single（单选）三个值 在程序中定义了资源文件后，接下来还是重写onCreateOptionsMenu(用于创建选项菜单)、onCreateContextMenu(用于创建上下文菜单)方法，在这些方法中调用MenuInflater对象的inflate方法加载指定资源对应的菜单即可。 下面的实例是将前面开发的菜单示例程序改为XML资源文件定义菜单。activity_main.xml源码： 123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;请输入测试文字!&quot; android:gravity=&quot;center_horizontal&quot; /&gt; &lt;EditText android:id=&quot;@+id/et&quot; android:gravity=&quot;center_horizontal&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;测试文字&quot;/&gt; &lt;TextView android:id=&quot;@+id/txt&quot; android:gravity=&quot;center_horizontal&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!可通过上下文菜单修改背景色&quot; android:textSize=&quot;20sp&quot; android:background=&quot;@color/colorAccent&quot;/&gt;&lt;/LinearLayout&gt; menu_main.xml源码（菜单项）： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:title=&quot;@string/font_size&quot;&gt; &lt;menu&gt; &lt;group android:checkableBehavior=&quot;single&quot;&gt; &lt;item android:title=&quot;@string/font_10&quot; android:id=&quot;@+id/font_10&quot;/&gt; &lt;item android:title=&quot;@string/font_12&quot; android:id=&quot;@+id/font_12&quot;/&gt; &lt;item android:title=&quot;@string/font_14&quot; android:id=&quot;@+id/font_14&quot;/&gt; &lt;item android:title=&quot;@string/font_16&quot; android:id=&quot;@+id/font_16&quot;/&gt; &lt;item android:title=&quot;@string/font_18&quot; android:id=&quot;@+id/font_18&quot;/&gt; &lt;/group&gt; &lt;/menu&gt; &lt;/item&gt; &lt;item android:title=&quot;@string/font_default&quot; android:id=&quot;@+id/font_default&quot;&gt; &lt;/item&gt; &lt;item android:id=&quot;@+id/font_color&quot; android:title=&quot;@string/font_color&quot;&gt; &lt;menu&gt; &lt;group android:checkableBehavior=&quot;single&quot;&gt; &lt;item android:id=&quot;@+id/red_font&quot; android:title=&quot;@string/red_font&quot;/&gt; &lt;item android:id=&quot;@+id/blue_font&quot; android:title=&quot;@string/blue_font&quot;/&gt; &lt;item android:id=&quot;@+id/green_font&quot; android:title=&quot;@string/green_font&quot;/&gt; &lt;/group&gt; &lt;/menu&gt; &lt;/item&gt;&lt;/menu&gt; context.xml源码（上下文菜单选项）： 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;group android:checkableBehavior=&quot;single&quot;&gt; &lt;item android:id=&quot;@+id/red&quot; android:title=&quot;@string/red&quot; android:alphabeticShortcut=&quot;r&quot;/&gt; &lt;item android:id=&quot;@+id/blue&quot; android:title=&quot;@string/blue&quot; android:alphabeticShortcut=&quot;b&quot;/&gt; &lt;item android:id=&quot;@+id/green&quot; android:title=&quot;@string/green&quot; android:alphabeticShortcut=&quot;g&quot;/&gt; &lt;/group&gt;&lt;/menu&gt; strings.xml资源文件： 1234567891011121314151617&lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;MenuResTest&lt;/string&gt; &lt;string name=&quot;font_size&quot;&gt;字体大小&lt;/string&gt; &lt;string name=&quot;font_default&quot;&gt;恢复默认&lt;/string&gt; &lt;string name=&quot;font_color&quot;&gt;字体颜色&lt;/string&gt; &lt;string name=&quot;font_10&quot;&gt;10号字体&lt;/string&gt; &lt;string name=&quot;font_12&quot;&gt;12号字体&lt;/string&gt; &lt;string name=&quot;font_14&quot;&gt;14号字体&lt;/string&gt; &lt;string name=&quot;font_16&quot;&gt;16号字体&lt;/string&gt; &lt;string name=&quot;font_18&quot;&gt;18号字体&lt;/string&gt; &lt;string name=&quot;red_font&quot;&gt;红色字体&lt;/string&gt; &lt;string name=&quot;blue_font&quot;&gt;蓝色字体&lt;/string&gt; &lt;string name=&quot;green_font&quot;&gt;绿色字体&lt;/string&gt; &lt;string name=&quot;red&quot;&gt;红色背景&lt;/string&gt; &lt;string name=&quot;blue&quot;&gt;蓝色背景&lt;/string&gt; &lt;string name=&quot;green&quot;&gt;绿色背景&lt;/string&gt;&lt;/resources&gt; MainActivity.java源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.example.menurestest;import androidx.appcompat.app.AppCompatActivity;import android.graphics.Color;import android.os.Bundle;import android.view.ContextMenu;import android.view.Menu;import android.view.MenuInflater;import android.view.MenuItem;import android.view.View;import android.widget.EditText;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; private TextView txt; private EditText et; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); et = (EditText)findViewById(R.id.et); txt = (TextView)findViewById(R.id.txt); registerForContextMenu(txt); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; MenuInflater inflater = new MenuInflater(this); inflater.inflate(R.menu.menu_main,menu); return super.onCreateOptionsMenu(menu); &#125; @Override public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) &#123; MenuInflater inflater = new MenuInflater(this); inflater.inflate(R.menu.context,menu); menu.setHeaderTitle(&quot;选择背景色&quot;); menu.setHeaderIcon(R.mipmap.ic_launcher); &#125; @Override public boolean onContextItemSelected(MenuItem item) &#123; item.setChecked(true); switch (item.getItemId())&#123; case R.id.red: txt.setBackgroundColor(Color.RED); break; case R.id.blue: txt.setBackgroundColor(Color.BLUE); break; case R.id.green: txt.setBackgroundColor(Color.GREEN); break; &#125; return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; if (item.isCheckable())&#123; item.setChecked(false); &#125; switch (item.getItemId())&#123; case R.id.font_10: item.setChecked(true); et.setTextSize(10*2); break; case R.id.font_12: item.setChecked(true); et.setTextSize(12*2); break; case R.id.font_14: item.setChecked(true); et.setTextSize(14*2); break; case R.id.font_16: item.setChecked(true); et.setTextSize(16*2); break; case R.id.font_18: item.setChecked(true); et.setTextSize(18*2); break; case R.id.red_font: item.setChecked(true); et.setTextColor(Color.RED); break; case R.id.blue_font: item.setChecked(true); et.setTextColor(Color.BLUE); break; case R.id.green_font: item.setChecked(true); et.setTextColor(Color.GREEN); break; case R.id.font_default: et.setTextColor(Color.BLACK); et.setTextSize(18); break; &#125; return true; &#125;&#125; 使用XML资源文件定义菜单有如下两个好处： XML资源文件不仅负责定义应用界面，也负责定义菜单，这样可把所有界面相关的内容交给XML文件管理，而Java代码的功能更集中。 后期更新、维护应用时，如果需要更新、维护菜单，打开、编辑XML文件即可，避免对Java文件的修改。 使用PopupMenu创建弹出式菜单PopupMenu代表弹出式菜单，它会在指定组件上弹出PopupMenu，在默认情况下，PopupMenu会显示在该组件的下方或者上方。PopupMenu可增加多个菜单项，并可为菜单项增加子菜单。 使用PopupMenu创建菜单的步骤如下： 调用new PopupMenu(Context context,View anchor)创建下拉菜单，anchor代表要激发该弹出菜单的组件。 调用MenuInflater的inflate()方法将菜单资源填充到PopupMenu中。 调用PopupMenu的show()方法显示弹出式菜单。 下面给出一个Button的PopupMenu的源码：activity_main.xml的源码： 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center_horizontal&quot; tools:context=&quot;.MainActivity&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;onPopupButtonClick&quot; android:text=&quot;点击试试&quot;/&gt;&lt;/LinearLayout&gt; menu文件夹中的popup_menu.xml资源文件源码： 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;item android:title=&quot;@string/query&quot; android:id=&quot;@+id/query&quot;/&gt; &lt;item android:title=&quot;@string/add&quot; android:id=&quot;@+id/add&quot;/&gt; &lt;item android:title=&quot;@string/edit&quot; android:id=&quot;@+id/edit&quot;/&gt; &lt;item android:title=&quot;@string/hide&quot; android:id=&quot;@+id/hide&quot;/&gt;&lt;/menu&gt; strings.xml资源文件源码： 1234567&lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;PopupMenuTest&lt;/string&gt; &lt;string name=&quot;query&quot;&gt;查找&lt;/string&gt; &lt;string name=&quot;add&quot;&gt;添加&lt;/string&gt; &lt;string name=&quot;edit&quot;&gt;编辑&lt;/string&gt; &lt;string name=&quot;hide&quot;&gt;隐藏菜单&lt;/string&gt;&lt;/resources&gt; MainActivity.java源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.example.popupmenutest;import androidx.appcompat.app.AppCompatActivity;import android.app.Activity;import android.os.Bundle;import android.view.MenuItem;import android.view.View;import android.widget.PopupMenu;import android.widget.Toast;public class MainActivity extends Activity &#123; PopupMenu popup = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void onPopupButtonClick(View view) &#123; //创建PopupMenu对象 popup = new PopupMenu(this,view); //将R.menu.popup_menu.xml菜单资源加载到popup菜单中 getMenuInflater().inflate(R.menu.popup_menu,popup.getMenu()); //为popup菜单的菜单项单击事件绑定事件监听器 popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() &#123; @Override public boolean onMenuItemClick(MenuItem menuItem) &#123; switch (menuItem.getItemId())&#123; case R.id.query: Toast.makeText(MainActivity.this,&quot;你点击了&quot;+menuItem.getTitle()+&quot;菜单项&quot;,Toast.LENGTH_SHORT).show(); break; case R.id.hide: //隐藏该对话框 popup.dismiss(); Toast.makeText(MainActivity.this,&quot;你点击了&quot;+menuItem.getTitle()+&quot;菜单项&quot;,Toast.LENGTH_SHORT).show(); break; case R.id.add: Toast.makeText(MainActivity.this,&quot;你点击了&quot;+menuItem.getTitle()+&quot;菜单项&quot;,Toast.LENGTH_SHORT).show(); break; case R.id.edit: Toast.makeText(MainActivity.this,&quot;你点击了&quot;+menuItem.getTitle()+&quot;菜单项&quot;,Toast.LENGTH_SHORT).show(); break; &#125; return true; &#125; &#125;); popup.show(); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>SubMenu</tag>
        <tag>ContextMenu</tag>
        <tag>PopupMenu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（二十）]]></title>
    <url>%2F2018%2F08%2F04%2F8.4.1%2F</url>
    <content type="text"><![CDATA[安卓基础对话框Android有如下4种常用的对话框： AlertDialog：功能丰富、最实际的对话框 ProgressDialog：进度对话框，这个对话框只是对进度条的包装 DatePickerDialog:日期选择对话框，这个对话框只是对DatePicker的包装 TimePickerDialog:时间选择对话框，这个对话框只是对TimePicker的包装 使用AlertDialog创建对话框AlertDialog生成的对话框有4部分： 图标区 标题区 内容区 按钮区 从对话框的结构来看，有下列几步创建对话框： 创建AlerDialog.Builder对象 调用AlertDialog.Builder的setTitle()或setCustomTitle()方法设置标题 调用AlertDialog.Builder的setIcon()方法设置图标 调用AlertDialog.Builder的相关设置方法设置对话框内容 调用AlertDialog.Builder的setPositiveButton()、setNegativeButton()、setNeutralButton()方法添加多个按钮 调用AlertDialog.Builder的creat()方法创建AlertDialog对象，再调用AlertDialog对象的show()方法将该对话框显示出来 其中第4步是最灵活的，AlertDialog允许创建各种内容的对话框。AlertDialog提供了如下6中方法来指定对话框的内容。 setMessage()：设置对话框内容为简单文本 setItems()：设置对话框内容为简单列表项 setSingleChoiceItems()：设置对话框内容为单选列表项 setMultiChoiceItems()：设置对话框内容为多选列表项 setAdapter()：设置对话框内容为自定义列表项 setView()：设置对话框内容为自定义的View ps： 调用setSingleChoiceItems()方法时既可以传入数组作为参数，也可传入Cursor（相当于数据库查询结果集）作为参数，还可传入ListAdapter作为参数。如果传入ListAdapter作为参数，则由ListAdapter来提供多个列表项组件。 调用setMultiChoiceItems()方法添加多选列表项时，需要传入一个boolean[]参数，该参数有两个作用：①设置初始化时选中哪些列表项；②该boolean[]类型的参数还可用于动态地获取多选列表中列表项的选中状态。 setAdapter()方法需要传入一个Adapter参数 setView()方法可以接受一个View组件，通过这种方式，开发者可以定制对话框的内容因为在Android界面编程中，一切都是View。 如下是使用setView()方法的实例：activity_main.xml文件代码： 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;自定义View对话框&quot; android:onClick=&quot;ViewBtn&quot;/&gt;&lt;/LinearLayout&gt; MainActivity.java代码： 1234567891011121314151617181920212223242526public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void ViewBtn(View view) &#123; LinearLayout login = (LinearLayout)getLayoutInflater().inflate(R.layout.layout,null); new AlertDialog.Builder(this).setIcon(R.mipmap.ic_launcher) .setTitle(&quot;乱写一通&quot;) .setView(login) .setPositiveButton(&quot;是个瓜皮&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; Toast.makeText(MainActivity.this,&quot;是个瓜娃子&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;).setNegativeButton(&quot;dsaf&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; Toast.makeText(MainActivity.this,&quot;sdfadfas&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;).create().show(); &#125;&#125; 新建的一个layout代码（提供一个View）： 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:id=&quot;@+id/login&quot;&gt; &lt;TextView android:layout_gravity=&quot;center_horizontal&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;asdfafdsadfsafdsfd&quot;/&gt; &lt;EditText android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;adsfasdfafdasfasfdsaf&quot; /&gt;&lt;/LinearLayout&gt; 对话框风格的窗口只是把显示窗口的Activity的风格设为对话框风格。 使用PopupWindow只用如下两步创建对话框风格的窗口： 调用PopupWindow的构造器创建PopupWindow对象 调用PopupWindow的showAsDropDown(View v)将PopupWindow作为v组件的下拉组件显示出来；或者调用PopupWindow的showAtLocation()方法将PopupWindow在指定位置显示出来 PopupWindow.dismiss()方法用来销毁，隐藏PopupWindow对象。 使用DatePickerDialog、TimePickerDialogDatePickerDialog和TimePickerDialog的用法需要下面两步： 通过new关键词创建DatePickerDialog、TimePickerDialog实例，调用它们的show()方法即可将日期选择对话框、时间选择对话框显示出来。 为DatePickerDialog和TimePickerDialog绑定监听器，这样可以保证用户通过DatePickerDialog和TimePickerDialog设置时间时触发监听器，从而通过监听器获得用户设置的时间。 使用ProgressDialog创建进度对话框ProgressDialog代表了进度对话框，程序只要创建ProgressDialog实例，并将它显示出来就是一个进度对话框。使用ProgressDialog创建进度对话框有如下两种方式。 如果只是创建简单的进度对话框，那么调用ProgressDialog提供的静态方法show()方法显示对话框即可 创建ProgressDialog，然后调用方法对话框里的进度条进行设置，设置完成后将对话框显示出来即可 为了对进度对话框里的进度条进行设置，ProgressDialog包含了如下常用的方法： setIndeterminate(boolean indeterminate)：设置对话框里的进度条不显示进度值 setMax(int max)：设置对话框里进度条的最大值 setMessage(CharSequence message)：设置对话框里显示的消息 setProgress(int value)：设置对话框里进度条的进度值 setProgressStyle(int style)：设置对话框里进度条的风格 ps:下面给出三种进度对话框源代码：activity_main.xml源代码： 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;环形进度条&quot; android:onClick=&quot;showSpinner&quot;/&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;不显示进度的进度条&quot; android:onClick=&quot;showIndeterminate&quot;/&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;显示进度的进度条&quot; android:onClick=&quot;showProgress&quot;/&gt;&lt;/LinearLayout&gt; MainActivity.java源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class MainActivity extends AppCompatActivity &#123; final static int MAX_PROGRESS = 100; private int[] data =new int[50]; int progressStatus =0; int hasData =0; ProgressDialog pd1,pd2; //定义负责更新进度的Handler Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; //表明消息是由程序发送的 if (msg.what==0x123)&#123; pd2.setProgress(progressStatus); &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void showSpinner(View view) &#123; //调用静态方法显示环形进度条 ProgressDialog.show(this,&quot;任务执行中&quot;,&quot;等一哈&quot;,false,true); &#125; public void showIndeterminate(View view) &#123; pd1 = new ProgressDialog(MainActivity.this); pd1.setTitle(&quot;任务执行中&quot;); //设置对话框显示的neir pd1.setMessage(&quot;还未完成，请等待&quot;); //设置对话框能用“返回”按钮关闭 pd1.setCancelable(true); //设置对话框的进度条风格 pd1.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL); //设置对话框的进度条是否显示进度；true表示不显示进度 pd1.setIndeterminate(true); pd1.show(); &#125; public void showProgress(View view) &#123; progressStatus = 0; hasData = 0; pd2 = new ProgressDialog(MainActivity.this); pd2.setMax(MAX_PROGRESS); pd2.setTitle(&quot;任务完成百分比&quot;); pd2.setMessage(&quot;耗时完成任务百分比&quot;); //设置对话框不能用“返回”按钮关闭 pd2.setCancelable(false); pd2.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL); //设置对话框的进度条是否显示进度；true表示不显示进度 pd2.setIndeterminate(false); pd2.show(); new Thread()&#123; @Override public void run() &#123; while (progressStatus &lt; MAX_PROGRESS)&#123; //获取耗时操作完成的百分比 progressStatus = MAX_PROGRESS * doWork() /data.length; handler.sendEmptyMessage(0x123); &#125; //如果任务完成 if (progressStatus&gt;= MAX_PROGRESS)&#123; //关闭对话框 pd2.dismiss(); &#125; &#125; &#125;.start(); &#125; private int doWork() &#123; //为数组元素赋值 data[hasData++] = (int)(Math.random()*100); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //返回数组的“第几” return hasData; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>AlertDialog</tag>
        <tag>PopupWindow</tag>
        <tag>DatePickerDialog</tag>
        <tag>TimePickerDialog</tag>
        <tag>ProgressDialog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（十九）]]></title>
    <url>%2F2018%2F08%2F04%2F8.4%2F</url>
    <content type="text"><![CDATA[安卓基础Notification的功能和用法Notification是显示在手机状态栏的通知。Notification所代表的是一种具有全局效果的通知，程序一般通过NotificationManager服务发送Notification。应用可通过NotificationManager向系统全局发送通知。 Android为Notification增加了Notification.Builder类，通过该类允许开发者更轻松地创建Notification对象。Notification.Builder提供了如下常用方法。 setDefaults()：设置通知LED灯、音乐、振动等 setAutoCancel()：设置点击通知后，状态栏自动删除通知 setContentTitle()：设置通知标题 setContentText()：设置通知内容 setSmallcon()：为通知设置图标 setLargelcon()：为通知设置大图标 setTick()：设置通知在状态栏的提示文本 setContentlntent()：设置点击通知后将要启动的程序组件对应的PendingIntent。 发送Notification有如下步骤： 调用getSystemService(NOTIFICATION_SERVICE)方法获取系统的NotificationManager服务。 通过构造器创建一个Notification对象 为Notification设置各种属性 通过NotificationManager发送Notification 下面是一个简单的通知实例：MainActivity.java中代码: 12345678910111213141516171819202122232425262728293031323334public class MainActivity extends AppCompatActivity &#123; static final int NOTIFICATION_ID = 0x123; NotificationManager nm; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); nm = (NotificationManager)getSystemService(NOTIFICATION_SERVICE); &#125; public void send(View view) &#123; Intent intent = new Intent(MainActivity.this,OtherActivity.class); PendingIntent pi =PendingIntent.getActivity(MainActivity.this,0,intent,0); //下面方法中的setDefaults()中有三种参数Notification.DEFAULT_SOUNDS,DEFAULT_VIBRATE,DEFAULT_LIGHTS。 // DEFAULT_ALL表示三个都默认。如果只是选择其中两个参数用 \ 符号连接。 Notification notification = new Notification.Builder(this) .setAutoCancel(true).setTicker(&quot;新消息&quot;) .setSmallIcon(R.mipmap.ic_launcher) .setContentTitle(&quot;一条新通知&quot;) .setContentText(&quot;您中奖了！&quot;) .setDefaults(Notification.DEFAULT_ALL) .setWhen(System.currentTimeMillis()) .setContentIntent(pi) .build(); //发送通知 nm.notify(NOTIFICATION_ID,notification); &#125; public void del(View view) &#123; //取消通知 nm.cancel(NOTIFICATION_ID); &#125;&#125; activity_main.xml中的代码： 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:id=&quot;@+id/send&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;发送&quot; android:onClick=&quot;send&quot;/&gt; &lt;Button android:id=&quot;@+id/del&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;取消&quot; android:onClick=&quot;del&quot;/&gt;&lt;/LinearLayout&gt; AndroidManifest.xml文件中代码： 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.notification&quot;&gt; &lt;!--添加操作闪光灯的权限--&gt; &lt;uses-permission android:name=&quot;android.permission.FLASHLIGHT&quot;/&gt; &lt;!--添加手机振动的权限--&gt; &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot;/&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!--声明新建的Activity，此Activity必须继承AppCompatActivity--&gt; &lt;activity android:name=&quot;.OtherActivity&quot;/&gt; &lt;/application&gt;&lt;/manifest&gt; PendingIntent详解Intent是一个意图，一个描述了想要启动一个Activity、Broadcast或是Service的意图。它主要持有的信息是它想要启动的组件（Activity、Broadcast或是Service），在开发操作中，需要通过 startActivity，startService 或sendBroadcast 方法来启动这个意图执行某些操作！！ PendingIntent可以认为是对Intent的包装，实际上就是，供当前App或之外的其他App调用，而常见的是供外部App使用，外部App执行这个PendingIntent时，间接地调用里面的Intent,即外部App延时执行PendingIntent中描述的Intent及其最终行为,PendingIntent主要持有的信息是它所包装的Intent和当前AppContext，即使当前App已经不存在了，也能通过存在于PendingIntent里的Context来执行Intent。当你把PendingIntent递交给别的程序进行处理时,PendingIntent仍然拥有PendingIntent原程序所拥有的权限，当你从系统取得一个PendingIntent时，一定要非常小心才行，比如，通常，如果Intent目的地是你自己的component（Activity/Service/BroadcastReceiver）的话，你最好采用在Intent中显示指定目的component名字的方式，以确保Intent最终能发到目的，否则Intent最后可能不知道发到哪里了。 可以这样理解：当你想在A activity中启动另一个B activity,那么你可以选择两种情况[立即启动或延时启动]： 通过intent配置需要启动的B activity，然后调用startActivity()方法，让他立即执行启动操作，跳转过去 另一种情况是，你虽然想启动另一个B activity，可是你并不想马上跳转到Bactivity页面，你想静等5分钟之后再跳转到Bactivity，那么你可以通过PendingIntent来实现[当然实现方式有很多啦，这里仅是想说明PendingIntent与intent的区别]，PendingIntent可以包装第1步中的intent，然后通过AlarmManager这个定时器，定制5分钟之后启PendingIntent，实现这种延时操作，如果你还是听着似懂非懂，一头雾水，我表示很有压力了，我该怎么说你才能清楚呢，理论终究是抽象的，后见将会通过一个程序说明一下，程序中是启动一个BroadcastReceiver，其实原理都是一样的！！ 如何获得一个PendingIntent呢？其实很简单： 你可以通过getActivity(Context context, int requestCode, Intent intent, int flags)系列方法从系统取得一个用于启动一个Activity的PendingIntent对象 可以通过getService(Context context, int requestCode, Intent intent, int flags)方法从系统取得一个用于启动一个Service的PendingIntent对象 可以通过getBroadcast(Context context, int requestCode, Intent intent, int flags)方法从系统取得一个用于向BroadcastReceiver的发送广播的PendingIntent对象 PendingIntent几个常量： FLAG_CANCEL_CURRENT：如果AlarmManager管理的PendingIntent已经存在，那么将会取消当前的PendingIntent，从而创建一个新的PendingIntent FLAG_UPDATE_CURRENT：如果AlarmManager管理的PendingIntent已经存在，可以让新的Intent更新之前PendingIntent中的Intent对象数据，例如更新Intent中的Extras，另外，我们也可以在PendingIntent的原进程中调用PendingIntent的cancel ()把其从系统中移除掉 FLAG_NO_CREATE：如果AlarmManager管理的PendingIntent已经存在，那么将不进行任何操作，直接返回已经存在的PendingIntent，如果PendingIntent不存在了，那么返回null]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Notification</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（十八）]]></title>
    <url>%2F2018%2F08%2F02%2F8.2%2F</url>
    <content type="text"><![CDATA[安卓基础滚动视图（ScrollView）的功能和用法ScrollView由FrameLayout派生而出，他就是一个用于为普通组件添加滚动条的组件。ScrollView里最多只能包含一个组件，而ScrollView的作用就是为该组件添加垂直滚动条。ScrollView的作用和Swing编程中的JScrollPane十分相似，它们甚至不能被称为真正的容器，它们只是为其他容器添加滚动条。如果应用需要添加水平滚动条，则可借助于另一个滚动视图——HorizontalScrollView来实现。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ScrollView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（十七）]]></title>
    <url>%2F2018%2F08%2F01%2F8.1%2F</url>
    <content type="text"><![CDATA[安卓基础选项卡（TabHost）的功能和用法TabHost是一种非常实用的组件，TabHost可以很方便地在窗口上放置多个标签，每个标签页相当于获得了一个与外部容器相同大小的组件摆放区域。通过这种方式，就可以在一个容器里放置更多组件。 与TabHost结合使用的还有如下组件： TabWidget：代表选项卡的标题条 TabSpec：代表选项卡的一个Tab页面。TabHost仅仅是一个简单的容器，它提供了如下两个方法来创建、添加标签页 newTabSpec(String tag)：创建选项卡 addTab(TabHost.TabSpec tabSpec)：添加选项卡 使用TabHost的一般步骤如下： 在界面布局文件中定义TabHost组件，并为该组件定义该选项卡的内容 Activity应该继承TabActivity 通过TabActivity的getTabHost（）方法获取TabHost对象 通过TabHost对象的方法来创建、添加选项卡 ps：布局文件中的ID有如下要求： TabHost的ID是@android:id/tabhost TabWidget的ID应该为@android:id/tabs FrameLayout的ID应该为@android:id/tabcontent 上面这三个ID并不是开发者自己定义的，而是引用了Android系统已有的ID。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>TabHost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（十六）]]></title>
    <url>%2F2018%2F07%2F31%2F7.31%2F</url>
    <content type="text"><![CDATA[安卓基础日期、时间选择器（DatePicker和TimePicker）的功能和用法DatePicker和TimePicker是两个比较易用的组件，它们都是从FrameLayout派生而来；DatePicker用来选择日期，TimePicker用来选择时间。 如果程序需要获取用户选择的日期、时间，则可通过为DatePicker添加OnDateChangedListener进行监听、为TimePicker添加OnTimeChangeListener进行监听来实现。 使用DatePicker时可指定XML属性如下： android:calendarViewShown：设置该日期选择器是否显示CalendarView组件 android:endYear：设置日期选择器允许选择的最后一年 android:maxDate：设置该日期选择器支持的最大日期。以mm/dd/yyyy格式指定最大日期 andorid:minDate：设置该日期选择器支持的最小日期。以mm/dd/yyyy格式指定最大日期 android:spinnerShown：设置该日期选择器是否显示Spinner日期选择组件 android:startYear：设置日期选择器允许选择的第一年 NumberPicker数值选择器的功能和用法数值选择器用于让用户输入数值，用户既可以通过键盘输入数值，也可以通过拖动来选择数值，使用该组件常用如下三个方法： setMinValue(int minVal)：设置该组件支持的最小值 setMaxValue(int maxVal)：设置该组件支持的最大值 setValue(int value)：设置该组件的当前值 搜索框（SearchView）的功能和用法SearchView是搜索框组件，它可以让用户在文本框内输入文字，并允许通过监听器监控用户输入，当用户输入完成后提交搜索时，也可通过监听器执行实际的搜索。 setIconifiedByDefault(boolean iconified):设置该搜索框默认是否自动缩小为图标 setSubmitButtonEnabled(boolean enabled)：设置是否显示搜索按钮 setQueryHint(CharSequence hint)：设置搜索框内默认显示的提示文本 setOnQueryTextListener(SearchView.OnQueryTextListener listener)：为该搜索框设置事件监听器]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>DatePicker</tag>
        <tag>TimePicker</tag>
        <tag>NumberPicker</tag>
        <tag>SearchView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（十五）]]></title>
    <url>%2F2018%2F07%2F30%2F7.30%2F</url>
    <content type="text"><![CDATA[安卓基础昨天未解决问题的补充解决在XML布局Layout文件中，如果要为当前组件添加一个点击事件，使用android:onClick=”….”方法时，需要在MainActivity中生成。使用Alt+Enter，直接生成，避免无法关联？因为又可能会无法关联上，产生Could not find method next(View) in a parent or ancestor Context for android错误。 ViewFlipper的功能与用法ViewFlipper组件继承了ViewAnimator，它可调用addView(View v)添加多个组件。可以使用动画控制多个组件之间的切换效果。 ViewFlipper与前面的AdapterViewFlipper有较大相似性，它们可以控制组件切换的动画效果。它们的区别是：ViewFlipper需要开发者通过addView(View v)方法添加多个View，而AdapterViewFlipper则只要传入一个Adaper，Adapter将会负责提供多个View。ViewFlipper可以指定与AdapterViewFlipper相同的XML属性。 使用Toast显示提示信息Toast有两个特点：Toast提示信息不会获得焦点；提示信息过一段时间会自动消失。 使用Toast的步骤： 调用Toast的构造器或makeText()静态方法创建一个Toast对象 调用Toast的方法来设置该消息提示的对齐方式、页边距等 调用Toast的show()方法将它显示出来 Toast的功能和用法都比较简单，大部分时候它只能显示简单的文本提示；如果应用需要显示诸如图片、列表之类的复杂提示，一般建议使用对话框来完成；如果开发者确实想通过Toast来完成，也是可以的，此时就需要调用Toast构造器创建实例，再调用setView()方法设置该Toast显示的View组件。此方法允许开发者自己定义Toast显示的内容。 日历视图（CalendarView）组件的功能和用法日历视图可用于显示和选择日期，用户既可以选择一个日期，也可通过触摸来滚动日历。如果希望监控该组件的日期改变，则可调用CalendarView的setOnDateChangeListener()方法为此组件的点击事件添加事件监听器。 使用CalendarView时常见的XML属性： android:dateTextAppearance：设置该日历视图的日期文字的样式 android:firstDayOfWeek：设置每周的第一天，允许设置周一到周日任意一天作为每周的第一天 android:focusedMonthDateColor：设置获得焦点的月份的日期文字的颜色 android:maxDate：设置日历组件支持的最大日期。以mm/dd/yyyy格式指定最大日期 android:minDate：设置该日历组件支持的最小日期。同上设置 android:selectedDateVerticalBar：设置绘制在选中日期两边的竖线对应的Drawable android:selectedWeekBackgroundColor：设置被选中周的背景色 android:showWeekNumber：设置是否显示第几周 android:shownWeekCount：设置该日历组件总共显示几个星期 android:unfocusedMonthDateColor：设置没有焦点的月份的日期文字的颜色 android:weekDayTextAppearance：设置星期几的文字样式 android:weekNumberColor：设置显示周编号的颜色 android:weekSeparatorLineColor：设置周分割线的颜色]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ViewFlipper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（十四）]]></title>
    <url>%2F2018%2F07%2F29%2F7.29%2F</url>
    <content type="text"><![CDATA[安卓基础ViewAnimator及其子类ViewAnimator继承了FrameLayout，因此它表现出FrameLayout的特征，可以将多个View组件叠在一起，ViewAnimator可以在View切换时表现出动画效果。 ViewAnimator的XML属性如下： android:animateFirstView：设置ViewAnimator显示第一个View组件时是否使用动画 android:inAnimation：设置ViewAnimator显示组件时所使用的动画 android:outAnimation：设置ViewAnimator隐藏组件时所使用的动画 ViewSwitcher的功能及用法ViewSwitcher代表了视图切换组件，因此可以将多个View层叠在一起，每次只显示一个组件。当程序控制从一个View切换到另一个View时，ViewSwitcher支持指定动画效果。 为了给ViewSwitcher添加多个组件，一般通过调用ViewSwitcher的setFactory(ViewSwitcher.ViewFactory)方法为之设置ViewFactory，并由该ViewFactory为之创建View即可。 图像切换器（ImageSwitcher）的功能和用法ImageSwitcher继承了ViewSwitcher，并重写了ViewSwitcher的showNext()和showPrevious()方法，因此ImageSwitcher使用起来更简单。使用ImageSwitcher只需如下两步： 为ImageSwitcher提供一个ViewFactory，该ViewFactory生成的View组件必须是ImageView。 需要切换图片时，只要调用ImageSwitcher的setImageDrawable(Drawable drawable)、setImageResource(int resid)和setImageURI(Uri uri)方法切换图片。 ImageSwitcher效果更炫，他可以指定图片切换时的动画效果。 文本切换器（TextSwitcher）的功能和用法TextSwitcher继承了ViewSwitcher，因此它具有与ViewSwitcher相同的特征：可以在在切换View组件时使用动画效果。它也需要设置一个ViewFactory，它的ViewFactory的makeView()方法必须返回一个TextView组件。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ViewSwitcher</tag>
        <tag>ImageSwitcher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（十三）]]></title>
    <url>%2F2018%2F07%2F28%2F7.28%2F</url>
    <content type="text"><![CDATA[安卓基础拖动条（SeekBar）的功能与用法SeekBar继承了ProgressBar，因此ProgressBar所支持的XML属性和方法完全适用于SeekBar。 SeekBar允许用户改变拖动条的滑块外观，改变滑块外观通过如下属性来指定。 android：thumb：指定一个Drawable对象，该对象将作为自定义滑块。 为了让程序响应滑块位置的改变，程序可以考虑为他绑定一个OnSeekBarChangeListener监听器。 星级评分条（RatingBar）的功能和用法星级评分条和拖动条有相同的父类：AbsSeekBar，因此它们相似；它们的区别就是RatingBar通过星星来表示进度。 下面是RatingBar所支持的常见XML属性： android:isIndicator：设置该星级评分条是否允许用户改变（true为不允许修改） android:numStars：设置该星级评分条总共有多少个星级 android:rating：设置该星级评分条默认的星级 android:stepSize：设置每次最少需要改变多少个星级 为了让程序能响应星级评分条评分的改变，可以考虑为它绑定一个OnRatingBarChangeListener监听器。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>SeekBar</tag>
        <tag>RatingBar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（十二）]]></title>
    <url>%2F2018%2F07%2F27%2F7.27%2F</url>
    <content type="text"><![CDATA[安卓基础ProgressBar及其子类ProgressBar本身代表了进度条组件，它还派生出了两个常用组件:SeekBar和RatingBar。ProgressBar及其子类在用法上十分相似，只是显示有一定的区别。（主要是用来动态地显示进度，提高用户界面的友好性） Android支持多种风格的进度条，通过style属性可以为ProgressBar指定风格。该属性可支持如下几个属性值： @android:style/Widget.ProgressBar.Horizontal：水平进度条 @android:style/Widget.ProgressBar.Inverse：普通大小的环形进度条 @android:style/Widget.ProgressBar.Large：大环形进度条 @android:style/Widget.ProgressBar.Large.Inverse：大环形进度条 @android:style/Widget.ProgressBar.Small：小环形进度条 @android:style/Widget.ProgressBar.Small.Inverse：小环形进度条 ProgressBar支持的XML属性： android:max：设置该进度条的最大值 android:progress：设置该进度条的已完成进度值 android:progressDrawable：设置该进度条对应的Drawable对象 android:indeterminate：该属性设为true，设置进度条不精确显示进度 android:indeterminateDrawable：设置绘制不显示进度条的Drawable对象 android:indeterminateDuration：设置不精确显示进度的持续时间 ProgressBar提供了如下方法来操作进度 setProgress（int）：设置进度的完成百分比 incrementProgressBy（int）：设置进度条的进度增加或减小。当参数为正数时进度增加，为负数时进度减小。 ps：Handler用来发送信息，当msg.what==0x111表示消息是由该程序发送的。math.random()函数是取从0至1之间的随机数,乘100以后就是取0到100之间的随机数 显示在标题上的进度条有一种进度条，可以直接在窗口标题上显示，这种进度条甚至不需要使用ProgressBar组件，它是直接由Activity的方法启用的。为了在窗口标题上显示进度条，需要经过下列两步： 调用Activity的requestWindowFeature（）方法，该方法根据传入的参数可启用特定的窗口特征。例如：传入Window.FEATURE_INDETERMINATE_PROGRESS在窗口标题上显示不带进度的进度条；传入Window.FEATURE_PROGRESS则显示带进度的进度条。 调用Activity的setProgressBarVisibility(boolean)或setProgressBarIndeterminate Visibility(boolean)方法即可控制进度条的显示和隐藏。 ps：Android5.0默认的主题：Material看不到标题上的进度条；因此要显示标题上的进度条需要将该应用主题设置为Holo。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ProgressBar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（十一）]]></title>
    <url>%2F2018%2F07%2F26%2F7.26%2F</url>
    <content type="text"><![CDATA[安卓基础Spinner的功能和用法Spinner就是一个列表选择框，相当于弹出一个菜单供用户选择。Spinner与Gallery都继承了AbsSpinner，AbsSpinner继承了AdapterView。因此它也表现出AdapterView的特征：只要为AdapterView提供Adapter即可。Spinner支持的常用XML属性及相关方法如下： android:entries：使用数组资源设置该下拉列表框的列表项 android:dropDownHorizontalOffest：设置列表选择框的水平偏移距 android:dropDownVerticalOffest：设置列表选择框的垂直偏移距 android:dropDownWidth：设置列表选择框的宽度 android:popupBackground：设置列表选择框的背景色 android:prompt：设置该列表选择框的提示信息 android：entries属性不是Spinner定义的，而是在AbsSpinner中定义的，因此Gallery也支持该XML属性。 如果开发者在使用Spinner时已经确定了列表选择框里的列表项，只要为Spinner指定android:entries属性即可；如果程序需要在运行时动态地决定Spinner的列表项，或者程序需要对Spinner的列表项进行定制，则可使用Adapter为Spinner提供列表项。 Spinner与Gallery都继承了AbsSpinner，表明Gallery和Spinner都是一个列表选择框。它们的区别是在于，Spinner显示的是一个垂直的列表选择框，而Gallery显示的是一个水平的列表选择框；Spinner的作用是供用户选择，而Gallery则允许用户通过拖动来查看上一个、下一个列表项。如果程序需要监控到Gallery选择项的改变，通过为Gallery添加OnItemSelectedListener监听器即可实现。 Android现在已经不推荐使用Gallery，而是用HorizontalScrollView和ViewPager来代替Gallery组件。 AdapterViewFlipper的功能与用法AdapterViewFlipper继承了AdapterViewAnimator，它也会显示Adapter提供的多个View组件，但它每次只能显示一个View组件，可通过showPrevious()和showNext()方法控制该组件显示上一个、下一个组件。 AdapterViewFilpper可以在多个View切换过程中使用渐隐渐显的动画效果。除此之外，还可以调用该组件的startFlippering()控制它“自动播放”下一个View组件。 AdapterViewAnimator支持的XML属性如下： android:animateFirstView：设置显示该组件的第一个View时是否使用动画 android:inAnimation：设置组件显示时使用的动画 android:loopViews：设置循环到最后一个组件后是否自动“转头”到第一个组件 android:outAnimation：设置组件隐藏时使用的动画 AdapterViewFilpper额外支持的XML属性： android:autoStart：设置显示该组件是否自动播放 android:flipInterval：设置自动播放的时间间隔 StackView的功能与用法StackView也是AdapterViewAnimator的子类，它也用于显示Adapter提供的一系列View。StackView将会以“堆叠(Stack)”的方式来显示多个列表项。StackView提供了下面两种控制方式： 拖走StackView中处于顶端的View，下一个View将会显示出来。将上一个View拖进StackView，将使之显示出来。 通过调用StackView的showNext()、showPrevious()控制显示下一个、上一个组件。 ps：定义的图片数组中元素位置靠前的在程序运行结果的最上方。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Spinner</tag>
        <tag>AdapterViewFlipper</tag>
        <tag>StackView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（十）]]></title>
    <url>%2F2018%2F07%2F25%2F7.25%2F</url>
    <content type="text"><![CDATA[安卓基础GridView（网格视图）GridView用于在界面上按行、列分布的方式显示多个组件。GridView和ListView都是AbsListView的子类，它们都有列表项。它们的区别就是：GridView能显示多列，ListView只能显示一列。GridView也需要通过Adapter来提供显示的数据。GridView提供的常用XML属性及相关方法如下： android:columnWidth:设置列的宽度 android:gravity:设置对齐方式 android:horizontalSpacing:设置各元素之间的水平间距 android:numColums:设置列数 android:stretchMode:设置拉伸模式 android:verticalSpacing:设置各元素之间的垂直间距 其中的android:stretchMode属性支持下列几个属性值： NO_STRETCH：不拉伸 STRETCH_SPACING：仅拉伸元素之间的间距 STRETCH_SPACING_UNIFORM：表格元素本身、元素之间的间距一起拉伸 STRETCH_COLUMN_WIDTH仅拉伸表格元素本身 GridView包含的多少行由Adapter决定。 ExpandableListView可展开的列表组件ExpandableListView时ListView的子类，它在普通ListView基础上进行了扩展，它把列表项分为几组，每组里又可包含多个列表项。ExpandableListView的用法与普通的ListView的用法十分相似，只是ExpandableListView所显示的列表项应该由ExpandableListAdapter提供，ExpandableListView也是一个接口。ExpandableListView额外支持的常用XML属性： android:childDivider：指定各组内各子列表项之间的分隔条 android:childIndicator：显示在子列表项旁边的Drawable对象 android:groupIndicator：显示在组列表项旁边的Drawable对象 扩展BaseExpandableListAdapter来实现ExpandableListAdapter，当扩展BaseExpandableListAdapter时，关键是实现如下4个方法： getGroupCount():该方法返回包含的组列表项的数量 getGroupView():该方法返回的View对象作为组列表项 getChildCount():该方法返回特定组所包含的子列表项的数量 getChildView():该方法返回的View对象将作为特定组、特定位置的子列表项]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GridView</tag>
        <tag>ExpandableListView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（九）]]></title>
    <url>%2F2018%2F07%2F24%2F7.24%2F</url>
    <content type="text"><![CDATA[安卓基础Adapter接口及实现类Adapter本身只是一个接口，它派生了ListAdapter和SpinnerAdapter两个子接口，其中ListAdapter为AbsListView提供列表项，而SpinnerAdapter为AbsSpinner提供列表项。Adapter常用的实现类： ArrayAdapter：简单、易用的Adapter。通常用于将数组或List集合的多个值包装成多个列表项 SimpleAdapter：并不简单、功能强大的Adapter，可以用于将List集合的多个对象包装成多个列表项 SimpleCursorAdapter：与SimpleAdapter基本相似，只是用于包装Cursor提供的数据 BaseAdapter：通常用于被扩展。扩展BaseAdapter可以对各列表项进行最大限度的定制 ArrayAdapter在布局文件中，定义ListView，但都没有指定android：entries属性，需要通过Adapter来提供列表项。Activity为两个ListView提供Adapter，Adapter决定ListView所显示的列表项。 1234ListView list = (ListView)findViewById(R.id.list)String[] arr1 = &#123;&quot;孙悟空&quot;,&quot;猪八戒&quot;,&quot;沙悟净&quot;&#125;;ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this,R.Layout.array_item,arr1);list.setAdapter(adapter); 其中ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this,R.Layout.array_item,arr1);中的参数： Context：代表访问整个Android应用的接口。几乎创建所有组件都需要传入Context对象。 textViewResourceId：一个资源ID，代表一个TextView，该TextView组件将作为ArrayAdapter的列表项组件 数组或List：负责为多个列表项提供数据 第二个参数控制每个列表项的组件，第三个负责为列表项提供数据。 如果程序的窗口仅需要显示一个列表，则可以直接让Activity继承ListActivity来实现，无需调用setContentView()方法显示一个界面，而是可以直接传入一个内容Adapter，ListActivity的子类就呈现出一个列表。如： 123String[] arr = &#123;&quot;孙悟空&quot;,&quot;猪八戒&quot;,&quot;沙悟净&quot;&#125;;ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this,R.Layout.simple_list_item_multiple_choice,arr);setAdapter(adapter); 使用Android提供的R.Layout.simple_list_item_multiple_choice布局文件作为列表项组件。 SimpleAdapter创建ListView通过ArrayAdapter实现Adapter虽然简单、易用，但是ArrayAdapter功能比较有限，它的每个列表项只能是TextView。如果想要实现更复杂的列表项，可以考虑使用SimpleAdapter。 123456789101112//创建一个List集合，List集合的元素是MapList&lt;Map&lt;String,Object&gt;&gt; listItems = new ArrayList&lt;Map&lt;String,Object&gt;&gt;();for(int i=0;i&lt; names.length;i++)&#123; Map&lt;String,Object&gt; listItem=new HashMap&lt;String,Object&gt;(); listItem.put(&quot;header&quot;,imageIds[i]); listItem.put(&quot;personName&quot;,names[i]); listItem.put(&quot;desc&quot;,descs[i]); listItems.add(listItem);&#125;//创建一个SimpleAdapterSimpleAdapter simpleAdapter = new SimpleAdapter(this,listItems,R.layout.simple_item,new String[] &#123;&quot;personName&quot;,&quot;header&quot;,&quot;desc&quot;&#125;,new int[] &#123;R.id.name,R.id.header,R.id.desc&#125;);list.setAdapter(simpleAdapter); 使用SimpleAdapter的难点在于创建SimpleAdapter对象，它需要5个参数，其中后四个最关键。 第二个参数：该参数应该是一个List&lt;?extends Map&lt;String,?&gt;&gt;类型的集合对象，该集合中每个Map&lt;String,?&gt;对象生成一个列表项。 第三个参数：该参数指定一个界面布局的ID。 第四个参数：该参数应该是一个String[]类型的参数，该参数决定提取Map&lt;String,?&gt;对象中那些key对应的value来生成列表项。 第五个参数：该参数应该是一个int[]类型的参数，该参数决定填充哪些组件。 如果需要监听用户单击、选中某个列表项的事件，可以通过AdapterView的setOnItemClickListener()方法为单击事件添加监听器，或者通过setOnItemSelectedListener()方法为列表项的选中事件添加监听器。在Activity中为ListView通过如下代码绑定监听器 123456//为ListView的列表项的单击事件绑定事件监听器list.setOnItemClickListener(new OnItemClickListener()&#123;&#125;);//为ListView的列表项的选中事件绑定事件监听器list.setOnItemSelectedListener(new OnItemSelectedListener()&#123;&#125;); 这种事件处理机制完全适用于AdapterView的其他子类 BaseAdapter通过扩展BaseAdapter来实现Adapter，扩展BaseAdapter可以取得对Adapter的最大控制权；程序要创建多少个列表项、每个列表项的组件都由开发者决定。 1234567891011121314151617181920BaseAdapter adapter = new BaseAdapter()&#123; @Override public int getCount()&#123;//指定一共包含多少个选项 return **;&#125; @Override public Object getItem(int position)&#123; return null;&#125;//重写该方法，该方法返回值将作为列表项的ID @Override public long getItemId(int position)&#123; return position;&#125;//重写该方法，该方法返回的View将作为列表框 @Override public View getView(int position,View convertView,ViewGroup parent)&#123;&#125;&#125; getCount():该方法的返回值控制该Adapter将会包含多少个列表项。 getItem(int position)：该方法的返回值决定第position处的列表项的内容。 getItemId(int position)：该方法的返回值决定第position处的列表项的ID。 getView(int position,View convertView,ViewGroup parent)：该方法的返回值决定第position处的列表项组件。 上面4个方法中最重要的是第一个和第四个。 AutoCompleteTextView自动完成文本框自动完成文本框（AutoCompleteTextView）从EditText派生而出，当用户输入一定字符之后，自动完成文本框会显示一个下拉菜单，供用户选择，当用户选择某个菜单项之后，AutoCompleteTextView按用户选择自动填充该文本框。AutoCompleteTextView除了可以使用EditText提供的XML属性和方法之外，还支持以下的常用XML属性： android:completionHint：设置下拉菜单中的提示标题 android:completionHintView：设置下拉菜单中提示标题的视图 android:completionThreshold：设置用户至少要输入几个字符才会显示提示 android:dropDownHeight：设置下拉菜单的高度 android:dropDownHorizontalOffset：设置下拉菜单与文本框之间的水平偏移。下拉菜单默认与文本框左对齐 android:dropDownVerticalOffset：设置下拉菜单与文本框之间的垂直偏移。下拉菜单默认紧跟文本框 android:dropDownWidth：设置下拉菜单的宽度 android:popupBackground：设置下拉菜单的背景 Markdow语法注意使用`标记代码块时，不要再它前后打空格，只要回车换行，留出空行就行。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Adapter</tag>
        <tag>ArrayAdapter</tag>
        <tag>SimpleAdapter</tag>
        <tag>BaseAdapter</tag>
        <tag>AutoCompleteTextView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（八）]]></title>
    <url>%2F2018%2F07%2F23%2F7.23%2F</url>
    <content type="text"><![CDATA[安卓基础 AdapterViewAdapterView是一组重要的组件，AdapterView是一个抽象基类。AdapterView具有如下特征 AdapterView继承了ViewGroup，它的本质是容器。 AdapterView可以包括多个“列表项”，并将多个“列表项”以合适的形式显示出来。 AdapterView显示的多个“列表项”由Adapter提供。调用AdapterView的setAdapter(Adapter)方法设置Adapter即可。 AdapterView派生了三个子类：AbsListView、AbsSpinner、AdapterViewAnimator，这三个子类依然是抽象的，实际使用过程中往往采用他们的子类。 列表视图(ListView)和ListActivityListView它以垂直列表的形式显示所有列表项。生成列表视图有如下两种方式： 直接使用ListView创建 让Activity继承ListActivity(相当于该Activity显示的组件为ListView) 一旦在程序中获得了ListView之后，接下来就需要为ListView设置它要显示的列表项。在这一点上，ListView显示出AdapterView的特征：通过setAdapter(Adapter)方法为之提供Adapter，并且由Adapter提供列表项即可。 ListView、GridView、Spinner、Gallery等AdapterView都是容器，而Adapter负责提供每个“列表项”组件，AdapterView则负责采用合适的方式显示这些列表项。 ListView提供的常用XML属性如下： android:divider：设置List列表项的分隔条（可用颜色分隔，也可用Drawable分隔） android:dividerHeight：设置分隔条的高度 android:entries：指定一个数组源，Android将根据该数组资源来生成ListView android:footerDividersEnabled：如果设置为false，则不再footerView之前绘制分隔条 android:headerDividersEnabled：如果设置为false，则不在headerView之后绘制分隔条]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ListView</tag>
        <tag>ListActivity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（七）]]></title>
    <url>%2F2018%2F07%2F22%2F7.22%2F</url>
    <content type="text"><![CDATA[安卓基础 ImageViewImageView继承View，主要用来显示图片，它能显示的不仅仅是图片，任何Drawable对象都可以使用ImageView来显示。ImageView支持的XML属性： android:adjustViewBounds设置ImageView是否调整自己的边界来保持所显示图片的长宽比 android:cropToPadding如果将该属性设置为true，该组件将会被裁剪到保留该ImageView的padding android:scaleType设置所显示的图片如何缩放或移动以适应ImageView的大小 android:src设置ImageView所显示的图片的ID android:scaleType支持的属性值： matrix:使用matrix方式进行缩放 fitXY对图片、纵向独立缩放 fitStart保持纵横比缩放图片 fitCenter保持纵横比缩放图片，缩放后放在ImageView中央 fitEnd保持纵横比缩放图片，缩放后放在ImageView的右下角 center放在ImageView中央 centerCrop保持纵横比缩放图片，只要图片的最短边能显示出来即可 centerInside保持纵横比缩放图片，ImageView能完全显示该图片 为了控制ImageView显示的图片，ImageView提供了如下方法 setImageBitmap(Bitmap bit):使用Bitmap位图设置图片 setImageDrawable(Drawable drawable)：使用Drawable对象设置图片 setImageResource(int resId)：使用图片资源ID设置图片 setImageURI(Uri uri)：使用图片的URI设置该ImageView显示设置的图片 ps：如果要实现放大图片的局部 1234有两个ImageView，第一个放原图Image1，第二个放发大的部分图片Image2。第一步：获取原图与放大部分的比例，即double scale = 1.0*Image1.getHeight()/Image2.getHeight()。第二步：获取需要显示的图片的起始位置:int X=(int)(event.getX()*scale);int Y=(int)(event.getY()*scale);还要注意在原图中右边和下边的宽度大于Image2的，必须固定起始位置为Image1.getWidth()-Image2.getWidth()。 ImageButtonImageButton派生了一个ZoomButton，ZoomButton可以代表“放大”“缩小”两个按钮，ZoomButton的行为基本类似于ImageButtonZoomControls组件，该组件相当于同时组合了“放大”“缩小”两个按钮，并允许分别为两个按钮绑定不同的事件监听器。 使用QuickContactBadge关联联系人QuickContactBadge继承了ImageView，因此它的本质也是图片按钮，也可以通过android:src来指定它显示的图片。它额外增加的功能是：该图片可以关联到手机中指定联系人，当用户单机该图片时，系统将会打开相应联系人的联系方式界面。可以调用如下方法： assignContactFromEmail(String emailAddapp\src\main\ress,boolean lazyLookup):将该图片关联到指定E-mail地址对应的联系人 assignContactFromPhone(String phoneNumber,boolean lazyLookup):将该图片关联到指定电话号码对应的联系人 assignContactUri(Uri contactUri):将图片关联到特定Uri对应的联系人杂项改变查看图片的透明度，可以调用ImageView的setImageAlpha()方法来实现i+=a 就是i=i+a]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ImageView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（六）]]></title>
    <url>%2F2018%2F07%2F21%2F7.21%2F</url>
    <content type="text"><![CDATA[安卓基础TextView默认情况下，TextView是不带边框的，如果想为TextView添加边框，可以考虑为TextView设置一个背景Drawable，该Drawable只是一个边框（是一个XML文件，放在drawable文件夹内）。由于TextView是EditText和Button的父类，因此对TextView控制的属性，同样适用于EditText与Button。 EditTextEditText最重要的属性是inputType，该属性相当于HTML的&lt;input…/&gt;元素的type属性，用于将EditText设置为指定类型的输入组件。android:inputType属性（系统自动显示哪种类型的输入键盘）： numberPassword：表示只能接受数字密码（使用安卓系统自带安全的数字输入法） number：表示是数字输入框（使用输入法的数字输入法） date：表示是日期输入框（使用输入法的数字输入法） phone：表示是输入电话号码的输入框（使用输入法的数字输入法） android:selectAllOnFocu属性 =true为如果文本框的内容能选择，设置是否当它获得焦点时自动选中所有文本。 =false不选中。 ButtonButton继承了TextView，主要是生成一个按钮，该按钮能提供被用户点击时触发一个onClick事件。如果需要让按钮的背景颜色、背景图片随用户动作动态改变，考虑使用自定义Drawable实现。 Button常用属性： android:shadowColor设置文本框内文本的阴影颜色 android:shadowRadius设置阴影的模糊程度，该值越大越模糊 android:shadowDx阴影在水平方向的偏移 android:shadowDy阴影在垂直方向的偏移 Button的android:background=””属性，可以用XML实现，在XMl中可以用state_pressed=”true”表示按钮按下，state_pressed=”false”表示按钮松开，并且利用android:drawable=””表示背景。 使用9Patch图片作为背景当按钮的内容太多时，Android会自动缩放整张图片，以保证背景图片能覆盖整个按钮。但是这种缩放的效果并不好。为了实现只缩放图片中某个部分，借助9Patch图片实现。左侧和上侧的直线共同决定图片的缩放区域右侧和下侧的直线共同决定图片的内容显示区域 RadioButton和CheckBox两个都有一个可选中的功能，不过一组RadioButton只能选择其中一个，所以RadioButton通常要与RadioGroup一起使用，用于定于一组单选钮；CheckBox可以复选。都可额外指定一个android:checked属性，该属性用于指定RadioButton、checkBox初始时是否被选中。如果在XML布局文件中默认勾选了某个单选钮，则必须为该组单选钮的每个按钮指定android：id属性值；否则这组单选钮不能正常工作 状态开关按钮（ToggleButton）和开关（Switch）两个都是Button派生出来的，本质也是按钮。ToggleButton和Switch通常用于切换程序中的某种状态。ToggleButton支持的XML属性： android:checked设置该按钮是否被选中 android:textOff设置当按钮的状态关闭时显示的文本 android:textOn设置当按钮的状态打开时显示的文本 Switch支持的XML属性： android:checked设置该按钮是否被选中 android:textOff设置当按钮的状态关闭时显示的文本 android:textOn设置当按钮的状态打开时显示的文本 android:switchTextAppearnce设置该开关图标上的文本样式 android:textStyle设置该开关的文本风格 android:thumb指定使用自定义Drawable绘制该开关按钮 android:track指定使用自定义Drawable绘制该开关的开关轨迹 android:typeface设置该开关的文本的字体风格 时钟（AnalogClock和TextClock）TextClock是数字时钟，继承了TextView，不能设置android:text。它的属性： android:format12Hour设置该时钟的12小时制的格式字符串 android:format24Hour设置该时钟的24小时制的格式字符串 android:timeZone设置该时钟的时区 AnalogClock是模拟时钟，继承了View，重写了View的OnDraw方法。它的属性： android:dial设置该模拟时钟的表盘使用的图片 android:hand_hour设置该模拟时钟的时针使用的图片 android:hand_minute设置该模拟时钟的分针使用的图片 计时器(Chronometer)Chronometer继承TextView，但是它不会显示当前时间，它显示的是从某一个起始时间开始，一共过去了多长时间。Chronometer的方法： setBase(long base)：设置计时器的起始时间 setFormat(String format)：设置显示时间的格式 start()：开始计时 stop()：停止计时 setOnChronometerTickListener(Chronometer.OnChronometerTickListener listener)：绑定事件监听器，当事件改变时触发该监听器 SystemClock.elapsedRealtime()，系统启动至今的时间/计算某个时间经历了多长时间有意义 零碎知识点String words = checkId == R.id.male ? &quot;你的性别是男性&quot;:&quot;你的性别是女性&quot;这句代表如果RadioButton的checkId值是等于R.id.male就把”你的性别是男性”赋给words。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>TextView</tag>
        <tag>EditText</tag>
        <tag>Button</tag>
        <tag>使用9Patch图片作为背景</tag>
        <tag>RadioButton和CheckBox</tag>
        <tag>状态开关按钮（ToggleButton）和开关（Switch）</tag>
        <tag>时钟（AnalogClock和TextClock）</tag>
        <tag>计时器(Chronometer)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[长征]]></title>
    <url>%2F2018%2F07%2F20%2F7.20%2F</url>
    <content type="text"><![CDATA[回顾历史长征土地革命战争时期，中国工农红军主力撤离长江南北各苏区，转战两年，到达陕甘苏区的战略转移行动。1934年10月，第五次反围剿失败后，中央主力红军为摆脱国民党军队的包围追击，被迫实行战略性转移，退出中央根据地，进行长征。长征是人类历史上的伟大奇迹，中央红军共进行了380余次战斗，攻占700多座县城，红军牺牲了营以上干部多达430余人，平均年龄不到30岁，共击溃国民党军数百个团，其间共经过14个省，翻越18座大山，跨过24条大河，走过荒草地，翻过雪山，行程约二万五千里，红一方面军于1935年10月到达陕北，与陕北红军胜利会师。1936年10月，红二、四方面军到达甘肃会宁地区，同红一方面军会师。红军三大主力会师，标志着万里长征的胜利结束。 基本路线瑞金→突破敌四道防线→强渡乌江→占领遵义→四渡赤水→巧渡金沙江→强渡大渡河→飞夺泸定桥→翻雪山→过草地→陕北吴起会师(1935年10月)→甘肃会宁会师(1936年10月)，宣告长征的胜利结束。 各阶段长征准备阶段（1934年7月7日～1934年10月10日）长征失利阶段（1934年10月10日～1935年1月15日）长征转折阶段（1935年1月15日～1935年6月14日）坚持北上和南下分裂阶段（1935年6月14日～1935年10月19日）发展巩固和南下受挫阶段（1935年10月19日～1936年7月1日）大会师阶段（1936年7月1日～1936年12月12日） 各部队第一支是中央红军（后改称红一方面军），于1934年10月10日由福建的长汀等地出发，1935年10月19日到达陕西的吴起镇（今吴起县），行程达二万五千里；第二支是红二十五军（后编入红一方面军），于1934年11月16日由河南罗山何家冲出发，1935年9月15日到达陕西延川永坪镇，同陕甘红军会师，合编为红十五军团，行程近万里，最早到达陕北的一支红军 。第三支是红四方面军，于1935年5月初放弃川陕苏区，由彰明、中坝、青川、平武等地出发，向岷江地区西进，1936年10月9日到达甘肃会宁，与红一方面军会师，行程一万余里；第四支是红二、红六军团（后同红一方面军第三十二军合编为红二方面军），于1935年11月19日由湖南桑植刘家坪等地出发，1936年10月22日到达会宁以东的将台堡，同红一方面军会师，行程两万余里。]]></content>
      <categories>
        <category>历史</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android学习（五）]]></title>
    <url>%2F2018%2F07%2F19%2F7.19%2F</url>
    <content type="text"><![CDATA[安卓基础相对布局RelativeLayout可支持的两个Xml属性 android:gravity设置该布局容器内各子组件的对齐方式 android:ignoreGravity设置哪个组件不受gravity属性影响 为了扩展RelativeLayout中各子组件的分布布局，RelativeLayout提供了一个内部类：RelativeLayout.LayoutParams，该类提供了大量的Xml属性来控制子组件的布局分布。 相对布局子组件的布局分布里只能设置true或false的XML属性。 android:layout_centerHorizontal控制该子组件是否位于布局容器的水平居中 android:layout_centerVertical控制该子组件是否位于布局容器的垂直居中 android:layout_centerInParent控制该子组件是否位于布局容器的中央位置 android:layout_alignParentBottom控制该子组件是否与布局容器的底端对齐 android:layout_alignParentLeft控制该子组件是否与布局容器的左端对齐 android:layout_alignParentRight控制该子组件是否与布局容器的右端对齐 android:layout_alignParentTop控制该子组件是否与布局容器的顶端对齐 相对布局子组件的布局分布里属性值为其他UI组件ID的XML属性。 android:layout_toRightOf控制该子组件位于给出ID组件的右侧 android:layout_toLeftOf控制该子组件位于给出ID组件的左侧 android:layout_above控制该子组件位于给出ID组件的上方 android:layout_below控制该子组件位于给出ID组件的下方 android:layout_alignTop控制该子组件与给出ID组件的上边界对齐 android:layout_alignBottom控制该子组件与给出ID组件的下边界对齐 android:layout_alignLeft控制该子组件与给出ID组件的左边界对齐 android:layout_alignRight控制该子组件与给出ID组件的右边界对齐 ps：align对齐，to在什么侧 GridLayoutGridLayout的作用类似于HTML中的table标签，它将整个容器划分为rows*columns个网格，每个网格可以放置一个组件。除此之外，也可以设置一个组件横跨多少列、一个组件纵跨多少行。GridLayout常用的XML属性： android:alignmentMode设置该布局管理器采用的对齐模式 android:columnCount设置该网格的列数量 android:columnOrderPreserved设置该网格容器是否保留序号 android:rowCount设置该网格的行数量 android:rowOrderPreserved设置该网格容器是否保留行序号 android:useDefaultMargins设置该布局管理器是否使用默认的页边距 ps：Margins边距，column列，row行为了控制GridLayout布局容器中各子组件的布局分布，GridLayout提供了一个内部类：GridLayout.LayoutParams，该类提供了大量的XML属性来控制网格布局中子组件的布局分布。GridLayout.LayoutParams常用的XML属性： android:layout_column设置该子组件在GridLayout的第几列 android:layout_columnSpan设置该子组件在GridLayout横向上跨几列 android:layout_gravity设置该子组件采用何种方式占据该网格的空间 android:layout_row设置该子组件在GridLayout的第几行 android:layout_rowSpan设置该子组件在GridLayout纵向上跨几行 ps：column列，row行，span跨越setpadding(a,b,c,d)设置四周的空白区域 绝对布局绝对布局由AbsoluteLayout所代表。就像Java中AWT编程中的空布局，Android不提供任何布局控制，而是由开发人员自己通过X、Y坐标来控制组件的位置，布局容器不再管理子组件的位置、大小。（绝对布局已经过时了） layout_x:子组件的X坐标 layout_y:子组件的Y坐标 安卓布局中常用的距离单位px：每个px对应屏幕上的一个点dip或dp（设备独立像素，device independent pixels）：一种基于屏幕密度的抽象单位。在每英寸160点的显示器上，1dip=1px。但随着屏幕密度的改变，dip与px的换算会发生改变。sp（比例像素，scaled pixels）：主要是处理字体的大小，可以根据用户的字体大小首选项进行缩放。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>View</tag>
        <tag>Relativelayout</tag>
        <tag>GridLayout</tag>
        <tag>AbsoluteLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（四）]]></title>
    <url>%2F2018%2F07%2F18%2F7.18%2F</url>
    <content type="text"><![CDATA[安卓基础表格布局TableLayout继承了LinearLayout，TableLayout通过添加TableRow、其他组件来控制表格的行数和列数。每次向TableLayout中添加一个TableRow，该TableRow就是一个表格行，TableRow也是容器，因此它也可以不断地添加其他组件，每添加一个子组件该表格就增加一行。如果直接向TableLayout中添加组件，那么这个组件将直接占用一行。在TableLayout中，列的宽度由最宽的TableRow决定，整个表格布局的宽度由父容器决定。Shrinkable：一个TableRow中，列的单元格宽度可以收缩。从0开始计数Stretchable：一个TableRow中，列的单元格宽度可以拉伸。从0开始计数 帧布局帧布局由FrameLayout所代表，FrameLayout直接继承了ViewGroup组件。帧布局容器为每个加入其中的组件创建一个空白的区域(一帧)，每个子组件占据一帧，这些帧都会根据gravity属性执行自动对齐。把组件一个个叠加在一起，后加的组件覆盖前面加的组件。FrameLayout包含的子元素也可指定Layout_gravity。安卓不允许开发者启动线程访问用户界面的UI组件。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>View</tag>
        <tag>Tablelayout</tag>
        <tag>FrameLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（三）]]></title>
    <url>%2F2018%2F07%2F16%2F7.16%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[安卓基础开发自定义ViewView组件只是一个空白区域，没有任何内容。对于Android应用的其他UI组件来说，它们都继承了View组件，然后再View组件提供的空白区域绘制外观。当Android系统提供的UI组件不足以满足项目需要时，开发者可以通过继承View来派生自定义组件。当开发者打算派生自己的UI组件时，首先要定义一个继承View基类的子类，然后重写View类的一个或多个方法。 线性布局Android的线性布局不会换行，当组件一个挨着一个排列到头之后，剩下的组件将不会被显示出来。Linearlayout的常用XML属性及相关方法的说明： android:divider 设置处置布局时两个按钮之间的分隔条 android:gravity 设置布局管理器内组件的对齐方式。可以同时指定多种对齐方式的组合，例如：left|center_vertical代表出现在屏幕左边，而且垂直居中。 android:orientation 设置布局管理器内组件的排列方式。有horizontal水平排列，vertical垂直排列。 Linearlayout包含的所有子元素都受Linearlayout.layoutParams控制，因此Linearlayout包含的子元素可以额外指定如下的属性： android:layout_gravity 指定该子元素在Linearlayout中的对齐方式 android:layout_weight 指定该子元素在Linearlayout中所占的权重 ps：许多布局内子元素支持指定android:layout_ gravity属性，该属性设置该子元素在父容器中的对齐方式。与android:layout_gravity相似的属性还有android:gravity属性（一般是容器才支持指定该属性），android:gravity属性用于控制它所包含的子元素的对齐方式。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>View</tag>
        <tag>Linearlayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i++与++i的区别]]></title>
    <url>%2F2018%2F07%2F15%2F7.15.2%2F</url>
    <content type="text"><![CDATA[这个问题过一段时间就老是忘记i++与++i的区别简单的说i++与++i在单独使用的时候，就是i=i+1。而a=++i，相当于i=i+1；a=i；（先i=i+1，再使用i的值）而a=i++，相当于a=i；i=i+1；（先使用i的值，再i=i+1） 0对任何数求余结果都是0例如：0%2就是0.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>i++与++i</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（二）]]></title>
    <url>%2F2018%2F07%2F15%2F7-15%2F</url>
    <content type="text"><![CDATA[安卓基础Activity和ViewActivity只能通过setContentView(View)来显示指定组件。setContentView()的参数有两种： view对象 布局管理器的id值，即R.layout.main等等 ServiceService也代表一个单独的Android组件。Service与Activity的区别在于：Service通常位于后台运行，它一般不需要与用户交互，因而Service没有图形用户界面。Service组件需要继承Service基类，Service被运行起来之后，它将拥有自己独立的生命周期，Service组件通常用于为其他组件提供后台服务或监控其他组件的运行状态。 BroadcastReceiverBroadcastReceiver也是Android应用中的组件，代表广播消息接收器。BroadcastReceiver非常类似于事件编程中的监听器，与普通事件监听器不同的是，普通事件监听器监听的事件源是程序中的对象；而BroadcastReceiver监听的事件源是Android应用中的其他组件。使用BroadcastReceiver组件接受广播消息比较简单，开发者只需要实现自己的BroadcastReceiver子类，并重写onReceive(Context context,Intent intent)方法即可。当其他组件通过sendBroadcast(),sendStickyBroadcast(),sendOrderedBroadcast()方法发送广播消息时，如果该BroadcastReceiver也对该消息感兴趣（通过IntentFilter配置），BroadcastReceiver的onReceive(Context context,Intent intent)方法将会被触发。开发者实现了BroadcastReceiver后，通常有两种方式来注册这个系统级的“事件监听器”。 在Java代码中通过Context.registReceiver()方法注册BroadcastReceiver. 在AndroidManifest.xml文件中使用&lt;receiver…/&gt;元素完成注册。 ContentProviderAndroid应用运行在各自独立的进程中，如果这些Android应用之间需要实现实时的数据交换——例如，我们开发了一个发送短信的程序，当发送短信时需要从联系人管理应用中读取指定联系人的数据——这就需要多个应用程序之间进行数据交换，开发者可以编写自己的ContentProvider来实现数据交换。开发者需要实现如下的抽象方法： insert(Uri,ContentValues)：向ContentProvider插入数据 delete(Uri,ContentValues)：删除ContentProvider中指定数据 update(Uri,ContentValues,String,String[])：更新ContentProvider中指定数据 query(Uri,String[],String,String[],String)：从ContentProvider查询数据 通常与ContentProvider结合使用的时ContentResolver，一个应用程序使用ContentProvider暴露自己的数据，而另一个应用程序则通过ContentResolver来访问数据。 Intent和IntentFilterIntent可以启动另一个Activity，也可以启动一个Service组件，还可以发送一条广播消息来触发系统中的BroadcastRecevier。也就说这三种组件之间的通信都以Intent作为载体。 当需要启动一个Activity时，可以调用Context的startActivity(Intent intent)或startActivityForResult(Intent intent,int requestCode)方法，这两个方法中intent中封装了需要启动的Activity的信息。 启动Service时，调用Context的startService(Intent intent)方法或者bindService(Intent service,ServiceConnection conn,int flags)方法，这两个方法中intent封装了需要启动的目标service的信息。 当需要触发一个BroadcastReceiver时，可调用Context的sendBroadcast(Intent intent),sendStickyBroadcast(Intent intent)或sendOrderedBroadcast(Intent intent,String receiverPermission)方法来发送广播消息，这三个方法中Intent参数封装了需要触发的目标BroadcastReceiver的信息。 当一个组件通过Intent表示了启动或触发另一个组件的“意图”之后，这个意图可以分为两类。 显式Intent：显式Intent明确指定需要启动或者触发的组件的类名。 隐式Intent：隐式Intent只是指定需要启动或者触发的组件应满足怎样的条件。 被调用的组件通过IntentFilter来声明自己所满足的条件——也就是声明自己到底能处理哪些隐式Intent。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Activity</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（一）]]></title>
    <url>%2F2018%2F07%2F14%2F7.14%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Android应用清单文件AndroidManifest.xmlAndroidManifest.xml清单文件通常包含如下信息： 应用程序包名 应用程序所包含的组件，如Activity、Service、BroadcastReceiver和ContentProvider等 应用程序兼容的最低版本 应用程序使用系统所需的权限声明 其他程序访问该程序所需的权限声明 应用程序权限说明1.声明运行该应用本身所需要的权限通过为&lt;Manifest…/&gt;元素添加&lt;uses-permission…/&gt;子元素即可为程序本身声明权限。例如：&lt;! –声明该应用本身需要打电话的权限 –&gt;&lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;/&gt;2.声明调用该应用所需的权限通过为应用的各组件元素，如&lt;activity…/&gt;元素添加&lt;uses-permission…/&gt;子元素即可声明调用该程序所需的权限。例如：&lt;! –声明该应用本身需要发送短信的权限 –&gt; &lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot;&gt;常用权限如下表： 权限 说明 ACCESS_NETWORK_STATE 允许应用程序获取网络状态信息的权限 ACCESS_WIFI_STATE 允许应用程序获取Wi-Fi网络状态信息的权限 BATTERY_STATS 允许应用程序获取电池状态信息的权限 BLUETOOTH 允许应用程序连接匹配的蓝牙设备的权限 BLUETOOTH_ADMIN 允许应用程序发现匹配的蓝牙设备的权限 BROADCAST_SMS 允许应用程序广播收到短信提醒的权限 CALL_PHONE 允许应用程序拨打电话的权限 CAMERA 允许应用程序使用照相机的权限 CHANGE_NETWORK_STATE 允许应用程序改变网络连接状态的权限 CHANGE_WIFI_STATE 允许应用程序改变wifi网络连接状态的权限 DELETE_CACHE_FILES 允许应用程序删除缓存文件的权限 DELETE_PACKAGES 允许应用程序删除安装包的权限 FLASHLIGHT 允许应用程序访问闪光灯的权限 INTERNET 允许应用程序打开网络Socket的权限 MODIFY_AUDIO_SETTINGS 允许应用程序修改全局声音设置的权限 PROCESS_OUTGOING_CALLS 允许应用程序监听、控制、取消呼出电话的权限 READ_CONTACTS 允许应用程序读取用户的联系人数据的权限 READ_HISTORY_BOOKMARKS 允许应用程序读取历史书签的权限 READ_OWNER_DATA 允许应用程序读取用户数据的权限 READ_PHONE_STATE 允许应用程序读取电话状态的权限 READ_PHONE_SMS 允许应用程序读取短信的权限 REBOOT 允许应用程序重启系统的权限 RECEIVE_MMS 允许应用程序接收、监控、处理彩信的权限 RECEIVE_SMS 允许应用程序接收、监控、处理短信的权限 RECORD_AUDIO 允许应用程序录音的权限 SEND_SMS 允许应用程序发送短信的权限 SET_ORIENTATION 允许应用程序旋转屏幕的权限 SET_TIME 允许应用程序设置时间的权限 SET_TIME_ZONE 允许应用程序设置时区的权限 SET_WALLPAPER 允许应用程序设置桌面壁纸的权限 VIBRATE 允许应用程序控制振动器的权限 WRITE_CONTACTS 允许应用程序写入用户联系人的权限 WRITE_HISTORY_BOOKMARKS 允许应用程序写历史书签的权限 WRITE_OWNER_DATA 允许应用程序写用户数据的权限 WRITE_SMS 允许应用程序写短信的权限]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>AndroidManifest.xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统概述]]></title>
    <url>%2F2018%2F07%2F14%2F7.14%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[1.数据库的4个基本概念数据(data)描述数据的符号记录称为数据。 数据库(DataBase,DB)数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享。 数据库管理系统(DataBase Management System,DBMS)数据库管理系统是位于用户与操作系统之间的一层数据管理软件。数据库管理系统和操作系统一样是计算机的基础软件。主要功能： 数据定义功能 数据组织、存储和管理 数据操纵功能 数据库的事务管理和运行管理 数据库的建立和维护功能 其他 数据库系统(DataBase System,DBS)数据库系统是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员(DataBase Administrator,DBA)组成的存储、管理、处理和维护数据的系统。 2.数据管理技术的发展 人工管理阶段 文件系统阶段 数据库系统阶段 3.数据模型两类数据模型 概念模型 按照用户的观点来对数据建模，用于数据库设计 逻辑模型和物理模型 包括层次模型、网状模型、关系模型等等，它是按照计算机系统观点对数据建模，用于数据库管理系统的实现。 数据模型的组成要素 数据结构 数据操作 数据的完整性约束条件]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[博客编写注意事项（2）]]></title>
    <url>%2F2018%2F07%2F13%2F7.13%2F</url>
    <content type="text"><![CDATA[浅谈Markdown语法在GitHub博客中的应用 第二个注意事项markdown语句书写细节在诸如#,:等特殊符号后，应添加空格，以保证语句在编译时的正确性。 ‘标亮’的使用在输入法为英文的情况下，我们使用的tab键正上方的那个键来表示标亮。例如：你好，我是标亮符号的表现形式。 ‘加粗’的使用我们仅仅只需要在需要加粗的文本前后各加2个*就可以实现。例如： 你好我是加粗的表现形式。 ‘无序列表项’的使用列表项通过“-/*/+ 文本描述”引号其中的表达方式实现。二级无序列表项只需要在缩进符号前，加一个空格。例如：（此处需要空一行才可以实现无序列表） 无序列表项1 无序列表项1.1 无序列表项2 无序列表项3 ‘有序列表项’的使用有序列表项通过“1.”引号其中的数字+一个英文句点实现。例如： 有序列表项1 有序列表项2 有序列表项3 ‘列表缩进’的使用缩进的符号用“*/+/-”都可以实现，在缩进符号后面紧跟一个空格或者tab制表符。在文本中的换行用两个空格即可实现。例如： 蜀相丞相祠堂何处寻，锦官城外白森森。映阶碧草自春色，隔叶黄鹂空好音。三顾频烦天下计，两朝开济老臣心。出事未捷身先死，长使英雄泪满襟。 ‘图片，超链接，视频’在博客中的插入剑门关ps：在网页中的图片，只需要右击鼠标，点击复制图片地址，再插入博客中，图片插入的网址粘贴上就行。 ‘代码块’的插入在英文键盘输入的模式下,使用tab键上面的键，文本首尾连按三次就行。例如： 12345public class Speak()&#123; public static void main(String args[])&#123; System.out.println(&quot;你好&quot;); &#125;&#125; ‘表格’的插入推荐一个能生成多种列表的网址：http://www.tablesgenerator.com/markdown_tables#点此进入 ‘tags’多标签实现通过在tags的叙述中使用“- 标签1- 标签2”来实现，标签1与2之间需要换行。例如：123tags: - Activity - View]]></content>
      <categories>
        <category>MarkDown语法</category>
      </categories>
      <tags>
        <tag>博客编写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客编写格式注意（1）]]></title>
    <url>%2F2018%2F07%2F12%2F7.12%2F</url>
    <content type="text"><![CDATA[浅谈GitHub博客的本地Markdown文件书写的语法及注意事项 第一个注意事项title标题 “—”title: 博客编写格式注意categories: MarkDown语法tags: 博客编写“—”浅谈GitHub博客的本地Markdown文件书写的语法及注意事项 在这段md语句中title的“—” “—”包裹需要在第二个—后面加一段文字性描述；否则GitHub博客上不会识别出这个md文件的标题，博客上显示的标题是未命名，且title下面的分类、标签都没有加上，变成了文字性的描述了。 ‘&gt;’引用的使用‘&gt;’的结尾需要回车打出一个空白行来结束引用。]]></content>
      <categories>
        <category>MarkDown语法</category>
      </categories>
      <tags>
        <tag>博客编写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读三国]]></title>
    <url>%2F2018%2F07%2F11%2F%E4%B8%80%E5%8F%A3%E6%B0%94%E8%AF%BB%E4%B8%89%E5%9B%BD1%2F</url>
    <content type="text"><![CDATA[总结一下三国演义中出现的关键人物及事迹 读三国（一）汉室倾颓，讨伐董卓刘关张桃园三结义、曹孟德献七星宝刀、虎牢关三英战吕布、董卓火烧洛阳、王允利用貂蝉美人计离间吕布董卓 群雄逐鹿，吕布覆灭曹操挟天子以令诸侯、孙策小霸王平定江东八十一县、吕布白门楼殒命 内阁密诏，千里独行刘备曹操青梅煮酒论英雄、董承联合众汉臣密谋杀曹操、关云长千里走单骑、刘玄德赵子龙相见情义比桃园]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>三国</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewPager的认识]]></title>
    <url>%2F2018%2F07%2F10%2FViewPager%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[ViewPager的认识ViewPager是怎么样的一个控件 它是一个用于页面切换的组件，我们可以向它的布局内填充多个View，我们可以通过在触摸屏上左右滑动来切换不同的View。我们需要一个适配器Adapter，将要显示的View和我们的ViewPager进行绑定。ViewPager有自己的Adapter——PagerAdapter。其中，Google建议使用Fragment来填充ViewPager的，这样可以更加方便的生成每个Page以及管理每个Page的生命周期，就是FragmentPageAdapter和FragmentStatePagerAdapter两个不同的Adapter。除此之外，ViewPager会缓存当前页，前一页，以及后一页，比如有1，2，3，4这四个页面，当我们处于第一页：缓存1，2；当我们处于第二页：缓存1，2，3；当我们处于第三页：缓存2，3，4；当我们处于第四页缓存3，4。 PagerAdapter使用重写方法：getCount()：获得viewpager中有多少个viewdestroyItem()：移除一个给定位置的页面。适配器有责任从容器中删除这个视图。这是为了确保在finishUpdate(ViewGroup)返回时视图能被移除。instantiateItem()：①将给定位置的view添加到ViewGroup(容器)中，创建并显示出来②返回一个代表新增页面的Object(key),通常都是直接返回view本身就可以了。当然也可以自己自定义key，但是key和每一个view要一一对应。isViewFromObject()：判断instantiateItem(ViewGroup,int)函数所返回的key与一个页面视图是否是代表的同一个视图(即它俩是否是对应，对应的表示同一个View)，通常我们直接写return view ==object；就可以了。貌似因为ViewPager中有个存储view状态信息的ArrayList，根据View取出对应信息。ps：不一定要重写所有方法。]]></content>
      <categories>
        <category>Fragment</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown练习]]></title>
    <url>%2F2018%2F07%2F09%2FMarkdown%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述 宗旨 Markdown的目标是实现易读易写。 可读性，无论如何，都是最重要的。一份使用Markdown格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown语法受到一些既有text-to-HTML格式的影响，包括Setext、atx、Textile、reStructuredText、Grutatext和EtText，而最大灵感来源其实是纯文本电子邮件的格式。 总之，Markdown的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像强调。Markdown的列表看起来，嗯，就是列表。Markdown的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用hexo+github搭建免费博客]]></title>
    <url>%2F2018%2F07%2F08%2F%E5%88%A9%E7%94%A8hexo%2Bgithub%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一、准备工作： 注册一个github账号 ：支持高亮代码块、LaTeX 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手； 安装node.js ：下载链接https://pan.baidu.com/s/1xTBWJ-FFqe6_UfpYezuBtA 安装git ：下载链接https://pan.baidu.com/s/1FdgU2wjgF4RXQc5JRXrxbw 安装node.js和git ：只需要按默认next就ok了。 node.js环境配置：参考链接中的步骤https://www.jianshu.com/p/03a76b2e7e00 二、开始： 创建blog文件夹、并安装hexo、创建github仓库：在你的某个盘符下根目录创建一个blog空文件夹，操作步骤参考下面链接中的步骤3和4https://www.cnblogs.com/fengxiongZz/p/7707219.html 配置SSH key：参考下面链接中的步骤3https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html和参考下面链接中的步骤5https://www.cnblogs.com/fengxiongZz/p/7707219.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于SQLite本地数据库查询]]></title>
    <url>%2F2018%2F07%2F08%2Fsqlite%2F</url>
    <content type="text"><![CDATA[关于SQLite本地数据库查询1 本地数据库是存在于软件自安装至卸载的生命周期。2 sql语句与MySQL的数据库操作语句一样。3 通过用户注册的时候，获取当前用户的id（主键），通过Intent传值到最终需要用sqlite创建数据表的Activity中，Intent传值是要一个Activity接一个Activity的传（Activity中有点击跳转事件）。4 Intent传值的一些方法：①intent.putExtra(“userid”,result); //将服务器中result的id放入intent。result是一个字符串，通过服务器获取的。②Activity中传“userid”对应的值：String userId = null；Intent intent = getIntent();userId = intent.getStringExtra(“userid”);//取出intent.putExtra(“userid”,userId);//放入]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
