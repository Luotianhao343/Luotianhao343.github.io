<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="罗某">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="罗某">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="罗某">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>罗某</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">罗某</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home//首页"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user//我的"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags//标签"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th//分类"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive//归档"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/23/8.23.3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="法外狂徒罗某人">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="罗某">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/23/8.23.3/" itemprop="url">Strength</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-23T21:12:16+08:00">
                2018-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/fit/" itemprop="url" rel="index">
                    <span itemprop="name">fit</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="健身基础"><a href="#健身基础" class="headerlink" title="健身基础"></a>健身基础</h1><h2 id="全身各块肌肉，较好的训练动作"><a href="#全身各块肌肉，较好的训练动作" class="headerlink" title="全身各块肌肉，较好的训练动作"></a>全身各块肌肉，较好的训练动作</h2><p>每块肌肉一个专属动作：</p>
<ol>
<li>最佳整体胸肌增长，哑铃平板卧推</li>
<li>最佳背阔肌宽度增长，宽握高位下拉（宽距引体）</li>
<li>最佳整体三角肌增长，哑铃推举</li>
<li>最佳二头肌增长，窄距反握引体向上</li>
<li>最佳三头肌增长，双杠臂屈伸</li>
<li>最佳股四头肌训练，颈前深蹲</li>
<li>最佳腘绳肌和臀部肌肉增长，罗马尼亚硬拉</li>
<li>最佳斜方肌增长，杠铃耸肩</li>
<li>最佳整体腹部训练，卷腹</li>
<li>最佳核心力量训练，平板支撑</li>
<li>最佳整体肌肉增长，深蹲</li>
</ol>
<h2 id="增肌9要点"><a href="#增肌9要点" class="headerlink" title="增肌9要点"></a>增肌9要点</h2><p>要点：</p>
<ol>
<li>1个小时（训练控制在1小时内）</li>
<li>2个部位</li>
<li>3个动作</li>
<li>4组</li>
<li>一日5餐</li>
<li>6个部位（胸肩背腿腹臀）</li>
<li>7天（一个周期7天）</li>
<li>8RM</li>
<li>9个星期（开始休息1星期）</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/23/8.23.2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="法外狂徒罗某人">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="罗某">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/23/8.23.2/" itemprop="url">Android学习（四十之Android网络应用）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-23T18:08:40+08:00">
                2018-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="安卓基础"><a href="#安卓基础" class="headerlink" title="安卓基础"></a>安卓基础</h1><p>Android完全支持JDK本身的TCP,UDP网络通信API，也可以使用ServerSocket、Socket来建立基于TCP/IP协议的网络通信，还可以使用DatagramSocaket、Datagrampacket、MulticastSocket来建立基于UDP协议的网络通信。Android也支持JDK提供的URL、URLConnection等网络通信API。   </p>
<p>不仅如此，Android还内置了HttpClient，这样可以非常方便地发送HTTP请求，并获取HTTP响应，通过内置HttpClient，Android简化了与网站之间的交互。令人遗憾的是，Android并未内置对Web Service的支持，为了弥补这种不足，可以利用ksoap2-android项目在Android应用中调用远程Web Service。</p>
<h2 id="基于TCP协议的网络通信"><a href="#基于TCP协议的网络通信" class="headerlink" title="基于TCP协议的网络通信"></a>基于TCP协议的网络通信</h2><p>TCP/IP通信协议是一种可靠的网络协议，它在通信的两端各建立一个Socket，从而在通信的两端之间形成了网络虚拟链路。一旦建立了它，两端的程序就可以通过它进行通信。Java对基于TCP协议的网络通信提供了良好的封装，Java使用Socket对象来代表两端的通信接口，并通过Socket产生IO流来进行网络通信。</p>
<h3 id="TCP协议基础"><a href="#TCP协议基础" class="headerlink" title="TCP协议基础"></a>TCP协议基础</h3><p>IP协议是Internet上使用的一个关键协议，它的全称是Internet Protocol，即Internet协议，简称IP协议。通过使用IP协议，使Internet成为一个允许连接不同类型的计算机和不同的操作系统的网络。<br>要使两台计算机彼此之间进行通信，两台计算机必须使用同一种“语言”，IP协议只保证计算机能发送和接受分组数据。IP协议负责将消息从一个主机传送到另一个主机上，消息在传送的过程中被分割成一个个小包。<br>尽管计算机通过安装IP软件，保证了计算机之间可以发送和接收数据，但IP协议还不能解决数据分组在传输过程中可能出现的问题。因此，若要解决可能出现的问题，连接上Internet的计算机还需要安装TCP协议来提供可靠并且无差错的通信服务。<br>TCP协议被称为一种端对端协议。这是因为它为两台计算机之间的连接起了重要作用：当一台计算机需要与另一台远程计算机连接时，TCP协议会让它们建立一个连接——用于发送和接收数据的虚拟链路。<br>TCP协议负责收集这些信息包，并将其按适当的次序放好发送，在接收端收到后再将其正确地还原。TCP协议保证了数据包在传送中准确无误。TCP协议使用重发机制：当一个通信实体发送一个消息给另一个通信实体之后，需要收到另一个通信实体的确认信息，如果没有收到另一个通信实体的确认信息，则会再次重发刚才发送的消息。</p>
<h3 id="使用ServerSocket创建TCP服务器端"><a href="#使用ServerSocket创建TCP服务器端" class="headerlink" title="使用ServerSocket创建TCP服务器端"></a>使用ServerSocket创建TCP服务器端</h3><p>Java中能接收其他通信实体连接请求的类是ServerSocket，ServerSocket对象用于监听来自客户端的Socket连接，如果没有连接，它将一直处于等待状态。ServerSocket包含一个监听来自客户端连接请求的方法：</p>
<ul>
<li>Socket accept()：如果接收到一个客户端Socket的连接请求，该方法将返回一个与连接客户端Socket对应的Socket；否则该方法将一直处于等待状态，线程也被阻塞</li>
<li>ServerSocket(int port)：用指定的端口port来创建一个ServerSocket。该端口有效整数值：0~65535</li>
<li>ServerSocket(int port,int backlog）：增加一个用来改变连接队列长度的参数backlog</li>
<li>ServerSocket(int port,int backing,InetAddress localAddr)：在机器存在多个IP地址的情况下，允许通过localAddr这个参数来指定将该ServerSocket绑定到指定的IP地址</li>
</ul>
<p>当ServerSocket使用完毕后，调用close（）方法来关闭该ServerSocket。</p>
<h3 id="使用Socket进行通信"><a href="#使用Socket进行通信" class="headerlink" title="使用Socket进行通信"></a>使用Socket进行通信</h3><p>客户端通常使用Socket的构造器来连接到指定服务器，Socket通常可提供如下两个构造器。 </p>
<ul>
<li>Socket(InetAddress/String remoteAddress,int port)：创建连接到指定远程主机、远程端口的Socket，该构造器没有指定本地地址、本地端口，默认使用本地主机的默认IP地址，默认使用系统动态分配的端口</li>
<li>Socket(InetAddress/String remoteAddress,int port,InetAddress localAddr,int localPort)：创建连接到指定远程主机、远程端口的Socket，并指定本地IP地址和本地端口，适用于本地主机有多个IP地址的情形</li>
</ul>
<p>Socket提供了如下两个方法来获取输入流和输出流：</p>
<ul>
<li>InputStream getInputStream()：返回该Socket对象对应的输入流，让程序通过该输入流从Socket中取出数据</li>
<li>OutputStream getOutputStream()：返回该Socket对象对应的输入流，让程序通过该输入流向Socket中输入数据</li>
</ul>
<p>Android已经不允许在UI线程中建立网络连接，需要启动新线程来建立网络连接。</p>
<h3 id="加入多线程"><a href="#加入多线程" class="headerlink" title="加入多线程"></a>加入多线程</h3><p>使用传统的BufferedReader的readLine()方法读取数据时，在该方法成功返回之前，线程被阻塞，程序无法继续执行。考虑到这个原因，服务器应该为每个Socket单独启动一条线程，每条线程负责与一个客户端进行通信。<br>客户端读取服务器的线程同样会被阻塞，所以系统应该单独启动一条线程，该线程专门负责读取服务器数据。</p>
<p>每个客户端应该包含两条线程：一条负责生成主界面，响应用户动作，并将用户输入的数据写入Socket对应的输出流中；另一条负责读取Socket对应输入流中的数据（从服务器发送过来的数据），并负责将这些数据在程序界面上显示出来</p>
<h2 id="使用URL访问网络资源"><a href="#使用URL访问网络资源" class="headerlink" title="使用URL访问网络资源"></a>使用URL访问网络资源</h2><p>URL(Uniform Resource Locator)对象代表统一资源定位器，它是指向互联网“资源”的指针。资源可以是简单的文件或目录，也可以是对更复杂的对象的引用，例如对数据库或搜索引擎的查询。通常情况，URL可以有协议名、主机、端口和资源组成，即满足如下格式：<code>protocol://host:port/resourceName</code>我们可以把URL理解成URI的特例，Java的URI不能用于定位任何资源，它的唯一作用就是解析。URL包含一个可打开到达资源的输入流。</p>
<p>URL类提供了多个构造器用于创建URL对象，一旦获得URL对象之后，可以调用如下常用方法来访问该URL对应的资源：</p>
<ul>
<li>String getFile()：获取此URL的资源名</li>
<li>String getHost()：获取此URL的主机名</li>
<li>String getPath()：获取此URL的路径部分</li>
<li>int getPort()：获取此URL的端口号</li>
<li>String getProtocol()：获取此URL的协议名称</li>
<li>String getQuery()：获取此URL的查询字符串部分</li>
<li>URLConnection openConnection()：返回一个URLConnection对象，它表示到URL所引用的远程对象的连接</li>
<li>InputStream openStream()：打开与此URL的连接，并返回一个用于读取该URL资源的InputStream</li>
</ul>
<h3 id="使用URL读取网络资源"><a href="#使用URL读取网络资源" class="headerlink" title="使用URL读取网络资源"></a>使用URL读取网络资源</h3><p>URL对象提供的openStream()可以读取该URL资源的InputStream，通过该方法可以非常方便地读取远程资源。</p>
<h3 id="使用URLConnection提交请求"><a href="#使用URLConnection提交请求" class="headerlink" title="使用URLConnection提交请求"></a>使用URLConnection提交请求</h3><p>URL的openConnection()方法将返回一个URLConnection对象，该对象表示应用程序和URL之间的通信连接。程序可以通过URLConnection实例向该URL发送请求，读取URL引用的资源。<br>通常创建一个和URL的连接，并发送请求、读取此URL引用的资源需要如下几个步骤。</p>
<ol>
<li>通过调用URL对象的openConnection()方法来创建URLConnection对象</li>
<li>设置URLConnection的参数和普通请求属性</li>
<li>如果只是发送GET请求，那么使用connect方法建立和远程资源之间的实际连接即可；如果需要发送POST方式的请求，则需要获取URLConnection实例对应的输出流来发送请求参数</li>
<li>远程资源变为可用，程序可以访问远程资源的头字段，或者通过输入流读取远程资源的数据</li>
</ol>
<p>在建立和远程资源的实际连接之前，程序可以通过如下方法来设置请求头字段</p>
<ul>
<li>setAllowUserInteraction：设置该URLConnection的allowUserInteraction请求头字段的值</li>
<li>setDoInput：设置该URLConnection的doInput请求头字段的值</li>
<li>setDoOutput：设置该URLConnection的doOutput请求头字段的值</li>
<li>setIfModifiedSince：设置该URLConnection的ifMOdifiedSince请求头字段的值</li>
<li>setUseCaches：设置该URLConnection的useCaches请求头字段的值，除此之外，还可以使用如下方法来设置或者增加通用的头字段<ul>
<li>setRequestProperty(String key,String value)：设置该URLConnection的key请求头字段的值为value</li>
<li>addRequestProperty(String key,String value)：为该URLConnection的key请求头字段增加value值，该方法并不会覆盖原请求头字段的值，而是将新值追加到原请求头字段中</li>
</ul>
</li>
</ul>
<p>当远程资源可用之后，程序可以使用以下方法来访问头字段和内容</p>
<ul>
<li>Object getContent()：获取该URLConnection的内容</li>
<li>String getHeaderField(String name)：获取指定响应头字段的值</li>
<li>getInputStream()：返回该URLConnection对应的输入流，用于获取URLConnection响应的内容</li>
<li>getOutputStream()：返回该URLConnection对应的输出流，用于向URLConnection发送请求参数</li>
</ul>
<p><strong>PS：如果既要使用输入流来读取URLConnection响应的内容，也要使用输出流发送请求参数，一定要先使用输出流，再使用输入流</strong></p>
<h3 id="使用HttpURLConnection"><a href="#使用HttpURLConnection" class="headerlink" title="使用HttpURLConnection"></a>使用HttpURLConnection</h3><p>HttpURLConnection继承了URLConnection，因此也可用于向指定网站发送GET请求、POST请求。在URLConnection的基础上提供了如下便捷的方法</p>
<ul>
<li>int getResponseCode()：获取服务器的响应代码</li>
<li>String getResponseMessage()：获取服务器的响应信息</li>
<li>String getRequestMethod()：获取发送请求的方法</li>
<li>void setRequestMethod(String method)：设置发送请求的方法</li>
</ul>
<p>为了实现多线程下载，步骤如下：</p>
<ol>
<li>创建URL对象</li>
<li>获取指定URL对象所指向资源的大小（由getContentLength()方法实现），此处用到HttpURLConnection类</li>
<li>在本地磁盘上创建一个与网络资源相同大小的空文件夹</li>
<li>计算每条线程应该下载网络资源的哪个部分（从哪个字节开始，到哪个字节结束）</li>
<li>依次创建、启动多条线程来下载网络资源的指定部分</li>
</ol>
<h3 id="使用Apache-HttpClient"><a href="#使用Apache-HttpClient" class="headerlink" title="使用Apache HttpClient"></a>使用Apache HttpClient</h3><p>在一般情况下，如果只是需要向Web站点的某个简单页面提交请求并获取服务器响应，则完全可以使用前面所介绍的HttpURLConnection完成。但在大多数情况下，Web网页可能没这么简单，这些页面不是通过一个简单的URL就可以访问的，可能需要用户登录，而且具有相应的权限才可以访问该界面。<br>为了更好地处理向Web站点请求，包括处理Session、Cookie等细节问题，Apache开源组织提供了一个HttpClient项目，它是一个简单的HTTP客户端，可以用于发送HTTP请求，接收HTTP响应。但不会缓存服务器的响应，不能执行HTML页面中嵌入的JavaScript代码；也不会对页面内容进行解析和处理。（HttpClient是一个增强的HttpURLConnection）<br>使用HttpClient发送请求、接收响应，步骤：</p>
<ol>
<li>创建HttpClient对象</li>
<li>如果需要发送GET请求，则创建HttpGet对象；如果需要发送POST请求，则创建HttpPost对象</li>
<li>如果需要发送请求参数，则可调用HttpGet、HttpPost共同的setParams(HttpParams params)方法来添加请求参数；对于HttpPost对象而言，也可调用setEntity(HttpEntity entity)方法来设置请求参数</li>
<li>调用HttpClient对象的execute(HttpUriRequest request)方法发送请求，执行该方法返回一个HttpResponse</li>
<li>调用HttpResponse的getAllHeaders()、getHeaders(String name)等方法可获取服务器的响应头；调用HttpResponse的getEntity()方法可获取HttpEntity对象，该对象包装了服务器的响应内容。程序可通过该对象获取服务器的响应内容</li>
</ol>
<p>程序只要第一次通过HttpClient登录系统，接下来即可通过该HttpClient访问被保护的资源。</p>
<h3 id="使用WebView浏览网页"><a href="#使用WebView浏览网页" class="headerlink" title="使用WebView浏览网页"></a>使用WebView浏览网页</h3><p>WebView的用法与普通ImageView组件的用法基本相似，它提供了大量方法来执行浏览器操作，例如如下常用方法：</p>
<ul>
<li>void goBack()：后退</li>
<li>void goForward()：前进</li>
<li>void loadUrl(String url)：加载指定URL对应的网页</li>
<li>boolean zoomln()：放大网页</li>
<li>boolean zoomOut()：缩小网页</li>
</ul>
<p>通过WebView的loadUrl()方法来加载显示指定URL对应的页面</p>
<h3 id="使用WebView加载HTML代码"><a href="#使用WebView加载HTML代码" class="headerlink" title="使用WebView加载HTML代码"></a>使用WebView加载HTML代码</h3><p>WebView提供了一个loadData(String data,String mimeType,String encoding)方法，该方法用于加载并显示HTML代码。但在实际使用过程中，当它加载包含中文的HTML内容时，WebView将会显示乱码。<br>不过loadDataWithBaseURL(String baseUrl,String data,String mimeType,String encoding,String historyUrl)方法，该方法是loadData(String data,String mimeType,String encoding)方法的增强版，他不会产生乱码。</p>
<p>参数：</p>
<ul>
<li>data：指定需要加载的HTML代码</li>
<li>mimeType：指定HTML代码的MIME类型，对于HTML代码可指定为text/html</li>
<li>encoding：指定HTML代码编码所使用的字符集，比如GBK</li>
</ul>
<h3 id="使用WebView中的JavaScript调用Android方法"><a href="#使用WebView中的JavaScript调用Android方法" class="headerlink" title="使用WebView中的JavaScript调用Android方法"></a>使用WebView中的JavaScript调用Android方法</h3><p>很多时候，WebView加载的页面是带有JavaScript脚步的，比如页面上有一个按钮，用户单击按钮时将会弹出一个提示框，或打开一个列表框。由于该按钮是HTML页面上的按钮，它只能激发一段JavaScript脚步，这就要让JavaScript脚步来调用Android方法。<br>在WebView的JavaScript中调用Android方法只要如下三个步骤：</p>
<ol>
<li>调用WebView关联的WebSettings的setJavaScriptEnabled(true)启用JavaScript调用功能</li>
<li>调用WebView的addJavascriptInterface(Object object,String name)方法将object对象暴露给JavaScript脚步</li>
<li>在JavaScript脚本中通过刚才暴露的name对象调用Android方法</li>
</ol>
<p>JavaScript脚本可以直接调用Java对象的方法</p>
<h2 id="使用Web-Service进行网络编程"><a href="#使用Web-Service进行网络编程" class="headerlink" title="使用Web Service进行网络编程"></a>使用Web Service进行网络编程</h2><p>为了让Android应用与远程服务器进行交互，可以借助于Java的RMI技术，但这要求远程服务器程序必须采用Java实现；也可以借助于CORBA技术，但是这种技术显得过于复杂。除此之外，Web Service是一种不错的选择。</p>
<h3 id="Web-Service平台概述"><a href="#Web-Service平台概述" class="headerlink" title="Web Service平台概述"></a>Web Service平台概述</h3><p>Web Service平台主要涉及的技术有SOAP（Simple Object Access Protocol，简单对象访问协议）,WSDL（Web Service Description Language，Web Service描述语言）,UDDI（Universal Description,Description and Integration，统一描述、发现和整合协议）</p>
<ol>
<li><p>SOAP是一种具有扩展性的XML消息协议。SOAP允许一个应用程序向另一个应用程序发送XML消息，SOAP消息是从SOAP发送者传至SOAP接收者的单路消息，任何应用程序均可作为发送者或接收者。SOAP仅定义消息结构和消息处理的协议，与底层的传输协议独立。因此，SOAP协议能通过HTTP,JMS,SMTP协议传输</p>
<ul>
<li>&lt;Envelope…/&gt;根元素，SOAP消息对应的XML文档以该元素作为根元素</li>
<li>可选的&lt;Header../&gt;元素，包含SOAP消息的头信息</li>
<li>必须的&lt;Body../&gt;元素，包含所有的调用和响应信息</li>
</ul>
</li>
<li><p>WSDL使用XML描述Web Service，包括访问和使用Web Service所必须的信息，定义该Web Service的位置、功能及如何通信等描述信息</p>
<ul>
<li>WHAT部分：用于定义Web Service所提供的操作或者方法。由WSDL中&lt;type../&gt;,&lt;message../&gt;和&lt;portType../&gt;元素定义</li>
<li>HOW部分：用于定义如何访问Web Service，包括数据格式详情和访问Web Service操作的必要协议</li>
<li>WHERE部分：用于定义Web Service位于何处。该部分使用&lt;service…/&gt;元素定义</li>
</ul>
</li>
<li><p>UDDI是一套信息注册规范，它基于Web，是分布式。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/23/8.23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="法外狂徒罗某人">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="罗某">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/23/8.23/" itemprop="url">Android学习（三十九之多媒体应用开发）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-23T11:47:09+08:00">
                2018-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="安卓基础"><a href="#安卓基础" class="headerlink" title="安卓基础"></a>安卓基础</h1><h2 id="音频和视频的播放"><a href="#音频和视频的播放" class="headerlink" title="音频和视频的播放"></a>音频和视频的播放</h2><h3 id="使用MediaPlayer播放音频"><a href="#使用MediaPlayer播放音频" class="headerlink" title="使用MediaPlayer播放音频"></a>使用MediaPlayer播放音频</h3><p>当程序控制MediaPlayer对象装载音频完成之后，程序可以调用MediaPlayer的如下三个方法进行播放控制：</p>
<ul>
<li>start()：开始或恢复播放</li>
<li>stop()</li>
<li>pause()</li>
</ul>
<p>为了让MediaPlayer来装载指定音频文件，MediaPlayer提供了如下简单的静态方法：</p>
<ul>
<li>static MediaPlayer create(Context context,Uri uri)：从指定Uri来装载音频文件，并返回新创建的MediaPlayer对象</li>
<li>static MediaPlayer create(Context context,int resid)：从resid资源ID对应的资源文件中装载音频文件，并返回新创建的MediaPlayer对象</li>
</ul>
<p>上面两个方法不适用于MediaPlayer循环播放多个音频文件，因为每次都会返回新创建的MediaPlayer对象。此时可通过MediaPlayer的setDataSource()方法来装载指定的音频文件。MediaPlayer提供了如下方法：</p>
<ul>
<li>setDataSource(String path)：指定装载path路径下所代表的文件</li>
<li>setDataSource(FileDescriptor fd,long offset,long length)：指定装载fd所代表的文件中从offset开始、长度为length的文件内容</li>
<li>setDataSource(FileDescriptor fd)：指定装载fd所代表的文件</li>
<li>setDataSource(Context context,Uri uri)：指定装载uri所代表的文件</li>
</ul>
<p>执行了上面的setDataSource（）方法后，MediaPlayer并未真正去装载那些音频文件，还需要调用MediaPlayer的prepare（）方法去真正装载音频文件。</p>
<p>MediaPlayer还提供了一些绑定事件监听器的方法，用于监听MediaPlayer播放过程中所发生的特定事件。绑定事件监听器的方法如下：</p>
<ul>
<li>setOnCompletionListener(MediaPlayer.OnCompletionListener listener)：为MediaPlayer的播放完成事件绑定事件监听器</li>
<li>setOnErrorListener(MediaPlayer.OnErrorListener listener)：为MediaPlayer的播放错误事件绑定事件监听器</li>
<li>setOnPreparedListener(MediaPlayer.OnpreparedListener listener)：当MediaPlayer调用prepare()方法时触发该监听器</li>
<li>setOnSeekCompleteListener(MediaPlayer.OnSeekCompleteListener listener)：当MediaPlayer调用seek()方法时触发该监听器</li>
</ul>
<p>1.播放应用的资源文件，播放应用的资源文件需要两步（音频资源文件一般放在Android应用中的/res/raw目录下）：</p>
<ol>
<li>调用MediaPlayer的creat（Context Context,int resid）方法装载指定的资源文件</li>
<li>调用MediaPlayer的start(),pause(),stop()等方法控制播放即可</li>
</ol>
<p>2.播放应用的原始资源文件：</p>
<ol>
<li>调用Context的getAssets（）方法获取应用的AsserManager</li>
<li>调用AssetManager对象的openFd（String name）方法打开指定的原始资源文件，该方法返回一个AssetFileDescriptor对象</li>
<li>调用AssetFileDescriptor的getFileDescriptor（）、getStartOffset（）、getLength（）方法来获取音频文件的FileDescriptor、开始位置、长度等。</li>
<li>创建MediaPlayer对象，并调用MediaPlayer对象的setDataSource(FileDescriptor fd,long offset,long length)方法来装载音频资源</li>
<li>调用MediaPlayer对象的prepare（）方法准备音频</li>
<li>调用MediaPlayer的start（），pause（），stop（）方法控制播放</li>
</ol>
<p>3.播放外部存储器上的音频文件</p>
<ol>
<li>创建MediaPlayer对象，并调用MediaPlayer对象的setDataSource（String path）方法装载指定的音频文件</li>
<li>调用MediaPlayer对象的prepare（）方法准备音频</li>
<li>调用MediaPlayer的start（），pause（），stop（）方法控制播放</li>
</ol>
<p>4.播放来自网络的音频文件</p>
<p>方式：①直接使用MediaPlayer的静态create（Context context，Uri uri<br>）方法②调用MediaPlayer的setDataSource(Context context,Uri uri)方法装载指定Uri对应的音频文件</p>
<p>以第二种方式播放来自网络的音频文件的步骤如下：</p>
<ol>
<li>根据网络的音频文件所在的文字创建Uri对象</li>
<li>创建MediaPlayer对象，并调用MediaPlayer对象的setDataSource(Context context,Uri uri)方法装载Uri对应的音频文件</li>
<li>调用MediaPlayer对象的prepare（）方法准备音频</li>
<li>调用MediaPlayer的start（），pause（），stop（）方法控制播放</li>
</ol>
<p>MediaPlayer除了调用prepare（）方法来准备声音之外，还可以调用prepareAsync（）来准备声音。prepareAsync（）是异步的，他不会阻塞当前的UI进程</p>
<p>MediaPlayer的状态图：</p>
<p><img src="https://developer.android.com/images/mediaplayer_state_diagram.gif" alt="MediaPlayer状态图"></p>
<h3 id="音乐特效控制"><a href="#音乐特效控制" class="headerlink" title="音乐特效控制"></a>音乐特效控制</h3><p>Android播放音乐的均衡器靠AudioEffect及其子类完成的。它的子类如下：</p>
<ul>
<li>AcousticEchoCanceler：取消回声控制器</li>
<li>AutomaticGainControl：自动增益控制器</li>
<li>NoiseSuppressor：噪声压制控制器</li>
<li>BassBoost：重低音控制器（setStrength（short strength）方法来设置重低音的强度）</li>
<li>Equalizer：均衡控制器（getNumberOfPresets()方法获取该均衡器所有预设的音场并提供了getPresetName()方法获取预设音场名称。获取Equalizer对象后，可调用它的getNumberOfBands()方法获取该均衡器支持的总频率，再调用getCenterFreq(short band)方法根据索引来获取频率。当用户想为某个频率的均衡器设置参数值时，可调用setBandLevel(Short band,short level)方法进行设置</li>
<li>PresetReverb：预设音场控制器（调用setPreset(short preset)方法设置使用预设置的音场。</li>
<li>Visualizer：示波器（它不用于控制音乐播放效果，他只是显示音乐的播放波形。为了实时显示该示波器的数据需要为该组件设置一个OnDataCaptureListener监听器，该监听器将负责更新波形显示组件的界面）</li>
</ul>
<p>上述前三个子类的用法很简单，只要调用它们的静态create（）方法创建相应的实例，然后调用它们的isAvailable（）方法判断是否可用，再调用setEnabled（boolean enable）方法启动相应效果即可。</p>
<p>后四个类，都需要调用构造器来创建实例。创建实例时，同样需要传入一个audioSession参数，为了启用他们，同样需要调用AudioEffect基类的setEnabled（true）方法。</p>
<h3 id="使用SoundPool播放音效"><a href="#使用SoundPool播放音效" class="headerlink" title="使用SoundPool播放音效"></a>使用SoundPool播放音效</h3><p>MediaPlayer存在如下缺点：</p>
<ul>
<li>资源占用量较高，延迟时间较长</li>
<li>不支持多个音频同时播放</li>
</ul>
<p>Android系统SoundPool提供了一个Builder内部类，该内部类专门用于创建SoundPool。<br>SoundPool提供了如下4个load()重载方法：</p>
<ul>
<li>int load(Context context,int resId,int priority)：从resId所对应的资源加载声音</li>
<li>int load(FileDescriptor fd,long offset,long length,int priority)：加载fd所对应的文件中从offset开始、长度为length的声音</li>
<li>int load(AssetFileDescriptor afd,int priority)：从afd所对应的文件中加载声音</li>
<li>int load(String path,int priority)：从path对应的文件去加载声音</li>
</ul>
<p>该priority参数目前没有任何作用，Android建议将该参数设为1，保持和未来的兼容性。上面4个方法加载声音之后，都会返回该声音的ID，以后程序就可以通过该声音的ID来播放指定声音了。SoundPool提供的播放指定声音的方法如下：</p>
<ul>
<li>int play(int soundID,float leftVolume,float rightVolume,int priority,int loop,float rate)：该方法的第一个参数指定播放哪个声音；priority指定播放声音的优先级，数值越大，优先级越高；loop指定是否循环，0为不循环，-1为循环；rate指定播放的比率，数字可从0.5到2,1为正常比率。</li>
</ul>
<p>归纳起来，使用SoundPool播放声音的步骤如下：</p>
<ol>
<li>调用SoundPool.Builder的构造器创建SoundPool.Builder对象，并可通过该Builder对象为SoundPool设置属性</li>
<li>调用SoundPool的构造器创建SoundPool对象</li>
<li>调用SoundPool对象的load()方法从指定资源、文件中加载声音。最好使用HashMap&lt;Integer,Integer&gt;来管理所加载的声音</li>
<li>调用SoundPool的play()方法播放声音</li>
</ol>
<p>实际使用SoundPool播放声音时有如下几点需要注意：SoundPool虽然可以一次性加载多个声音，但由于内存限制，因此避免使用SoundPool来播放歌曲或者做游戏背景音乐，只有那些短促、密集的声音才考虑用SoundPool进行播放。</p>
<h3 id="使用VideoView播放视频"><a href="#使用VideoView播放视频" class="headerlink" title="使用VideoView播放视频"></a>使用VideoView播放视频</h3><p>使用步骤：</p>
<ol>
<li>在界面布局文件中定义VideoView组件，或者在程序中创建VideoView组件</li>
<li>调用VideoView的如下两个方法来加载指定视频<ul>
<li>setVideoPath(String path)</li>
<li>setVideoUri(Uri uri)</li>
</ul>
</li>
<li>调用VideoView的start(),stop(),pause()方法来控制视频播放</li>
</ol>
<p>实际上与VideoView结合使用的还有一个MediaController类，它提供一个友好的图形控制界面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//获得对象</span><br><span class="line">MediaController mController = new MediaController(this);</span><br><span class="line">//设置videoView与mController建立关联</span><br><span class="line">videoView.setVideoPath(video.getAbsolutePath());</span><br><span class="line">videoView.setMediaController(mController);</span><br><span class="line">mController.setMediaPlayer(videoView);</span><br><span class="line">videoView.requestFocus();</span><br></pre></td></tr></table></figure>
<h3 id="使用MediaRecorder录制音频"><a href="#使用MediaRecorder录制音频" class="headerlink" title="使用MediaRecorder录制音频"></a>使用MediaRecorder录制音频</h3><p>使用步骤：</p>
<ol>
<li>创建MediaRecorder对象</li>
<li>调用MediaRecorder对象的setAudioSoruce()方法设置声音来源，一般传入MediaRecorder.AudioSource.MIC参数指定录制来自麦克风的声音</li>
<li>调用MediaRecorder对象的setOutputFormat()方法设置所录制的音频文件格式</li>
<li>调用MediaRecorder对象的setAudioEncoder(),setAudioEncodingBitRate(int bitRate),setAudioSamplingRate(int samplingRate)方法设置所录制的声音编码格式、编码位率、采样率等，这些参数将可以控制所录制的声音品质、文件大小。一般来说，声音品质越好，声音文件越大</li>
<li>调用MediaRecorder的setOutputFile(String path)方法设置所录制的音频文件的保存位置</li>
<li>调用MediaRecorder的prepare()方法准备录制</li>
<li>调用MediaRecorder对象的start()方法开始录制</li>
<li>录制完成，调用MediaRecorder对象的stop()方法停止录制，并调用release()方法释放资源</li>
</ol>
<p><strong>ps：第三步和第四步不能反；需要录制声音的权限和向外部存储器写入数据的权限</strong></p>
<p>MediaRecorder的状态图：</p>
<p><img src="https://images0.cnblogs.com/blog/234895/201311/24234720-7b799f27675941dab22ea49a643dab69.gif" alt="MediaRecorder的状态图"></p>
<h2 id="控制摄像头拍照"><a href="#控制摄像头拍照" class="headerlink" title="控制摄像头拍照"></a>控制摄像头拍照</h2><h3 id="使用Android5-0的Camera-v2拍照"><a href="#使用Android5-0的Camera-v2拍照" class="headerlink" title="使用Android5.0的Camera v2拍照"></a>使用Android5.0的Camera v2拍照</h3><p>Android5.0的Camera v2涉及如下API：</p>
<ul>
<li>CameraManager：摄像头管理器</li>
<li>CameraCharacteristics：摄像头特性</li>
<li>CameraDevice：代表系统摄像头</li>
<li>CameraCaptureSession：这是一个非常重要的API，当程序需要预览、拍照时，都需要先通过该类的实例创建Session。该对象控制预览的方法为setRepeatingRequest()；控制拍照的方法为capture()</li>
<li>CameraRequest和CameraRequest.Builder：当程序调用setRepeatingRequest()方法进行预览时，或调用capture()方法进行拍照时，都需要传入CameraRequest参数</li>
</ul>
<h3 id="录制视频短片"><a href="#录制视频短片" class="headerlink" title="录制视频短片"></a>录制视频短片</h3><p>MediaRecorder还可用于录制视频。为了让MediaRecorder录制时采集图像，应该在调用setAudioSource(int audio_source)方法时再调用setVideoSource(int video_source)方法来设置图像来源</p>
<h2 id="Android-5-0-新增的屏幕捕捉"><a href="#Android-5-0-新增的屏幕捕捉" class="headerlink" title="Android 5.0 新增的屏幕捕捉"></a>Android 5.0 新增的屏幕捕捉</h2><p>Android 5.0 新增了MediaProjectionManager管理器，该管理器可以非常方便地实现了屏幕捕捉功能。<br>使用步骤：</p>
<ol>
<li>以MEDIA_PROJECTION_SERVICE为参数，调用Context.getSystemService()方法即可获取MediaProjectionManager实例</li>
<li>调用MediaProjectionManager对象的createScreenCaptureIntent()方法创建一个屏幕捕捉的Intent</li>
<li>调用startActivityForResult()方法启动第2步得到的Intent，这样即可启动屏幕捕捉的Intent</li>
<li>重写onActivityResult()方法，在该方法中通过MediaProjectionManager对象来获得MediaProjection对象，在该对象中即可获取被捕捉的屏幕</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/22/8.22.2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="法外狂徒罗某人">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="罗某">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/22/8.22.2/" itemprop="url">Android学习（三十八之使用Service与BroadcastReceiver）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-22T22:13:42+08:00">
                2018-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="安卓基础"><a href="#安卓基础" class="headerlink" title="安卓基础"></a>安卓基础</h1><h2 id="接受广播消息"><a href="#接受广播消息" class="headerlink" title="接受广播消息"></a>接受广播消息</h2><p>BroadcastReceiver本质上就是一个全局监听器，用于监听系统全局的广播消息。由于BroadcastReceiver是一个全局监听器，因此它可以非常方便地实现系统中不同组件之间的通信。</p>
<h3 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h3><p>BroadcastReceiver用于接受程序（包括用户开发的程序和系统内建的程序）所发出的Broadcast Intent，与应用程序启动Activity、Service相同的是，程序启动BroadcastReceiver也只需要两步：</p>
<ol>
<li>创建需要启动的BroadcastReceiver的Intent</li>
<li>调用Context的sendBroadcast()或sendOrderedBroadcast()方法来启动指定的BroadcastReceiver</li>
</ol>
<p>与Activity、Service具有完整的生命周期不同，BroadcastReceiver本质上只是一个系统级的监听器——它专门负责监听各程序所发出的Broadcast。<br>前面介绍的各种OnXxxListener只是程序级别的监听器，这些监听器运行在指定程序所在进程中，当程序退出时，OnXxxListener监听器也就随之关闭了。但BroadcastReceiver属于系统级的监听器，他拥有自己的进程，只要存在与之匹配的Intent被广播出来，BroadcastReceiver就会被激发。<br>实现BroadcastReceiver的方法十分简单，只要重写BroadcastReceiver的onReceive(Context context,Intent intent)方法即可。<br>一旦实现了BroadcastReceiver，接下来就应该指定该BroadcastReceiver能匹配的Intent，此时有两种方式：</p>
<ul>
<li>使用代码进行指定，调用BroadcastReceiver的Context的registerReceiver(BroadcastReceiver receiver,IntentFilter filter)方法指定</li>
<li>在AndroidManifest.xml中配置。例如如下代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;.IncomingSMSReceiver&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">       &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot;/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>
<p>每次系统Broadcast事件发生后，系统就会创建相应的BroadcastReceiver实例，并自动触发它的onReceive()方法，onReceive()方法执行完之后，BroadcastReceiver实例就会被销毁。<br>如果BroadcastReceiver的onReceive（）方法不能再10秒内执行完成，Android会认为该程序无响应。所以不要在BroadcastReceiver的onReceive（）方法里执行一些耗时的操作；否则就会弹出ANR（Application No Response）对话框。<br>**如果确实需要根据Broadcast来完成一项比较耗时的操作，则可以考虑通过Intent启动一个Service来完成该操作。不应考虑使用新线程去完成耗时的操作，因为BroadcastReceiver本身的生命周期就很短，可能出现的情况是子线程可能还没有结束，BroadcastReceiver就已经退出了。虽然该进程内还有用户启动的新线程，但由于该进程内不包含任何活动组件，因此系统可能在内存紧张时优先结束该进程。这样就可能导致BroadcastReceiver启动的子线程不能执行完成。</p>
<h3 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h3><p>只要调用Context的sendBroadcast(Intent intent)方法即可，这条广播将会启动intent参数对应的BroadcastReceiver。</p>
<h3 id="有序广播"><a href="#有序广播" class="headerlink" title="有序广播"></a>有序广播</h3><p>Broadcast分为两种：</p>
<ul>
<li>Normal Broadcast(普通广播)：Normal Broadcast是完全异步的，可以在同一时刻（逻辑上）被所有接受者接收到，消息传递的效率比较高。缺点是接受者不能将处理结果传递给下一个接收者，并且无法终止Broadcast Intent的传播</li>
<li>Ordered Broadcast(有序广播)：Ordered Broadcast的接受者将按预先声明的优先级高低依次接收Broadcast。优先级别声明在&lt;intent-filter…/&gt;元素的android:priority属性中，数越大优先级别越高，取值范围为-1000~1000；也可以调用IntentFilter对象的setPriority（）设置优先级别。Ordered Broadcast接收者可以终止Broadcast Intent的传播，Broadcast Intent传播一旦终止，后面的接收者就无法接收到Broadcast。另外，OrderedBroadcast的接受者可以将数据传递给下一个接收者。</li>
</ul>
<p>对于Ordered Broadcast而言，调用BroadcastReceiver的abortBroadcast()方法即可终止Broadcast；优先接受到Broadcast的接收者可以通过setResultExtras(Bundle)方法将处理结果存入Broadcast中，然后传给下一个接收者，下一个接收者通过代码Bundle bundle = getResultExtras(true)可以获取上一个接收者存入的数据。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>比如程序有一个Activity和Service，而且Service是通过startService（）方法气动的，正常情况下，这个Activity与通过startService（）方法启动的Service之间无法通信，但借助BroadcastReceiver的帮助，程序就可以实现两者之间的通信。</p>
<p><strong>PS：对于BroadcastReceiver程序实现过程：①当实现sendBroadcast（intent）方法 ②与之intent对应绑定的BroadcastReceiver会被自动调用。</strong></p>
<h2 id="接收系统广播消息"><a href="#接收系统广播消息" class="headerlink" title="接收系统广播消息"></a>接收系统广播消息</h2><p>除了可以接收用户发送的广播之外，还可以接收系统广播。<br>Android的大量系统事件会对外发送标准广播。下面是Android常见的广播Action常量：</p>
<ul>
<li>ACTION_TIME_CHANGED：系统时间被改变</li>
<li>ACTION_DATE_CHANGED：系统日期被改变</li>
<li>ACTION_TIMEZONE_CHANGED：系统时区被改变</li>
<li>ACTION_BOOT_COMPLETED：系统启动完成</li>
<li>ACTION_PACKAGE_ADDED：系统添加包</li>
<li>ACTION_PACKAGE_CHANGED：系统包的改变</li>
<li>ACTION_PACKAGE_REMOVED：系统包的删除</li>
<li>ACTION_PACKAGE_RESTARTED：系统的包被重启</li>
<li>ACTION_PACKAGE_DATA_CLEARED：系统的包数据被清空</li>
<li>ACTION_BATTERY_CHANGED：电池电量改变</li>
<li>ACTION_BATTERY_LOW：电池电量低</li>
<li>ACTION_POWER_CONNECTED：系统连接电源</li>
<li>ACTION_POWWER_DISCONNECTED：系统与电源断开</li>
<li>ACTION_SHUTDOWN：系统被关</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/22/8.22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="法外狂徒罗某人">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="罗某">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/22/8.22/" itemprop="url">Android学习（三十七之使用Service与BroadcastReceiver）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-22T12:04:57+08:00">
                2018-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="安卓基础"><a href="#安卓基础" class="headerlink" title="安卓基础"></a>安卓基础</h1><h3 id="Service的生命周期"><a href="#Service的生命周期" class="headerlink" title="Service的生命周期"></a>Service的生命周期</h3><p>Service生命周期图：<br><img src="https://upload-images.jianshu.io/upload_images/944365-cf5c1a9d2dddaaca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/456" alt="Service生命周期"></p>
<p>与多次调用startService()方法启动Service，就多次回调Service的onStartCommand()方法不同的是，多次调用bindService()方法并不会重复绑定，且只会回调一次onBind()方法。</p>
<p><strong>当Activity调用bindService()绑定一个已启动的Service时</strong>，系统只是把Service内部IBinder对象传给Activity，并不会把该Service生命周期完全“绑定”到该Activity，因而当Activity调用unBindService()方法取消与该Service的绑定时，也只是切断该Activity与Service之间的关联，并不能停止该Service组件。</p>
<h3 id="使用IntentService"><a href="#使用IntentService" class="headerlink" title="使用IntentService"></a>使用IntentService</h3><p>IntentService是Service的子类。<br>Service本身存在两个问题：</p>
<ul>
<li>Service不会专门启动一个单独的进程，Service与它所在应用位于同一个进程中。</li>
<li>Service不是一条新的线程，因此不应该在Service中直接处理耗时任务。</li>
</ul>
<p>如果开发者需要在Service中处理耗时任务，建议在Service中另外启动一条新的线程来处理该耗时任务。<br>直接在其他程序组件中启动子线程来处理耗时任务不行吗？这种方式也不可靠，由于Activity可能会被用户退出，而BroadcastReceiver的生命周期本来就很短。可能出现：在子线程还没有结束的情况下，Activity就已经被用户退出了，或者BroadcastReceiver已经结束了。在Activity已经退出、BroadcastReceiver已经结束的情况下，此时他们所在的进程就变成了空进程（没有任何活动组件的进程），系统需要内存时可能会优先终止该进程。如果宿主进程被终止，那么该进程内的所有子线程也会被终止，这样就可能导致子线程无法执行完成。<br>而IntentService正好可以弥补Service的上面的两个不足：<strong>IntentService将会使用队列来管理请求Intent，每当客户端代码通过Intent请求启动IntentService时，IntentService会将该Intent加入队列中，然后开启一条新的worker线程来处理该Intent。对于异步的startService()请求，IntentService会按次序依次处理队列中的Intent，该线程保证同一时刻只处理一个Intent。由于IntentService使用新的worker线程处理Intent请求，因此IntentService不会阻塞主线程，所以IntentService自己就可以处理耗时任务。</strong><br>归纳起来，IntentService有如下特征：</p>
<ul>
<li>IntentService会创建单独的worker线程来处理所有的Intent请求</li>
<li>IntentService会创建单独的worker线程来处理onHandleIntent()方法实现的代码，因此开发者无须处理多线程问题</li>
<li>当所有请求处理完成后，IntentService会自动停止，因此开发者无须调用stopSelf()方法来停止该Service</li>
<li>为Service的onBind()方法提供了默认实现，默认实现的onBind()方法返回null</li>
<li>为Service的onStartCommand()方法提供了默认实现，该实现将请求Intent添加到队列中</li>
</ul>
<p>扩展IntentService实现Service无须重写onBind()和onStartCommand()方法，只要重写onHandleIntent()方法即可，在该方法中定义该Service需要完成的任务。</p>
<p>如果用继承Service子类的MyService来执行耗时操作，会导致UI线程阻塞（ANR异常）。</p>
<h2 id="电话管理器（TelephonyManager）"><a href="#电话管理器（TelephonyManager）" class="headerlink" title="电话管理器（TelephonyManager）"></a>电话管理器（TelephonyManager）</h2><p>TelephonyManager是一个管理手机通话状态、电话网络信息的服务类，该类提供了大量getXxx()方法获取网络状态和SIM卡的相关信息。<br>在程序中获取TelephonyManager：<code>TelephonyManager tManager = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE)</code></p>
<p>TelephonyManager还提供了一个listen(PhoneStateListener listener,int events)方法来监听通话状态。程序中要首先取得TelephonyManager对象，再创建一个PhoneStateListener，它是一个通话状态监听器，该监听器可用于对TelephonyManager进行监听。</p>
<p>##短信管理器（SmsManager）</p>
<p>SmsManager提供了一系列sendXxxMessage()方法用于发送短信，发送普通文本内容调用sendTextMessage()方法即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//获取SmsManager</span><br><span class="line">sManager = SmsManager.getDefault()</span><br><span class="line">//创建一个PendingIntent对象</span><br><span class="line">PendingIntent pi = PengingIntent.getActivity(MainActivity.this,0,new Intent(),0)</span><br><span class="line">//发送短信</span><br><span class="line">sManager.sendTextManage(number.getText().toString(),null,content.getText().toString(),pi,null)</span><br></pre></td></tr></table></figure>
<p><strong>PendingIntent是对Intent的包装，一般通过调用PendingIntent的getActivity()、getService（）、getBroadcastReceiver（）静态方法来获取PendingIntent对象。与Intent对象不同的是，PendingIntent通常会传给其他应用组件，从而有其他应用程序来执行PendingIntent所包装的“Intent”。</strong></p>
<h2 id="音频管理器（AudioManager）"><a href="#音频管理器（AudioManager）" class="headerlink" title="音频管理器（AudioManager）"></a>音频管理器（AudioManager）</h2><p>程序如果需要管理系统音量，或者让系统静音，这就可借助于Android提供的AudioManager来实现。程序一样是调用getSystemService()方法来获取系统的音频管理器。</p>
<h3 id="AudioManager"><a href="#AudioManager" class="headerlink" title="AudioManager"></a>AudioManager</h3><p>AudioManager对象调整手机指定类型的声音的方法：</p>
<ul>
<li>adjustStreamVolume(int streamType,int direction,int flags)。<br>其中第一个参数streamType指定声音类型，它的值如下：<ul>
<li>STREAM_ALARM：闹钟</li>
<li>STREAM_DTMF：DTMF音调的声音</li>
<li>STREAM_MUSIC：音乐</li>
<li>STREAM_NOTIFICATION：系统提示</li>
<li>STREAM_RING：电话铃声</li>
<li>STREAM_SYSTEM：手机系统</li>
<li>STREAM_VOICE_CALL：语音电话</li>
</ul>
</li>
</ul>
<p>第二个参数对声音进行增大或者减小；第三个参数是调整声音时的标志，指定为FLAG_SHOW_UI，则调整声音时显示音量进度条。</p>
<ul>
<li>setMicrophoneMute(boolean on)：设置是否让麦克风静音</li>
<li>setMode(int mode)：设置声音模式，值可为：NORMAL,RINGTONE,IN_CALL</li>
<li><p>setRingerMode(int ringerMode)：设置手机的电话铃声模式。值可为：</p>
<ul>
<li>RINGER_MODE_NORMAL：正常的手机铃声</li>
<li>RINGER_MODE_SILENT：手机铃声静音</li>
<li>RINGER_MODE_VIBRATE：手机振动</li>
</ul>
</li>
<li><p>setSpeakeerphoneOn(boolean on)：设置是否打开扩音器</p>
</li>
<li>setStreamMute(int streamType,boolean state)：将手机的指定类型的声音调整为静音。</li>
<li>setStreamVolume(int streamType,int index,int flags)：直接设置手机的指定类型的音量值。</li>
</ul>
<h2 id="振动器（Vibrator）"><a href="#振动器（Vibrator）" class="headerlink" title="振动器（Vibrator）"></a>振动器（Vibrator）</h2><p>有时候程序需要启动振动器，比如手机静音时使用振动提示用户；当玩游戏时，当系统碰撞、爆炸时使用振动带给用户更逼真的体验。<br>系统获取Vibrator也是调用了context的getSystemService()方法。</p>
<h3 id="Vibrator简介"><a href="#Vibrator简介" class="headerlink" title="Vibrator简介"></a>Vibrator简介</h3><p>Vibrator的使用：</p>
<ul>
<li>vibrate(long milliseconds)：控制手机振动milliseconds毫秒</li>
<li>vibrate(long[] pattern,int repeat)：指定手机以pattern指定的模式振动。例如指定pattern为new int[400,800,1200,1600]，也就是在400ms、800ms、1200ms、1600ms这些时间点交替启动、关闭手机振动器；其中repeat指定pattern数组的索引，指定对pattern数组中从repeat索引开始的振动进行循环</li>
<li>cancel()：关闭手机振动</li>
</ul>
<p>程序控制手机振动需要得到相应的权限，在AndroidManifest.xml文件中加授权代码：`<!-- 授予程序访问振动的权限 --></p>
<p><uses-permission android:name="android.premission.VIBRATE">`</uses-permission></p>
<h2 id="手机闹钟服务（AlarmManager）"><a href="#手机闹钟服务（AlarmManager）" class="headerlink" title="手机闹钟服务（AlarmManager）"></a>手机闹钟服务（AlarmManager）</h2><p>AlarmManager通常用来开发手机闹钟。但是，它的本质是一个全局定时器，AlarmManager可以在指定时间或者指定周期启动其他组件（包括Activity，Service，BroadcastReceiver）。</p>
<h3 id="AlarmManager"><a href="#AlarmManager" class="headerlink" title="AlarmManager"></a>AlarmManager</h3><p>在Android应用程序中也是通过Context的getSystemService()方法来获取AlarmManager对象的。获得AlarmManager对象后，可调用如下方法来设置定时启动指定组件：</p>
<ul>
<li><p>set(int type,long triggerAtTime,PendingIntent operation):设置在triggerAtTime时间启动由operation参数指定的组件。其中第一个参数指定定时服务的类型，该参数有如下值：</p>
<ul>
<li>ELAPSED_REALTIME:指定从现在开始时间过了一定时间后启动operation所对应的组件。</li>
<li>ELAPSED_REALTIME_WAKEUP：指定从现在开始时间过了一定时间后启动operation所对应的组件。即使系统处于休眠状态也会启动相应组件</li>
<li>RTC：指定当系统调用System.currentTimeMillis()方法的返回值与triggerAtTime相等时启动operation所对应的组件</li>
<li>RTC_WAKEUP：指定当系统调用System.currentTimeMillis()方法的返回值与triggerAtTime相等时启动operation所对应的组件。即使系统处于休眠状态也会执行operation所对应的组件</li>
</ul>
</li>
<li><p>setInexactRepeating(int type,long triggerAtTime,long interval,PendingIntent operation):设置一个非精确的周期性任务。</p>
</li>
<li>setRepeating(int type,long triggerAtTime,long interval,PendingIntent operation)：设置一个周期性执行的定时任务</li>
<li>cancel(PendingIntent operation)：取消AlarmManager的定时任务</li>
</ul>
<p>AlarmManager新增的如下两个方法支持精确激发：</p>
<ul>
<li>setExact(int type,long triggerAtMillis,PendingIntent operation)：设置闹钟将在精确的时间被触发</li>
<li>setWindow(int type,long windowStartMillis,long windowLengthMillis,PendingIntent operation)：设置闹钟将在精确的时间段内被触发</li>
</ul>
<h2 id="其他（System-currentTimeMillis-方法）"><a href="#其他（System-currentTimeMillis-方法）" class="headerlink" title="其他（System.currentTimeMillis()方法）"></a>其他（System.currentTimeMillis()方法）</h2><p>在开发过程中，通常很多人都习惯使用new Date()来获取当前时间。new Date()所做的事情其实就是调用了System.currentTimeMillis()。如果仅仅是需要或者毫秒数，那么完全可以使用System.currentTimeMillis()去代替new Date()，效率上会高一点。如果需要在同一个方法里面多次使用new Date()，通常性能就是这样一点一点地消耗掉。<br>System.currentTimeMillis()+3600*1000)可以这样解读：System.currentTimeMillis()相当于是毫秒为单位，但是，后头成了1000，就变成了以秒为单位。那么，3600秒=1小时，所以输出为当前时间的1小时后；<br>我们可以这样控制时间：System.currentTimeMillis()+time*1000)，里面传入的time是以秒为单位，当传入60，则输出：当前时间的一分钟后。</p>
<p>Calendar.getInstance()是获取一个Calendar对象并可以进行时间的计算，时区的指定；Calendar的对象和new Date()对象可以相互转化：Calendar calendar = Calendar.getInstance();Date date = calendar.getTime();</p>
<h2 id="更换壁纸（WallpaperManager）"><a href="#更换壁纸（WallpaperManager）" class="headerlink" title="更换壁纸（WallpaperManager）"></a>更换壁纸（WallpaperManager）</h2><p>它提供了clear()方法来清除壁纸，还提供了如下方法来设置系统的壁纸：</p>
<ul>
<li>serBitmap(Bitmap bitmap)：将壁纸设置为bitmap所代表的位图</li>
<li>setResource(int resid)：将壁纸设置为resid资源所代表的图片</li>
<li>setStream(InputStream data)：将壁纸设置为data数据所代表的图片</li>
</ul>
<h2 id="markdown语法中转义字符"><a href="#markdown语法中转义字符" class="headerlink" title="markdown语法中转义字符"></a>markdown语法中转义字符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\\ 反斜杠</span><br><span class="line">\` 反引号</span><br><span class="line">\* 星号</span><br><span class="line">\_ 下划线</span><br><span class="line">\&#123;\&#125; 大括号</span><br><span class="line">\[\] 中括号</span><br><span class="line">\(\) 小括号</span><br><span class="line">\# 井号</span><br><span class="line">\+ 加号</span><br><span class="line">\- 减号</span><br><span class="line">\. 英文句号</span><br><span class="line">\! 感叹号</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/21/8.21.2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="法外狂徒罗某人">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="罗某">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/21/8.21.2/" itemprop="url">Android学习（三十六之使用Service与BroadcastReceiver）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-21T12:03:44+08:00">
                2018-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="安卓基础"><a href="#安卓基础" class="headerlink" title="安卓基础"></a>安卓基础</h1><p>Service与Activity十分相似，都代表可执行的程序；区别在于：Service一直在后台运行，它没有用户界面，不会到前台来。一旦Service被启动起来，它就与Activity一样，它完全有自己的生命周期。<br>程序中Activity与Service的选择标准是，如果某个程序组件需要在运行时间向用户呈现某种界面，或者该程序需要与用户交互，就需要使用Activity。否则就使用Service。</p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>Service组件也是可执行的程序，它也有自己的生命周期。</p>
<h3 id="创建配置Service"><a href="#创建配置Service" class="headerlink" title="创建配置Service"></a>创建配置Service</h3><p>步骤：</p>
<ol>
<li>定义一个继承Service的子类</li>
<li>在AndroidManifest.xml文件中配置该Service</li>
</ol>
<p>Service和Activity都是从Context派生出来的，因此他们都可调用Context里定义的如getResources(),getContentResolver()等方法。</p>
<p>Service生命周期图：<br><img src="https://upload-images.jianshu.io/upload_images/944365-cf5c1a9d2dddaaca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/456" alt="Service生命周期"></p>
<p>Service生命周期方法：</p>
<ul>
<li>IBinder onBind(Intent intent)：该方法是Service子类必须实现的方法。该方法必须返回一个IBinder对象，应用程序可以通过该对象与Service组件通信。</li>
<li>void onCreate()：在该Service第一次被创建后将会立即回调该方法</li>
<li>void onDestroy()：在该Service被关闭之前回调该方法</li>
<li>void onStartCommand(Intent intent,int flags,int startId)：该方法的早期版本是void onStart(Intent intent,int startId)，每次客户端调用startService(Intent intent)方法启动该Service时都会回调该方法</li>
<li>boolean onUnbind(Intent intent)：当该Service上绑定的所有客户端都断开连接时将会回调该方法</li>
</ul>
<p>在AndroidManifest.xml中配置Service组件：</p>
<figure class="highlight plain"><figcaption><span>配置一个Service组件 --></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;service android:name=&quot;&quot;&gt;</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure>
<p>配置Service无须指定android:label属性——Service没有界面，指定标签意义不大。</p>
<p>在Android系统中运行Service有如下两种方式。</p>
<ul>
<li>通过Context的startService()方法：访问者与Service之间没有关联，即使<br>访问者退出了，Service仍然运行</li>
<li>通过Context的bindService()方法：访问者与Service之间绑定在一起，访问者退出，Service也就终止了</li>
</ul>
<h3 id="启动和停止Service"><a href="#启动和停止Service" class="headerlink" title="启动和停止Service"></a>启动和停止Service</h3><p>调用Context里定义的statService(),stopService()方法即可启动，关闭Service。<br>每当Service被创建时会回调onCreate()方法，每次Service被启动时都会回调onStartCommand()方法——多次启动一个已有的Service组件将不会再回调onCreate()方法，但每次启动时都会回调onStartCommand()方法。</p>
<h3 id="绑定本地Service并与之通信"><a href="#绑定本地Service并与之通信" class="headerlink" title="绑定本地Service并与之通信"></a>绑定本地Service并与之通信</h3><p>当程序通过startService(),stopService()启动，关闭Service时，Service与访问者之间基本上不存在太多的关联，因此Service和访问者之间也无法进行通信、交换数据。<br>如果Service和访问者之间需要进行方法调用或交换数据，则应该使用bindService()和unbindService()方法启动、关闭Service。</p>
<p>Context的bindService()方法的完整方法签名为：bindService(Intent service,ServiceConnection conn,int flags)，该方法的三个参数为：</p>
<ul>
<li>service:通过Intent指定要启动的Service。</li>
<li>conn：该参数是一个ServiceConnection对象，该对象用于监听访问者与Service之间的连接情况。当访问者与Service之间连接成功时回调该ServiceConnection对象的onServiceConnected(ComponentName name,IBinder service)方法，该binder对象即可实现与被绑定Service之间的通信；当Service所在的宿主进程由于异常中止或其他原因终止，导致该Service与访问者之间断开连接时回调该ServiceConnection对象的onServiceDisconnected(ComponentName name)方法。</li>
<li>flags：指定绑定时是否自动创建Service(如果Service还未创建）。该参数可指定为0（不自动创建）或BIND_AUTO_CREATE（自动创建）</li>
</ul>
<p>在开发子类时提供的一个IBinder onBinder(Intent intent)方法，在绑定本地Service的情况下，onBind(Intent intent)方法所返回的IBinder对象将会传给ServiceConnection对象里onServiceConnected(ComponentName name,IBinder service)方法的service参数，这样访问者就可以通过该IBinder对象与Service进行通信了。<br>IBinder对象相当于Service组件的内部钩子，该钩子关联到绑定的Service组件，当其他程序组件绑定到该Service时，Service将会把该IBinder对象返回给其他程序组件，其他程序组件通过该IBinder对象即可与Service组件进行实时通信。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/21/8.21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="法外狂徒罗某人">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="罗某">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/21/8.21/" itemprop="url">Android学习（三十五之使用ContentProvider实现数据共享）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-21T09:02:26+08:00">
                2018-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="安卓基础"><a href="#安卓基础" class="headerlink" title="安卓基础"></a>安卓基础</h1><p>###使用ContentProvider管理多媒体内容</p>
<p>Android为多媒体提供的ContentProvider的Uri如下：</p>
<ul>
<li>MediaStore.Audio.Media.EXTERNAL_CONTENT_URI</li>
<li>MediaStore.Audio.Media.INTERNAL_CONTENT_URI</li>
<li>MediaStore.Images.Media.EXTERNAL_CONTENT_URI</li>
<li>MediaStore.Images.Media.INTERNAL_CONTENT_URI</li>
<li>MediaStore.Video.Media.EXTERNAL_CONTENT_URI</li>
<li>MediaStore.Video.Media.INTERNAL_CONTENT_URI</li>
</ul>
<p>其中EXTERNAL标识在外部存储器，INTERNAL标识在内部存储器；Audio，Images，Video分别标识音频，图片，视频。</p>
<p>对外部存储修改，需要在AndroidManifest.xml文件中增加配置：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 授予读取外部存储设备的访问权限 --&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;</span><br><span class="line">&lt;!-- 授予写入外部存储设备的访问权限 --&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="监听ContentProvider的数据改变"><a href="#监听ContentProvider的数据改变" class="headerlink" title="监听ContentProvider的数据改变"></a>监听ContentProvider的数据改变</h2><p>当ContentProvider将数据共享出来之后，ContentResolver会根据业务需要去主动查询ContentProvider所共享的数据。有时候，应用程序需要实时监听ContentProvider所共享数据的改变，并随着ContentProvider的数据的改变而提供响应，这就需要利用ContentObserver了。</p>
<h3 id="ContentObserver"><a href="#ContentObserver" class="headerlink" title="ContentObserver"></a>ContentObserver</h3><p>监听ContentProvider数据改变的监听器需要继承ContentObserver类，并重写该基类所定义的onChange(boolean selfChange)方法———当它所监听的ContentProvider数据改变时，该onChange()方法将会被触发。<br>为了监听指定ContentProvider的数据变化，需要通过ContentResolver向指定Uri注册ContentObserver监听器。</p>
<ul>
<li>registerContentObserver(Uri uri,boolean notifyForDescendents,ContentObserver observer)<ul>
<li>uri:该监听器所监听的ContentProvider的Uri</li>
<li>notifyForDescendents：如果该参数设为true，假如注册监听的Uri为content://abc,那么Uri为content://abc/xyz,content://abc/xyz/foo的数据发生改变时也会触发该监听器；如果该参数设为false，假如注册监听器为content://abc，那么只有content://abc的数据发生改变时才会触发该监听器</li>
<li>observer：监听器实例</li>
</ul>
</li>
</ul>
<p><strong>PS：ContentResolver用于操作ContentProvider提供的数据；ContentObserver用于监听ContentProvider的数据改变；而ContentProvider则是所有ContentProvider组件的基类</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/20/8.20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="法外狂徒罗某人">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="罗某">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/20/8.20/" itemprop="url">Android学习（三十四之使用ContentProvider实现数据共享）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-20T12:15:47+08:00">
                2018-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="安卓基础"><a href="#安卓基础" class="headerlink" title="安卓基础"></a>安卓基础</h1><p>为了在应用程序之间交换数据，Android提供了ContentProvider，它是不同应用之间进行数据交换的标准API。</p>
<p>ContentProvider也是Android应用的四大组件之一，与Activity、Service、BroadcastReceiver相似，他们都要在AndroidManifest.xml文件中配置。</p>
<h2 id="数据共享标准：ContentProvider"><a href="#数据共享标准：ContentProvider" class="headerlink" title="数据共享标准：ContentProvider"></a>数据共享标准：ContentProvider</h2><p>ContentProvider以某种Uri的形式对外提供数据，允许其他应用访问或修改数据；其他应用程序是哟个ContentResolver根据Uri去访问操作指定数据。</p>
<p>可以将ContentProvider与ContentResolver简单的类比；可以把ContentProvider当成Android系统内部的“网站”，这个网站以固定的Uri对外提供服务；而ContentResolver则可以当成Android系统内部的HttpClient<br>，它可以向指定Uri发送“请求”（实际上是调用ContentResolver的方法），这种请求最后委托给ContentProvider处理，从而实现对“网站”（ContentProvider）内部数据进行操作。</p>
<h3 id="ContentProvider简介"><a href="#ContentProvider简介" class="headerlink" title="ContentProvider简介"></a>ContentProvider简介</h3><p>开发一个ContentProvider步骤：</p>
<ol>
<li>定义自己的ContentProvider类，该类需要继承Android提供的ContentProvider基类</li>
<li>向Android系统注册，在AndroidManifest.xml中注册ContentProvider，就像注册Activity一样。</li>
</ol>
<p>继承了ContentProvider之外，还要提供如下方法：</p>
<ul>
<li>public boolean onCreate()：ContentProvider创建时被调用，其他应用第一次访问ContentProvider时，该ContentProvider被创建出来，并立即回调该onCreate()方法</li>
<li>public Uri insert(Uri uri,ContentValues values)：根据该Uri插入values对应的数据</li>
<li>public int delete(Uri uri,String selection,String[] selectionArgs)：根据Uri删除selection条件所匹配的全部记录</li>
<li>public int update(Uri uri,ContentValues values,String selection,String[] selectionArgs)：根据Uri修改selection条件所匹配的全部记录</li>
<li>public Cursor query(Uri uri,String[] projection,String selection,String[] selectionArgs,String sortOrder)：根据Uri查询出selection条件所匹配的全部记录，其中projection就是一个列名列表，表明只选择出指定的数据列</li>
<li>public String getType(Uri uri)：该方法用于返回当前Uri所代表的数据的MIME类型。如果该Uri对应的数据可能包括多条记录，那么MIME类型字符串应该以vnd.android.cursor.dir/开头；如果该Uri对应的数据只包含一条记录，那么MIME类型字符串应该以vnd.android.item/开头</li>
</ul>
<h3 id="Uri简介"><a href="#Uri简介" class="headerlink" title="Uri简介"></a>Uri简介</h3><p>ContentProvider的Uri例如如下：<br><code>content://org.crazyit.providers.dictprovider/words</code>它可以分为如下三个部分：</p>
<ul>
<li><strong>content://</strong>：这个部分是Android的ContentProvider规定的，就像上网的协议默认是http://</li>
<li>org.crazyit.providers.dictprovider：这是ContentProvider的authorities。系统是由这个部分来找到操作哪个ContentProvider的。只要访问指定的ContentProvider，这个部分就是固定的</li>
<li>words：资源量部分（数据部分）。访问不同资源时，这里动态改变。</li>
</ul>
<p>为了将一个字符串转换成Uri，Uri工具类提供了parse()静态方法。例如，如下代码即可将字符串转换为Uri：<br><code>Uri uri=uri.parse(&quot;content://org.crazyit.prociders.dictprovider/word&quot;)</code></p>
<h3 id="使用ContentResolver操作数据"><a href="#使用ContentResolver操作数据" class="headerlink" title="使用ContentResolver操作数据"></a>使用ContentResolver操作数据</h3><p>Context提供了如下方法来获取ContentResolver对象:</p>
<ul>
<li>getContentResolver()</li>
</ul>
<p>获取ContentResolver对象后，调用如下方法操作数据</p>
<ul>
<li>insert(Uri uri,ContentValues values)：向Uri对应的ContentProvider中插入values对应的数据</li>
<li>delete(Uri uri,String where,String[] selectionArgs)：删除Uri对应的ContentProvider中where提交匹配的数据</li>
<li>update(Uri uri,ContentValues values,String where,String[] selectionArgs)：更新Uri对应的ContentProvider中where提交匹配的数据</li>
<li>query(Uri uri,String[] projection,String selection,String[] selectionArgs,String sortOrder)：查询Uri对应的ContentProvider中where提交匹配的数据</li>
</ul>
<h2 id="开发ContentProvider"><a href="#开发ContentProvider" class="headerlink" title="开发ContentProvider"></a>开发ContentProvider</h2><p>ContentProvider需要与ContentResolver结合学习</p>
<h3 id="ContentProvider与ContentResolver的关系"><a href="#ContentProvider与ContentResolver的关系" class="headerlink" title="ContentProvider与ContentResolver的关系"></a>ContentProvider与ContentResolver的关系</h3><p>Uri是ContentResolver和ContentProvider进行数据交换的标识。ContentResolver对指定的Uri执行CRUD等数据操作，但Uri并不是真正的数据中心，因为这些CRUD操作会委托给该Uri对应的ContentProvider来实现。<br>通常来说，假如A应用通过ContentResolver执行CRUD操作，这些CRUD操作都需要指定Uri参数，Android系统就根据该Uri找到对应的ContentProvider（该ContentProvider通常属于B应用），ContentProvider则负责实现CRUD方法，完成对底层数据的增删改查等操作，这样就可以让A应用访问、修改B应用的数据了。</p>
<p><img src="http://itfish.net/Home/Modules/Images/itfish_61052_0.jpg" alt="s"></p>
<p>上图是ContentResolver、Uri、ContentProvider三者关系。通过这种关系即可实现让A应用访问、使用B应用底层的数据。</p>
<h3 id="开发ContentProvider子类"><a href="#开发ContentProvider子类" class="headerlink" title="开发ContentProvider子类"></a>开发ContentProvider子类</h3><p>开发ContentProvider步骤：</p>
<ol>
<li>开发一个ContentProvider子类，该子类需要实现query(),insert(),update()和delete()等方法</li>
<li>在AndroidManifest.xml中注册该ContentProvider，指定android:authorities属性</li>
</ol>
<p>ContentProvider子类实现的CRUD方法，并不是给该应用本身调用，而是供其他应用来调用。</p>
<h3 id="配置ContentProvider"><a href="#配置ContentProvider" class="headerlink" title="配置ContentProvider"></a>配置ContentProvider</h3><p>Android要求Activity、Service、ContentProvider、BroadcastReceiver都必须进行显式配置.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;provider</span><br><span class="line">   android:name=&quot;.FristProvider&quot;</span><br><span class="line">   android:authorities=&quot;org.crazyit.providers.firstprovider&quot;</span><br><span class="line">   android:exported=&quot;true&quot;</span><br></pre></td></tr></table></figure>
<p>从上面的配置可以看出，配置ContentProvider时通常指定如下属性。</p>
<ul>
<li>name:指定该ContentProvider的实现类的类名</li>
<li>authorities:指定该ContentProvider对应的Uri</li>
<li>android:exporter:指定该ContentProvider是否允许其他应用调用。true代表可以被调用。</li>
</ul>
<p>当其他ContentResolver向该Uri执行CRUD方法时：</p>
<ul>
<li>ContentResolver调用方法时参数将会传给该ContentProvider的CRUD方法</li>
<li>ContentResolver调用方法的返回值，也就是ContentProvider执行CRUD的返回值</li>
</ul>
<h3 id="使用ContentResolver调用方法"><a href="#使用ContentResolver调用方法" class="headerlink" title="使用ContentResolver调用方法"></a>使用ContentResolver调用方法</h3><p>Context提供了getContentResolver()方法。这表明Activity、Service等组件都可以通过getContentResolver()方法获取ContentResolver对象。</p>
<p><strong>ContentResolver调用query(),insert(),update(),delete()方法，实际上就是调用uri参数对应的ContentProvider的query(),insert(),update(),delete()方法</strong></p>
<h3 id="创建ContentProvider的说明"><a href="#创建ContentProvider的说明" class="headerlink" title="创建ContentProvider的说明"></a>创建ContentProvider的说明</h3><p>为了确定该ContentProvider实际能处理的Uri，以及确定每个方法中Uri参数所操作的数据，Android系统提供了UriMatcher工具类。<br>UriMatcher工具类主要提供了如下两个方法：</p>
<ul>
<li>void addURI(String authority,String path,int code)：用于向UriMatcher对象注册Uri。其中authority和path组合成一个Uri，而code则代表该Uri对应的标识码</li>
<li>int match(Uri uri)：根据前面注册的Uri来判断指定的Uri对应的标识码。如果找不到匹配的，该方法返回-1。</li>
</ul>
<p>除此之外，Android还提供了一个ContentUris工具类，它是一个操作Uri字符串的工具类，提供了如下两个工具方法。</p>
<ul>
<li>withAppendedId(uri，id)：用于为路径加上ID部分</li>
<li>parseId(uri)：用于从指定Uri中解析出所包含的ID值</li>
</ul>
<p>在实际项目中，都会通过采用工具类来定义各种常量的方式进行处理。</p>
<h2 id="操作系统的ContentProvider"><a href="#操作系统的ContentProvider" class="headerlink" title="操作系统的ContentProvider"></a>操作系统的ContentProvider</h2><p>例如联系人信息、系统的多媒体信息。</p>
<h3 id="使用ContentProvider管理联系人"><a href="#使用ContentProvider管理联系人" class="headerlink" title="使用ContentProvider管理联系人"></a>使用ContentProvider管理联系人</h3><p>Android系统用于管理联系人的ContentProvider的几个Uri如下。</p>
<ul>
<li>ContactsContract.Contacts.CONTENT_URI：管理联系人</li>
<li>ContactsContract.CommonDataKinds.Phone.CONTENT_URI：管理联系人的电话</li>
<li>ContactsContract.CommonDataKinds.Email.CONTENT_URI：管理联系人的Email</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/19/8.19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="法外狂徒罗某人">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="罗某">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/19/8.19/" itemprop="url">Android学习（三十三之Android数据存储与IO）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-19T12:10:56+08:00">
                2018-08-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="安卓基础"><a href="#安卓基础" class="headerlink" title="安卓基础"></a>安卓基础</h1><p>轻量型数据库，不足以用来充当服务器</p>
<h3 id="SQLiteDatabase简介"><a href="#SQLiteDatabase简介" class="headerlink" title="SQLiteDatabase简介"></a>SQLiteDatabase简介</h3><p>通过SQLiteDatabase对象来管理、操作数据库。SQLiteDatabase提供了如下静态方法来打开一个文件对应的数据库。</p>
<ul>
<li>static SQLiteDatabase openDatabase(String path,SQLiteDatabase.CursorFactory factory,int flags)：打开path文件所代表的SQLite数据库</li>
<li>static SQLiteDatabase openOrCreateDatabase(File file,SQLiteDatabase.CursorFactory factory)：打开或者创建file文件所代表的SQLite数据库</li>
<li>static SQLiteDatabase openOrCreateDatabase(String path,SQLiteDatabase.CursorFactory factory)：打开或者创建path文件所代表的SQLite数据库</li>
</ul>
<p>在程序中获取了SQLiteDatabase对象后，调用如下方法来操作数据库：</p>
<ul>
<li>execSQL(String sql,Object[] bindArgs)：执行带占位符的sql语句</li>
<li>execSQL(String sql)：执行sql语句</li>
<li>insert(String table,String nullColumnHack,ContentValues values)：向指定表中插入数据</li>
<li>update(String table,ContentValues values,String whereClause,String[] whereArgs)：更新指定表中的特定数据</li>
<li>delete(String table,String whereClause,String[] whereArgs)：删除指定表中的特定数据</li>
<li>Cursor query(String tabel,String[] columns,String whereClause,String[] whereArgs,String groupBy,String having,String orderBy)：对指定数据表执行查询</li>
<li>Cursor query(String tabel,String[] columns,String whereClause,String[] whereArgs,String groupBy,String having,String orderBy,String limit)：对指定数据表执行查询。limit参数控制最多查询几条记录（用于控制分页的参数）</li>
<li>Cursor query(boolean distinct,String tabel,String[] columns,String whereClause,String[] whereArgs,String groupBy,String having,String orderBy,String limit)：对指定数据表执行查询；第一个参数是控制是否除去重复值</li>
<li>rawQuery(String sql,String[] selectionArgs)：执行带占位符的sql查询</li>
<li>beginTransaction()：开始事务</li>
<li>endTransaction()：结束事务</li>
</ul>
<p><strong>PS：whereArgs用于为wherClause自居传入参数。whereClause是执行数据库方法需要满足的条件</strong></p>
<p>上面的查询方法都返回一个Cursor对象，类似JDBC中的Resultset，Cursor提供了如下方法来移动查询结果的记录指针。</p>
<ul>
<li>move(int offset)：将记录指针向上（正数）或向下移动指定行数</li>
<li>boolean moveToFirst()：将记录指定移动到第一行</li>
<li>boolean moveToLast()：移动到最后</li>
<li>boolean moveToNext()：移动到下一行</li>
<li>boolean moveToPosition(int position)：将记录指针移动到指定行</li>
<li>boolean moveToPrevious()：移动到上一行</li>
</ul>
<p><strong>用SQLiteDatabase进行数据库操作的步骤：1.获取SQLiteDatabase对象，它代表了与数据库的连接。2.调用SQLiteDatabase的方法执行SQL语句。3.操作SQL语句的执行结果，比如用SimpleCursorAdapter封装Cursor4.关闭SQLiteDatabase，回收资源。</strong></p>
<h3 id="SQLiteOpenHelper类"><a href="#SQLiteOpenHelper类" class="headerlink" title="SQLiteOpenHelper类"></a>SQLiteOpenHelper类</h3><p>在实际项目中更常用SQLiteOpenHelper开发子类，并通过子类的getReadableDatabase(),getWritableDatabase()方法打开数据库。</p>
<p>SQLiteOpenHelper包含如下常用的方法：</p>
<ul>
<li>synchronized SQLiteDatabase getReadableDatabase():以读写的方式打开数据库对应的SQLiteDatabase对象</li>
<li>synchronized SQLiteDatabase getWritableDatabase():以写的方式打开数据库对应的SQLiteDatabase对象</li>
<li>abstract void onCreate(SQLiteDatabase db):第一次创建数据库回调该方法</li>
<li>abstract void onUpgrade(SQLiteDatabase db,int oldVersion,int newVersion):当数据库版本更新回调该方法</li>
<li>synchronized void close():关闭所有打开的SQLiteDatabase对象</li>
</ul>
<p>重写抽象方法：</p>
<ul>
<li>onCreate(SQLiteDatabase db):生成数据库表结构</li>
<li>onUpgrade(SQLiteDatabase db,int oldVersion,int new Version):当用户创建SQLiteOpenHelper对象时，必须指定一个version参数，该参数就是所使用的数据库版本。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/18/8.18.2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="法外狂徒罗某人">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="罗某">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/18/8.18.2/" itemprop="url">Android学习（三十二之Android数据存储与IO）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-18T22:17:11+08:00">
                2018-08-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="安卓基础"><a href="#安卓基础" class="headerlink" title="安卓基础"></a>安卓基础</h1><h2 id="使用SharedPreferences"><a href="#使用SharedPreferences" class="headerlink" title="使用SharedPreferences"></a>使用SharedPreferences</h2><p>应用程序少量的数据保存，这些数据的格式很简单，都是很普通的字符串、标量类型的值等，对于这种数据，Android提供了SharedPreferences进行保存</p>
<h3 id="SharedPreferences与Editor简介"><a href="#SharedPreferences与Editor简介" class="headerlink" title="SharedPreferences与Editor简介"></a>SharedPreferences与Editor简介</h3><p>SharedPreferences保存的数据主要是简单类型的key-value对。<br>SharedPreferences接口主要负责读取应用程序的Preferences数据，它提供了如下方法：   </p>
<ul>
<li>boolean contains(String key)：判断SharedPreferences是否包含特定key的数据</li>
<li>abstract Map&lt;String,?&gt; getAll()：获取SharedPreferences数据里全部的key-value对</li>
<li>boolean getXxx(String key,xxx defValue)：获取SharedPreferences数据里指定key对应的value。如果key不存在，返回默认值defValue。其中xxx可以是boolean、float、int、long、String等各种基本类型的值。</li>
</ul>
<p>通过SharedPreferences的内部接口，SharedPreferences调用edit()方法即可获取它所对应的Editor对象。Editor提供了如下方法向SharedPreferences写入数据。    </p>
<ul>
<li>SharedPreferences.Editor clear()：清空SharedPreferences中所有数据</li>
<li>SharedPreferences.Editor putXxx(String key,xxx value)：向SharedPreferences存入指定key对应的数据</li>
<li>SharedPreferences.Editor remove(String key)：删除SharedPreferences里指定key对应的数据项</li>
<li>boolean commit()：当Editor编辑完成后，调用该方法提交修改</li>
</ul>
<p>程序无法直接创建SharedPreferences实例，只能通过Context提供的getSharedPreferences(String name,int mode)方法获取SharedPreferences实例（SharedPreferences是一个接口）</p>
<h2 id="File存储"><a href="#File存储" class="headerlink" title="File存储"></a>File存储</h2><p>Android支持用FileInputStream、FileOutputStream这些IO流访问手机存储器上的文件。</p>
<p>###　openFileOutput和openFileInput</p>
<p>Context提供热如下两个方法打开应用程序的数据文件夹里的文件IO流。</p>
<ul>
<li>FileInputStream openFileInput(String name)：打开应用程序的数据文件夹下的name文件对应的输入流</li>
<li>FileOutputStream openFileOutput(String name,int mode)：打开应用程序的数据文件夹下的name文件对应的输出流</li>
</ul>
<h3 id="读写SD卡上的文件"><a href="#读写SD卡上的文件" class="headerlink" title="读写SD卡上的文件"></a>读写SD卡上的文件</h3><p>步骤：</p>
<ol>
<li>调用Environment的getExternalStorageState()方法判断是否插入内存卡<code>Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)</code>如果返回true即是插入了SD卡</li>
<li>调用getExternalStorageDirectory()方法来获取外部存储器</li>
<li>使用FileInputStream,FileOutputStream,FileReader,FileWriter读写SD卡里的文件<ul>
<li>必须插入SD卡，模拟器需要创建通过mskdcard</li>
<li>在AndroidManifest.xml中添加读写SD卡的权限，创建与删除文件权限：<code>&lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;</code>写入数据权限<code>uses-premission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</code></li>
</ul>
</li>
</ol>
<p><strong>ps：File.getCanonicalPath（）方法用来获取文件（文件夹）路径；使用时需要进行try/catch抛出IOException异常</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">法外狂徒罗某人</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">100</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
		  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0"
		  width=330 height=86 src="//music.163.com/outchain/player?type=2&id=2113043&
		  auto=0&height=66"></iframe>

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">法外狂徒罗某人</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
