<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Freemarker]]></title>
    <url>%2F2019%2F03%2F05%2FFreemarker%2F</url>
    <content type="text"><![CDATA[什么是FreemarkerFreeMarker是一款模板引擎： 即一种基于模板和要改变的数据， 并用来生成输出文本（HTML网页、电子邮件、配置文件、源代码等）的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。 FreeMarker是免费的，基于Apache许可证2.0版本发布。其模板编写为FreeMarker Template Language（FTL），属于简单、专用的语言。需要准备数据在真实编程语言中来显示，比如数据库查询和业务运算，之后模板显示已经准备好的数据。在模板中，主要用于如何展现数据，而在模板之外注意于要展示什么数据。[百度百科] 特点： 是一个模板引擎 不是web框架，适合作为Web应用框架的组件 与容器无关；它并不知道HTTP或者Servlets，FreeMaker同样可以应用于非Web应用程序中 更适合作为Model2的试图组件，可以在模板中使用JSP标记库 官网 入门 优点： 可以彻底的分离表现层和业务逻辑 可以提高开发效率 使得开发过程中的人员分工更加明确 Free Marker工作原理图： 模板和静态HTML是相同的，只是他会包含一些FreeMarker将它们变成动态内容的指令。模板文件存放在Web服务器上，就像通常存放静态HTML页面那样。当有人来访问这个页面， FreeMarker将会介入执行，然后动态转换模板，用最新的数据内容替换模板中 ${*...*} 的部分， 之后将结果发送到访问者的Web浏览器中。 访问者的Web浏览器就会接收到例如一个静态HTML示例那样的内容 (也就是没有FreeMarker指令的HTML代码)，访问者也不会察觉到服务器端使用的FreeMarker。 (当然，存储在Web服务器端的模板文件是不会被修改的；替换也仅仅出现在Web服务器的响应中。) 显示的数据是在 FreeMarker 之外准备的，通常是一些 “真正的” 编程语言(比如Java) 所编写的代码。模板作者无需知道这些值是如何计算出的。事实上，这些值的计算方式可以完全被修改， 而模板可以保持不变，而且页面的样式也可以完全被修改而无需改动模板。 当模板作者(设计师)和程序员不是同一人时，显示逻辑和业务逻辑相分离的做法是非常有用的， 即便模板作者和程序员是一个人，这么来做也会帮助管理应用程序的复杂性。 保证模板专注于显示问题(视觉设计，布局和格式化)是高效使用模板引擎的关键。 为模板准备的数据整体被称作为 数据模型。 数据模型不是文本格式，它来自于Java对象。 模板+数据模型=输出 模板指令（配合插值使用（${…}）） if 例如：Welcome ${user}&lt;#if user == &quot;Big Joe&quot;&gt;, our beloved leader&lt;/#if&gt;!这句模板中，如果显示user不是Big Joe那么，那么介于 &lt;#if condition&gt; 和 &lt;/#if&gt; 标签中的内容会被略过 。在指令或插值中没有被引号标注的内容都被视为变量的引用。 指定的字符串只能放在引号内。 list list指令一般格式： &lt;#list sequence as loopVariable&gt;repeatThis&lt;/#list&gt; 。当在list指令中loopVariable是null，那么模板会略过list这个指令。list指令将列表视为一个整体。其中可以有&lt;#sep&gt;&lt;/#sep&gt;和&lt;#else&gt;&lt;/#else&gt; include 使用include指令可以在模板中插入其他文件的内容。 内建函数为了清晰子变量是哪部分，使用 ?(问号)代替 .(点)来访问它们。 user?html 给出 user 的HTML转义版本， 比如 &amp; 会由 &amp;amp; 来代替。 user?upper_case 给出 user 值的大写版本 (比如 “JOHN DOE” 来替代 “John Doe”) animal.name?cap_first 给出 animal.name 的首字母大写版本(比如 “Mouse” 来替代 “mouse”) user?length 给出 user 值中 字符的数量(对于 “John Doe” 来说就是8) animals?size 给出 animals 序列中 项目 的个数(我们示例数据模型中是3个) 一些内建函数 animal.protected?string(&quot;Y&quot;, &quot;N&quot;) 基于 animal.protected 的布尔值来返回字符串 “Y” 或 “N”。 animal?item_cycle(&#39;lightRow&#39;,&#39;darkRow&#39;) 是之前介绍的 item_parity 更为常用的变体形式。 fruits?join(&quot;, &quot;) 通过连接所有项，将列表转换为字符串， 在每个项之间插入参数分隔符(比如 “orange,banana”) user?starts_with(&quot;J&quot;) 根据 user 的首字母是否是 “J” 返回布尔值true或false。 内建函数应用可以链式操作，比如user?upper_case?html 会先转换用户名到大写形式，之后再进行HTML转义。(这就像可以链式使用 .(点)一样) 总体结构模板是由如下部分混合而成： 文本：文本会照着原样来输出。 插值：这部分的输出会被计算的值来替换。插值由 ${ and } 所分隔 。插值 仅仅可以在 文本中使用 FTL标签：FTL标签和HTML标签很相似，但是它们却是给FreeMarker的指示， 而且不会打印在输出内容中。 注释：注释和HTML的注释也很相似，但它们是由 &lt;#-- 和 --&gt;来分隔的。注释会被FreeMarker直接忽略， 更不会在输出内容中显示。 Maven构建Fremarker项目（入门） 创建Configuration实例。 应该创建一个 freemarker.template.Configuration 实例， 然后调整它的设置。Configuration实例是存储 FreeMarker 应用级设置的核心部分。同时，它也处理创建和 缓存 预解析模板(比如 Template 对象)的工作。 12345678910111213141516// Create your Configuration instance, and specify if up to what FreeMarker// version (here 2.3.22) do you want to apply the fixes that are not 100%// backward-compatible. See the Configuration JavaDoc for details.Configuration cfg = new Configuration(Configuration.VERSION_2_3_22);// Specify the source where the template files come from. Here I set a// plain directory for it, but non-file-system sources are possible too:cfg.setDirectoryForTemplateLoading(new File("/where/you/store/templates"));// Set the preferred charset template files are stored in. UTF-8 is// a good choice in most applications:cfg.setDefaultEncoding("UTF-8");// Sets how errors will appear.// During web page *development* TemplateExceptionHandler.HTML_DEBUG_HANDLER is better.cfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IDEA下实现Android的高级重启及刷写Recovery]]></title>
    <url>%2F2019%2F03%2F01%2F%E9%80%9A%E8%BF%87Java%E6%8E%A7%E5%88%B6%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[功能构思 能够通过控制台实行高级控制 重启进入rec 重启进入bootloader进入bootloader之后能够 刷入boot.img 刷入recovery.img 重启手机 退出程序 功能如图： 刷写recovery的流程 打开开发者模式，并且开启usb调试。 重启进入bootloader 输入4，提示输入recovery的文件名（将recovery放入工程的src目录下） 输入5重启手机 项目结构 Command.class是存放了命令常量的类，并且有对应的getter方法。 Phone.class是一个父类，其中包含了通过java来实现cmd操作的方法 Huawei_p8继承Phone，它包含了功能的逻辑实现 main是测试类 收获 switch case用来判断变量是否与一系列值相等，每一个值是一个分支 对重复使用的方法进行封装 Scanner类的使用,创建scanner对象并且参数为输入流。scanner对象常用两个方法：①hasNext()表示判断有没有输入的数据②next()用来接收字符串。 将字符串转化为int型的方法：Integer.parseInt(String a) Scanner scanner2 = new Scanner(System.in); String no = scanner2.next(); j = Integer.parseInt(no); String.equals()方法是用来比较内容是否相等，==用来比较引用。如：String a = new String(“abc”)与String b = new String(“abc”)比较]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Win10下Java环境配置]]></title>
    <url>%2F2019%2F02%2F25%2Fwin10%E4%B8%8Bjava%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[需要配置三个系统变量 JAVA_HOME:跟jdk的绝对路径 CLASSPATH:.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; Path:jdk的绝对路径下的bin目录和jdk绝对路径下jre目录下的bin目录 其中第三步中改用绝对路径能够避免win10下的cmd命令中出现javac不是内部或外部命令问题]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[四级（一）]]></title>
    <url>%2F2018%2F12%2F27%2F%E8%8B%B1%E8%AF%AD%2F</url>
    <content type="text"><![CDATA[翻译常用短语常识性的单词短语 最古老之一 ： one of the oldest 文明 ： civilizations 元素 ： elements 组成 ： make up 起源 ： origin 基础 : foundation 工业革命 ： industrial revolution 建造空间站 ： complete a space station 目前 ： currently 中国超越日本成为世界第二大经济体 ：China surpassed Japan as the world’s second-largest economy 中华人民共和国 ： People’s Republic of China 洞庭湖 ： Dongting lake 长江 ： The Yangtze river 黄河 ： The Yellow River 改革开放 ： Reform and opening up 经济特区 ： special economic zone 港珠澳大桥 ： Hong kong-zhuhai-macao brige]]></content>
      <categories>
        <category>英语</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MyBatis入门]]></title>
    <url>%2F2018%2F11%2F09%2FMyBatis%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[ORM模型简介Object Relation Mapping对象关系映射 Object(java文件)Mapping(xml文件)Relation(数据库中表) 传统JDBC程序的设计缺陷 大量的硬编码,不符合开闭原则 大量无关业务处理的编码，如数据库连接及操作 扩展优化极不方便 MyBatisMyBatis是支持定制化SQL、存储过程和高级映射的持久层框架。 它的基本特点是： 避免传统JDCBC的硬编码 XML配置及注解 POJO对象和数据库记录直接映射 完善的文档支持 它的优势是： 简单易学 数据库交互信息配置化 动态SQL处理 它的使用场景： 关注SQL优化的项目 需求频繁更新改动的项目 一个maven+mybatis工程例子 新建一个为空的maven工程 配置pom文件，从中央仓库中搜索需要的jar包 将需要包的依赖引入pom文件的\\中，将包引入项目 在resources目录下新建mybatis.xml文件，来配置数据库连接池 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;!-- 使用数据库连接池 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 映射配置文件的路径 --&gt; &lt;mappers&gt; &lt;mapper resource="org/mybatis/example/BlogMapper.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 上面的代码只是官方给出的一个简单的例子，需要自己修改其中的数据库连接池和映射配置文件的路径。 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;!--使用数据库连接池--&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mytest"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--映射配置文件的路径--&gt; &lt;mappers&gt; &lt;!--&lt;mapper resource="org/mybatis/example/BlogMapper.xml"/&gt;--&gt; &lt;mapper resource="mapper/usersMapper.xml"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 这里使用的数据库是新建的数据库mytest，其中有users表： 1234567891011121314151617create database mytest;use mytest;create table users( id int auto_increment primary key comment '用户编号', username varchar(50) comment '登录账号', userpass varchar(50) comment '登录密码', nickname varchar(50) comment '用户昵称');insert into users values(1,'admin','admin','管理员');insert into users values(2,'manager','manager','管理员');insert into users values(3,'administrator','administrator','管理员');select * from users; 创建java实体类，这里是Users类，对应数据库中表users。users对象对应表users的一个元组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Users &#123; private Integer id; private String username; private String userpass; private String nickname; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getUserpass() &#123; return userpass; &#125; public void setUserpass(String userpass) &#123; this.userpass = userpass; &#125; public String getNickname() &#123; return nickname; &#125; public void setNickname(String nickname) &#123; this.nickname = nickname; &#125; @Override public String toString() &#123; return "Users&#123;" + "id=" + id + ", username='" + username + '\'' + ", userpass='" + userpass + '\'' + ", nickname='" + nickname + '\'' + '&#125;'; &#125;&#125; 其中使用[alt]+[insert]快速getter and setter和toString。 在resources目录下新建一个mapper包，其中用来存java实体类的对应映射文件，它的命名规则是：实体类名称+Mapper.xml 123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="org.mybatis.example.BlogMapper"&gt; &lt;select id="selectBlog" resultType="Blog"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 这里是mybatis官方给出的例子，我们需要重新配置其中的命名空间和sql语句。 123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace 命名空间 通常情况，命名空间的值，就是当前操作实体类的全名称 --&gt;&lt;mapper namespace="com.damu.entity.Users"&gt; &lt;select id="usersList" resultType="com.damu.entity.Users"&gt; select * from users &lt;/select&gt;&lt;/mapper&gt; 在test目录下，定义测试类，使用junit包来测试 12345678910111213141516171819202122232425262728293031323334import com.damu.entity.Users;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.List;public class TestDemo &#123; /* 通过junit进行测试 */ @Test public void testDemo1() throws IOException &#123; //初始化mybatis配置环境 String resource = "mybatis.xml"; InputStream is = Resources.getResourceAsStream(resource); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(is); //打开和数据库之间的对话 SqlSession sqlSession = factory.openSession(); List&lt;Users&gt; ulist = sqlSession.selectList("usersList"); for (Users user:ulist ) &#123; System.out.println(user); &#125; sqlSession.close(); &#125;&#125; 其中的初始化mybatis配置环境，即是Building SqlSessionFactory from XML。它有三步： 将mybatis配置文件定义为一个字符串。 创建一个输入字节流对象inputStream，通过org.apache.ibatis.io.Resources.getResourceAsStream(resource)来获得 创建SqlSessionFactory，通过new SqlSessionFactoryBuilder().build(inputStream)来创建SqlSessionFactory对象sqlSessionFactory 打开和数据库之间的对话，即Acquiring a SqlSession from SqlSessionFactory，捕获一个sql对话从工厂中： 通过sqlSessionFactory.openSession()来获得session对象 通过session的selectOne/selectList等等方法来获得表中的元组 整个mybaits的项目逻辑如下图]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[简单工厂(Static Factory Method)模式]]></title>
    <url>%2F2018%2F11%2F08%2F%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82(Static-Factory-Method)%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是简单工厂模式（Static Factory Method）将用来能创建多种对象的逻辑代码放在Factory.class文件中，不将这段具体的创建对象的代码放在将要调用这些对象实现功能的类中。在将来，由于业务需要，必须增加对象的种类时，上面的封装过程就避免以后创建对象直接修改功能类中的代码。如果不进行封装，仍然保持创建对象代码放在功能类中；在以后需要增加对象使用的场景，不仅功能类中的创建对象代码需要修改，其他的场景中用到这个创建对象的源码都要修改。这样的代码太死板了，不便于修改，容易手误。 接口的使用（用来统一标准或统一方法）需要对多种对象进行相同的逻辑处理，这个处理不关心究竟是什么对象，即这些对象都具有相同的逻辑处理功能，那么我们可以定义一个接口，这个接口就是这个逻辑处理方法；那些对象的类实现这个接口，便可以进行相同的逻辑处理。 常量的使用将需要调用的字符串等，可以写在存放常量的类中，这样避免使用字符串时手误。 简单工厂模式（静态工厂模式）一个简单的例子源码模拟一个植物大战僵尸游戏，我们需要多种植物对象，他们都有自己的作战功能，并且需要将这些对象按自己的操作来放在一个指定的位置上。 植物源码 Bean 123456789101112131415public class Bean implements Plant&#123; private String name; public String getName() &#123; return "绿豆"; &#125; public void setName(String name) &#123; this.name = name; &#125; public void fight()&#123; System.out.println("发射一颗豆子"); &#125;&#125; Ice 1234567891011121314public class Ice implements Plant&#123; private String name; public String getName() &#123; return "蓝豆"; &#125; public void setName(String name) &#123; this.name = name; &#125; public void fight()&#123; System.out.println("发射一颗减速豆子"); &#125;&#125; Wall 123456789101112131415public class Wall implements Plant&#123; private String name; public String getName() &#123; return "一堵墙"; &#125; public void setName(String name) &#123; this.name = name; &#125; public void fight()&#123; System.out.println("阻止进攻"); &#125;&#125; 接口1234public interface Plant &#123; public String getName(); public void fight();&#125; 工厂源码SimpleFactory 1234567891011121314151617public class SimpleFactory &#123; public static Plant createPlant(String name)&#123; Plant plant = null; if (PlantNameConstant.BEAN_NAME.equals(name))&#123; plant=new Bean(); &#125;else if (PlantNameConstant.ICE_NAME.equals(name))&#123; plant =new Ice(); &#125;else if (PlantNameConstant.WALL_NAME.equals(name))&#123; plant =new Wall(); &#125; return plant; &#125; //利用反射创建对象 public static Plant createPlantByClassName(String name) throws Exception&#123; return (Plant) Class.forName(name).newInstance(); &#125;&#125; 游戏功能1234567public class Function &#123; public void put(String name,int number) throws Exception&#123; Plant plant=SimpleFactory.createPlantByClassName(name); System.out.println("将"+plant.getName()+"放在"+number+"号草地上"); plant.fight(); &#125;&#125; 定义常量的类123456public class PlantNameConstant &#123; //反射的类 public static final String BEAN_NAME = "org.imooc.plant.Bean"; public static final String ICE_NAME = "org.imooc.plant.Ice"; public static final String WALL_NAME = "org.imooc.plant.Wall";&#125; 项目结构 为什么要用设计模式 当需要给这三种植物增加更多的特征，再使用这样的简单工厂模式就又出现了代码复用性降低和不便于扩展的问题了！假设Bean和Ice都有不同的头发颜色和不同的子弹种类 这里有Hair和Arms和Shell三个类，用来给三种植物添加更多的属性，在Bean类和Ice类中增加Hair和Arms对象作为它的属性；在Wall类中增加Shell对象作为它硬度的属性；并getter和setter： 123456789101112//子弹类型public class Arms &#123; private String bulletType; public String getBulletType() &#123; return bulletType; &#125; public void setBulletType(String bulletType) &#123; this.bulletType = bulletType; &#125;&#125; 123456789101112//头发颜色public class Hair &#123; private String colorType; public String getColorType() &#123; return colorType; &#125; public void setColorType(String colorType) &#123; this.colorType = colorType; &#125;&#125; 123456789101112//墙的硬度public class Shell &#123; private Integer hardness; public Integer getHardness() &#123; return hardness; &#125; public void setHardness(Integer hardness) &#123; this.hardness = hardness; &#125;&#125; 那么简单工厂类SimpleFatory就又变得很复杂了12345678910111213141516171819202122232425262728293031public class SimpleFactory &#123; public static Plant createPlant(String name)&#123; Plant plant = null; if (PlantNameConstant.BEAN_NAME.equals(name))&#123; Bean bean=new Bean(); Hair hair = new Hair(); hair.setColorType("Green"); bean.setHair(hair); Arms arms = new Arms(); arms.setBulletType("普通"); bean.setArms(arms); plant = bean; &#125;else if (PlantNameConstant.ICE_NAME.equals(name))&#123; Ice ice =new Ice(); Hair hair = new Hair(); hair.setColorType("Blue"); ice.setHair(hair); Arms arms = new Arms(); arms.setBulletType("普通"); ice.setArms(arms); plant = ice; &#125;else if (PlantNameConstant.WALL_NAME.equals(name))&#123; Wall wall =new Wall(); Shell shell = new Shell(); shell.setHardness(5); wall.setShell(shell); plant = wall; &#125; return plant; &#125;&#125; 这段代码的适用场景如果发生改变，那么仍然需要改变其中的创建对象的代码，它的扩展性就很低了，而且也不能复用。 有什么解决方式？将这三种植物的创建过程分别提取出来，统一出一个接口，工厂接口（含有植物创建方法），三种植物的对象通过各自的工厂来创建并返回。然后，可以根据选择哪个工厂来创建哪种植物。 Factory接口 123public interface Factory &#123; public Plant createPlant();&#125; Bean的工厂 123456789101112public class BeanFactory implements Factory &#123; public Plant createPlant()&#123; Bean bean=new Bean(); Hair hair = new Hair(); hair.setColorType("Green"); bean.setHair(hair); Arms arms = new Arms(); arms.setBulletType("普通"); bean.setArms(arms); return bean; &#125;&#125; Ice的工厂 123456789101112public class IceFactory implements Factory&#123; public Plant createPlant()&#123; Ice ice = new Ice(); Hair hair = new Hair(); hair.setColorType("Blue"); ice.setHair(hair); Arms arms = new Arms(); arms.setBulletType("冰豆"); ice.setArms(arms); return ice; &#125;&#125; Wall的工厂 123456789public class WallFactory implements Factory &#123; public Plant createPlant()&#123; Wall wall = new Wall(); Shell shell = new Shell(); shell.setHardness(5); wall.setShell(shell); return wall; &#125;&#125; 我们不使用简单工厂模式，改用工厂方法定义一个用来根据条件来返回工厂对象的类FactoryBuilder: 1234567891011121314151617public class FactoryBuilder &#123; public static Factory build(String name)&#123; Factory factory = null; if (PlantNameConstant.BEAN_NAME.equals(name))&#123; factory = new BeanFactory(); &#125;else if (PlantNameConstant.ICE_NAME.equals(name))&#123; factory = new IceFactory(); &#125;else if (PlantNameConstant.WALL_NAME.equals(name))&#123; factory = new WallFactory(); &#125; return factory; &#125; public static Factory createByClass(String name) throws Exception&#123; return (Factory)Class.forName(name).newInstance(); &#125;&#125; Function类: 12345678public class Function &#123; public void put(String name,int number) throws Exception&#123; Factory factory = FactoryBuilder.build(name); Plant plant = factory.createPlant(); System.out.println("将"+plant.getName()+"放在"+number+"号草地上"); plant.fight(); &#125;&#125; 这种将各种植物的工厂给单独定义的方式，在后来增加新的植物时，只需要定义新的植物工厂，然后通过FactoryBuilder中的反射来创建对应的工厂对象，通过这个工厂对象（父类对象指向子类的引用）调用植物工厂类中的创建植物方法，返回一个植物对象。实现了相同的功能，这样增加了代码的扩展性。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[maven初识]]></title>
    <url>%2F2018%2F11%2F06%2Fmaven%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Maven压缩包结构 bin ：包含mvn的运行脚本 boot： 类加载框架 config： 配置文件 lib：maven的类库 Maven文件目录 src main java package test java package resources pom.xml Maven命令 mvn compile编译 mvn install编译，运行和发布 mvn package 编译、运行但不发布，就是不会把target内容发布到本地仓库 mvn test编译，负责编译test包下面有相关java和运行，但是不会发布到本地仓库中 mvn clean清除，清除target内容 mvn archetype:generate按照生成一个maven工程目录以及pom文件等等 mvn archetype:generate -DgroupId=组织名，公司网址的反写+项目名 -DartifactId=项目名-模块名 -Dversion=版本号 -Dpackage=代码所在包名 1234mvn archetype:generate -DgroupId=[your project's group id] -DartifactId=[your project's artifact id] -DarchetypeArtifactId=maven-archetype-archetype Maven命令的具体理解 自己在本地写好了一个Java项目（maven），项目名叫model01；其中有一个SpeakHello类，我们需要在另外的项目中引用它。（这是我们为什么要使用mvn install的原因） 在model01的根目录下，有pom.xml文件，我们在其中会有一个设置 123&lt;groupId&gt;com.imooc.maven&lt;/groupId&gt;&lt;artifactId&gt;model&lt;/artifactId&gt;&lt;version&gt;0.0.1SNAPSHOT&lt;/version&gt; 这个就是本项目的默认参数，如果需要发布到本地仓库（才能被其他不同项目引用其中的类），只需要将本项目编译（compile），然后测试（test），再发布（install）；这个默认参数的作用就是用来定位的。 所以经过install发布的项目，才能在另外的项目中引用它的类。 使用compile之后会在本地生成target目录，并且产生main目录下java源文件的字节码文件；使用test命令，是在target目录下产生test目录下测试类源文件的字节码文件；使用package则会将这个项目进行打包，生成jar文件（并未发布到本地maven仓库）；使用install则会将jar包发布到本地maven仓库。 IDEA创建Maven项目###1.先创建好一个Maven项目 第一步： 第二步： 第三步： 2.将项目下的main目录下Java目录加载为sources root和test目录下Java目录加载为test sources root3.最右侧工具栏Maven：Projects代替CMD命令行下的命令操作重写index.jsp文件使用!+[Tab键]可以快速生成一个html模板 ###使用pom.xml文件导入新的依赖（导入包） ###写Html的一些注意事项 在写表单的时候注意是form ###pom文件中jar包的导入 maven中坐标和仓库每一个maven项目都有pom.xml文件，其中包含对本项目的定位，以及对其他项目包的依赖。其中groupId就是项目的包名（指的是在main-&gt;java-&gt;下的包）；artifactId是模块名（对包下模块的定位建议写成与groupId最后一个单位用-相连接，便于查看）；version是版本，自己一般使用快照版本。 仓库分为本地仓库和中央仓库，还有镜像仓库。 ##maven完整的项目构建过程 清理、编译、测试、打包、集成测试、验证、部署 maven生命周期clean 清理项目 pre-clean 执行清理前的工作 clean 清理上一次构建生成的所有文件 post-clean 执行清理后的文件 default 构建项目（核心） compile test package install site 生成项目站点 后面的项目依赖前面的命令 maven依赖冲突短路优先；路径长度相同，谁先声明谁优先。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[命令行操作数据库基操]]></title>
    <url>%2F2018%2F11%2F05%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%93%8D%2F</url>
    <content type="text"><![CDATA[命令行操作数据库基本操作（下面给的全是在win10CMD命令下的操作）切换进入bin目录 D: cd Web cd mysql-[Tab] cd bin 进入数据库 mysql -u root -p 输入数据库密码 展示数据库 show databases; use [表名]; 查询库中表 select * from [表名];]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb开发Http异常]]></title>
    <url>%2F2018%2F10%2F28%2FJavaWeb%E5%BC%80%E5%8F%91Http%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Http 500 和 404异常500 异常：服务器内部错误 404 异常：服务器找不到请求的页面 500异常500错误，主要错误出现在服务器内部的错误，程序上的错误，用户权限的问题，或者是数据库连接出现了问题。 这个异常发生在我写JDBC操作数据库时，ResultSet对象的引用没有关联到stmt.excute()方法的返回对象。其实就是数据库的连接出现了问题 12345678910111213141516171819202122232425262728293031323334353637public List&lt;Message&gt; getMessages(int page,int pageSize)&#123; /** *@Description * @param page 当前页码 * @param pageSize 每页记录数 *@return java.util.List&lt;com.imooc.jdbc.bean.Message&gt; **/ Connection conn = ConnectionUtil.getConnection(); //limit m，n从第m条开始，取出共n条记录 String sql = "select * from message order by create_time desc limit ?,?"; PreparedStatement stmt = null; ResultSet rs = null; List&lt;Message&gt; messages = new ArrayList&lt;&gt;(); try &#123; stmt = conn.prepareStatement(sql); //setInt()是为了给sql语句中的？？动态给条件。 stmt.setInt(1,(page-1)*pageSize); stmt.setInt(2,pageSize); //下面这句就是罪魁祸首，stmt.executeQuery方法执行后，忘记将他返回的对象指向rs的引用，就是他导致的空指针异常，进而引起500异常 rs = stmt.executeQuery(); while (rs.next())&#123; messages.add(new Message(rs.getLong("id"), rs.getLong("user_id"), rs.getString("username"), rs.getString("title"), rs.getString("content"), rs.getTimestamp("create_time") )); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; ConnectionUtil.release(rs,stmt,conn); &#125; return null; &#125; request的setAttribute()用法setAttribute()用来在同一个request周期中保存变量使用。比如servlet调用后，引出一个JSP页面，这就是一个request的生命周期。 通常情况下，setAttribute()方法都和RequestDispatcher.forward()一起使用。比如说：在A页面中写一个setAttribute()，并且写一个RequestDispatcher.forward()指向B页面；那就是说服务器给出的response是B页面，并且只有一次request和response；所以能在B页面取到request.setAtribute里的值，地址栏的url仍然是A页面的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[必备知识]]></title>
    <url>%2F2018%2F10%2F19%2F%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[HashMap和HashTable的区别？ 线程安全性 同步(Synchronized) 效率 null key与null value 重复 HashMap 不安全 非同步 高 允许null key和null value 不能有重复键，可以有重复值 HashTable 安全 同步 低 不允许null key和null value 在Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。 HashTable是线程安全的，多个线程可以共享一个HashTable。 HashMap中的键和值都是对象。不能有重复键，可以有重复值。 HashMap的迭代器是fail-fast迭代器，HashTable的enumerator迭代器不是fail-fast；所以当有其他线程改变HashMap的结构，将会抛出ConcurrentModificationException异常。 HashMap不能保证随着时间的推移Map中的元素次序是不变的。 HashMap使用下面的语句进行同步：Map m = Collections.synchronizedMap(hashMap); ArrayList和LinkedList和Vector的区别？ 同步(Synchronized) 数据增长 查找、插入、删除对象的效率 基于什么 ArrayList 非同步 扩展时，增长原来的50% 检索一个对象或者在集合末尾插入/删除一个对象时间复杂度：O(1) 动态数组 LinkedList 非同步 插入/删除时间复杂度：O(1)，检索一个元素为：O(n) 双向链表 Vector 同步（线程安全） 扩展时，自动增长原来一倍的数组长度 对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针。 ArrayList在集合中（非最后一个）增加或者移除元素意味着这个列表中剩余的元素都要移动，它的时间复杂度线性增长为O(n-i),其中在进行插入或者删除时，集合中第i和第i个元素之后的所有元素都要执行(n-i)个对象的位移操作。 如果只是查找特定位置的元素或者只在集合的末端增加、移除元素，那么使用Vector和ArrayList都可以。如果对其他位置插入、删除操作，最好选择LinkedList。 TreeMap和TreeSet的区别？TreeSet底层是通过TreeMap来实现的（如同HashSet底层是通过HashMap来实现的）。TreeMap的实现就是红黑树算法。 TreeSet和TreeMap的相同点： 集合 同步(Synchronized) 运行速度 TreeSet与TreeMap相同点 有序 非同步集合 慢于Hash，时间复杂度为O(logN) TreeSet和TreeMap的不同点： 存储的对象 重复对象 实现接口 null key null value TreeSet 存储一个对象 不能有重复对象 Set TreeMap 存储两个对象(key-value) 可以有重复对象 Map 不允许为null key，可以是null value 通过HashMap和HashSet源码分析Hash存储机制对于HashSet系统采用Hash算法决定集合元素的存储位置，这样可以保证快速存取集合元素；对于HashMap，系统key-value当成一个整体来处理，系统根据Hash算法来计算出key-value的存储位置，这样保证能快速存取Map的key-value对。 Java集合实际上是多个引用变量所组成的集合，这些引用变量指向实际的Java对象。 HashMap：当系统决定存储HashMap中的key-value对时，完全没有考虑Entry中的value，仅仅只是根据key来计算并决定每个Entry的存储位置。 当向HashMap中添加key-value对，由其key的hashCode()返回值决定该key-value对（就是Entry对象）的存储位置。当两个Entry对象的key的hashCode()返回值相同时，将由key通过equals()比较值决定是采用覆盖行为（返回true），还是产生Entry链（返回false）。 HashSet：HashSet的源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; // 使用 HashMap 的 key 保存 HashSet 中所有元素 private transient HashMap&lt;E,Object&gt; map; // 定义一个虚拟的 Object 对象作为 HashMap 的 value private static final Object PRESENT = new Object(); ... // 初始化 HashSet，底层会初始化一个 HashMap public HashSet() &#123; map = new HashMap&lt;E,Object&gt;(); &#125; // 以指定的 initialCapacity、loadFactor 创建 HashSet // 其实就是以相应的参数创建 HashMap public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;E,Object&gt;(initialCapacity, loadFactor); &#125; public HashSet(int initialCapacity) &#123; map = new HashMap&lt;E,Object&gt;(initialCapacity); &#125; HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;E,Object&gt;(initialCapacity , loadFactor); &#125; // 调用 map 的 keySet 来返回所有的 key public Iterator&lt;E&gt; iterator() &#123; return map.keySet().iterator(); &#125; // 调用 HashMap 的 size() 方法返回 Entry 的数量，就得到该 Set 里元素的个数 public int size() &#123; return map.size(); &#125; // 调用 HashMap 的 isEmpty() 判断该 HashSet 是否为空， // 当 HashMap 为空时，对应的 HashSet 也为空 public boolean isEmpty() &#123; return map.isEmpty(); &#125; // 调用 HashMap 的 containsKey 判断是否包含指定 key //HashSet 的所有元素就是通过 HashMap 的 key 来保存的 public boolean contains(Object o) &#123; return map.containsKey(o); &#125; // 将指定元素放入 HashSet 中，也就是将该元素作为 key 放入 HashMap public boolean add(E e) &#123; return map.put(e, PRESENT) == null; &#125; // 调用 HashMap 的 remove 方法删除指定 Entry，也就删除了 HashSet 中对应的元素 public boolean remove(Object o) &#123; return map.remove(o)==PRESENT; &#125; // 调用 Map 的 clear 方法清空所有 Entry，也就清空了 HashSet 中所有元素 public void clear() &#123; map.clear(); &#125; ... &#125; 从上面的源程序可以看出，HashSet的实现其实非常简单，它只是封装了一个HashMap对象来存储所有的集合元素，所有放入HashSet中的集合元素实际上由HashMap的key来保存，而HashMap的value则存储了一个PRESENT，它是一个静态的Object对象。 HashMap的put方法源码： 123456789101112131415161718192021222324252627282930public V put(K key, V value) &#123; // 如果 key 为 null，调用 putForNullKey 方法进行处理 if (key == null) return putForNullKey(value); // 根据 key 的 keyCode 计算 Hash 值 int hash = hash(key.hashCode()); // 搜索指定 hash 值在对应 table 中的索引 int i = indexFor(hash, table.length); // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // 找到指定 key 与需要放入的 key 相等（hash 值相同 // 通过 equals 比较放回 true） if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 如果 i 索引处的 Entry 为 null，表明此处还没有 Entry modCount++; // 将 key、value 添加到 i 索引处 addEntry(hash, key, value, i); return null; &#125; 如果向HashSet中添加一个已经存在的元素，新添加的集合元素（底层由HashMap的key保存）不会覆盖已有的集合元素。因为HashSet的add()方法添加集合元素时实际上转变为调用HashMap的put()方法来添加key-value对，当放入HashMap的Entry中key与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true），新添加的Entry的value会覆盖之前的value，但key不会有任何改变，所以HashSet添加已存在的元素不会覆盖已有元素。 测试：1234567891011121314151617181920212223242526272829303132333435363738class Name&#123; private String first; private String last; public Name(String first, String last) &#123; this.first = first; this.last = last; &#125; public boolean equals(Object o) &#123; if (this == o) &#123; return true; &#125; if (o.getClass() == Name.class) &#123; Name n = (Name)o; return n.first.equals(first) &amp;&amp; n.last.equals(last); &#125; return false; &#125; &#125; public class HashSetTest&#123; public static void main(String[] args) &#123; Set&lt;Name&gt; s = new HashSet&lt;Name&gt;(); s.add(new Name("abc", "123")); System.out.println( s.contains(new Name("abc", "123"))); &#125;&#125; 实际运行上面程序会输出false，因为s.contains(new Name(“abc”, “123”))这一句中new了一个Name对象，引用已经不是上面的Name(“abc”,”123”)了。HashSet判断两个对象相等的标准除了要求通过equals()方法比较返回true之外，还要求两个对象的hashCode()方法返回值相等。而上面的程序没有重写Name类的hashCode()方法，两个Name对象的hashCode()返回值并不相同，HashSet会把它们当成两个对象处理，因此程序返回false。 所以，当我们要把某个类的对象当成HashMap的key，或者要将这个类的对象放入HashSet中保存时，重写该类的equals(Object obj)方法和hashCode()方法很重要，而且这两个方法的返回值必须保持一致：当该类的两个hashCode()返回值相同时，他们通过equals()方法比较也应该返回true。 下面程序就重写了hashCode()和equals()方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Name &#123; private String first; private String last; public Name(String first, String last) &#123; this.first = first; this.last = last; &#125; // 根据 first 判断两个 Name 是否相等 public boolean equals(Object o) &#123; if (this == o) &#123; return true; &#125; if (o.getClass() == Name.class) &#123; Name n = (Name)o; return n.first.equals(first); &#125; return false; &#125; // 根据 first 计算 Name 对象的 hashCode() 返回值 public int hashCode() &#123; return first.hashCode(); &#125; public String toString() &#123; return "Name[first=" + first + ", last=" + last + "]"; &#125; &#125; public class HashSetTest2 &#123; public static void main(String[] args) &#123; HashSet&lt;Name&gt; set = new HashSet&lt;Name&gt;(); set.add(new Name("abc" , "123")); set.add(new Name("abc" , "456")); System.out.println(set); &#125; &#125; 这个程序的主方法先将第一个Name对象添加到HashSet中，该Name对象的first实例的变量值为“abc”，接着再试着将一个first为”abc”的Name对象添加到HashSet中，此时无法将新的Name对象添加到该HashSet中 String StringBuffer StringBuilder的区别？ 线程安全性 用处 String 适用于少量的字符串操作的情况 StringBuffer 安全 适用于多线程下字符缓冲区进行大量操作的情况 StringBuilder 不安全 适用于单线程下在字符缓冲区进行大量操作的情况 String：被final修饰，字符串常量，字符串长度不可变。Java中对String对象的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。 StringBuffer和StringBuilder：对象都是变量。StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象，不进行创建和回收的操作，所以执行速度比String快。但是StringBuffer是线程安全的，所以运行速度慢一点。 三者在运行速度方面，StringBuilder最快、String最慢。 Java多线程机制，实现多线程的方式？Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。 方式一：实现Runnable接口并重写run()方法适用于类已经继承了另一个类，就无法继承Thread类，此时必须实现一个Runnable接口。 方式二：使用Thread：继承Thread类方式三：使用ExecutorService、Callable、Future实现有返回结果的多线程线程有几种状态？Java线程阻塞调用wait函数和sleep的区别和联系，还有函数yield、notify等的作用？有五种生命状态：新建(New)、就绪(Runnable)、运行(Running)、阻塞(Blocked)、死亡(Dead)。 wait函数是Object的方法，sleep是Thread类的方法 wait()方法是：当前线程暂时退出并让出同步资源锁，以便其他正在等待该资源的线程得到该资源进而运行，只有调用二零notify()方法，之前调用wait()的线程才会解除wait状态。（notify只是唤醒之前调用wait的线程，不会分配任务） sleep()方法是：当前线程主动让出CPU，在sleep指定时间后CPU再回到该线程继续执行。不会释放对象锁。 notify()、notifyAll()是Object类的方法，yield()是Thread类的方法。 调用过wait()方法的对象可以通过调用notify()唤醒，notifyAll是唤醒所有的线程。yield()是暂停线程，不过不能指定暂停的时间，也不能保证当前线程马上停止；yield()只是让线程从运行态转变为就绪态。 Java中的同步机制 Synchronized，锁机制？Synchronized关键字可以作为函数的修饰符、也可做为函数内的语句，也就是同步方法和同步语句代码块。 同步方法，它锁定的是调用这个同步方法的对象。下面的method()方法被相同对象在不同线程中执行会形成互斥，达到同步的效果。 123Public synchronized void method()&#123; //…. &#125; 同步语句代码块，锁就是so这个对象，谁拿到这个对象就能运行他所控制的那段代码。当有一个明确的对象作为锁时，就能够这样写程式。 123456public void method(SomeObject so) &#123; synchronized(so) &#123; //….. &#125; &#125; Java对象的四种引用类型从JDK1.2开始，把对象的引用分为4种级别、从而使程序能更加灵活地控制对象的生命周期。这四种级别由高到低依次为：强引用、软引用、弱引用、虚引用。 强引用（StrongReference） 使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存不足时，Java虚拟机抛出OutOfMemoryError错误，使程序异常终止，也不回收具有强引用的对象来解决内存不足的问题。 软引用（SoftReference） 如果一个对象只有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。 弱引用（WeakReference） 弱引用和软引用的区别是：只具有弱引用的对象拥有更短的生命周期。在垃圾回收器线程扫描它所管理的内存区域过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。 虚引用（PhantomReference） 字如其名，就是形同虚设，与强软弱引用都不一样。虚引用不会决定对象的生命周期。如果一个对象仅有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。 Java中的异常机制？ 异常机制的层次结构 Java中，所有的异常对象都派生自Throwable类，如果Java中内置的异常类不能满足要求，可以自定义异常类，只需要继承Throwable类即可。Throwable类有两个重要的子类： Error(错误)：Java内部错误 Exception(异常)：程序本身可以处理的异常 异常的处理过程 抛出异常：throws、throw关键字 使用throws将程序中可能遇到的异常向上抛出，而本身不做处理。throw是主动抛出异常，一般和if语句配合比较多。 捕获异常（处理异常） 抛出的异常，总是需要处理的。使用try{}catch{}关键字，try中代码表示可能出现异常的代码块，catch中的代码块表示捕捉到该异常之后的后续操作。finally关键字用来完成对资源的关闭。 Comparable接口和Comparator接口实现比较的区别和用法？实现接口的同时，使用泛型规定要进行比较的对象所属的类。Comparable是位于lang包下，实现compareTo()方法；Comparator是位于util包下，实现compare()方法。 Java的23种设计模式中常用的设计模式？ 创建者模式：单例设计模式、抽象工厂模式、建造者模式、工厂模式、原型模式 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式 行为型模式：模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式 SSM框架面试简单介绍一下对springMVC的理解？ 基于组件技术。全部的应用对象，无论控制器和视图，还是业务对象，都是Java组件 不依赖于Servlet API 可以任意使用各种视图技术，不仅仅局限于JSP 支持各种请求资源的映射策略 应该是易于扩展的 SpringMVC的工作流程？ 用户发送请求到前端控制器DispatcherServlet DispatcherServlet解析收到的请求，得到资源标识符URI，调用HandlerMapping获得该Handler，并将控制器controller返回给DispatcherServlet DispatcherServlet通过HandlerAdapter适配器调用处理器 执行处理器Controller，返回模型和视图（MV） HandlerAdapter将MV返回给DispatcherServlet DispatcherServlet将MV传给ViewReslover视图解析器，返回具体的View DispatcherServlet将模型数据填充到视图中。 如果也用过struts2，简单介绍一下SpringMVC和struts2的区别 SpringMVC的入口是DispatcherServlet前端控制器，而struts2是一个过滤器 SpringMVC是一个url对应一个方法，struts2是基于类开发 SSM优缺点，使用场景？ mybatis可以优化sql，可以减少查询字段 hibernate数据库移植性比较好，mybatis在不同的数据库需要写不同的sql 简单介绍对mybatis的理解？ SqlMapConfig.xml作为mybatis的全局配置文件 mapper.xml是sql映射文件，配置操作数据库的sql语句 使用SqlSessionFactory会话工厂创建sqlSession来操作数据库 JDBC操作数据库的步骤？ 加载数据库驱动 获取数据库连接 创建statement对象 定义sql语句 使用preparedStatement设置sql语句 使用statement执行sql 解析结果 关闭资源 Servlet的doget与dopost的区别？ doget提交数据有大小限制，dopost没有 doget会将key和value明文显示；dopost传递数据是通过http请求附件，不会明文显示 doget安全性不如dopost 什么是OKHttp？OKHttp和HttpClient类似，是一个Http客户端。 什么是JSON？JSON用来取代xml的数据结构，它比xml传输数据将减少更多流量，速度更快。 JSON就是一段字符串，其中{}表示对象，[]中表示数组，””内是属性或者值，：表示后者是前者的值。 什么是key-value数据库？键值数据库，不能使用sql的查询语言。它的查询必须是要key已知的情况下，访问速度比关系型数据库快，不过要已知的key是限制。 数据库事务执行的四个基本要素？ACID，原子性，一致性，隔离性，持久性。 原子性：整个事务中的所有操作，要么全部执行，要不全部不执行 一致性：事务必须始终保持一致 隔离性：事务执行必须隔离 持久性：数据库事务操作的结果不会回滚 Java虚拟机运行时数据区？有虚拟机栈、本地方法栈、程序计数器、方法区、堆。 程序计数器：由于Java的多线程是线程轮流切换并分配处理器执行时间的方式来实现的。在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此，为了线程在切换后能恢复之前的执行位置，需要给每条线程都有一个独立的程序计数器，各条线程之间计数器互不影响。 Java虚拟机栈：Java虚拟机也是私有的，它的生命周期和线程一样。每个方法执行时都会创建栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行完成的过程，就对应着一个栈帧在Java虚拟机栈中入栈到出栈的过程。 本地方法栈：与虚拟机栈发挥的作用是非常相似的。他们的区别是Java虚拟机执行java方法服务，本地方法栈是执行native方法服务。 Java堆：被所有线程共享，在虚拟机启动时创建。此内存中存放的是对象实例。所有的对象实例和数组都要在堆上分配。GC堆的主要处理区域就是Java堆。由于现在的收集器基本都是分代收集算法，可以分为新生代和老年代，这样分始终是为了更快的分配和回收内存。 方法区：和Java堆类似都是被所有线程所共享的，它用于存储已加载的类的信息、常量、静态变量、即时编译器编译后的代码等数据。 运行时常量池：用于存放编译期生成的各种字面量和符号引用。 如何理解Java接口？Java接口是功能的抽象，没有具体的实现。降低了耦合性。解决了Java不能多继承的弊端。 Java接口的定义是：使用interface关键字。其中的变量被固定的public static final修饰符修饰，方法被public abstract修饰。 如果某个非抽象类需要实现某个接口，那么必须重写其中的所有方法。 抽象类和接口的区别：抽象类不能多继承，接口可以多实现。抽象类中可以有实体方法，接口中全是抽象方法。当不仅需要定义共性行为，还要有独立方法时，采用抽象类。 如何理解Java四大特性？（抽象、封装、继承、多态） 抽象：同一类事物共有的特征和方法的集合。具体实现是使用抽象类和接口。抽象的好处是下次写类似的项目，可以再使用抽象层。 封装：把对象的特征和方法隐藏起来，不让外界能直接访问到；需要通过该类提供的方法来访问内部信息。 继承：子类通过继承来拥有父类的特征和提供的非私有的方法，提高代码复用性。缺点是也提高了耦合性。 子类继承父类的关系是is-a，父类更通用，子类更具体。子类可以重写父类的方法，也可以有自己的方法和属性。 多态：定义一个父类，多个父类对象的引用指向不同的子类，这些对象可以调用子类重写的父类方法。 多态的作用是消除类型之间的耦合关系。 多态存在的三个条件：继承，重写，父类对象的引用指向子类。]]></content>
      <categories>
        <category>编程基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一些快捷键]]></title>
    <url>%2F2018%2F10%2F19%2F%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[IDEA ctrl+enter在当前行下面新增一行，跳至该行 shift+enter在当前行上面增加一行并跳至该行 ctrl+←/→进行逐词移动 ctrl+shift+←/→进行逐词选择 ctrl+↑/↓移动当前显示区域 ctrl+shift+↑/↓移动当前行 xml中添加注释：ctrl+/ ctrl+p：查看默认方法 ctrl+o：快速查看可以重写的方法 Alt+数字 :用来跳转例如project的窗口 文件之间跳转：alt+←/→ Ctrl+N ： 快速搜索打开指定class 文件和编辑的跳转：Alt+1和esc 文件搜索：ctrl+shift+n shift+f6：重构变量（名称） 抽取： 抽取变量：ctrl+v 抽取静态变量：ctrl+c 抽取成员变量：ctrl+f 抽取函数：ctrl+alt+m alt+insert：打开选择面板（用来写一些必要的函数，例如get和set等） ctrl+alt+t：try{}catch{}、if()等 eclipse 快速run程序：shift+alt+x 快速get和set：alt+shift+s Sublime Text3 添加html注释：ctrl+？ 删除一行：ctrl+x ctrl+enter在当前行下面新增一行，跳至该行 ctrl+shift+enter在当前行上面增加一行并跳至该行 ctrl+shift+↑/↓移动当前行 复制当前行，并插入下一行：ctrl+shift+d]]></content>
      <categories>
        <category>工具的使用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java反射机制]]></title>
    <url>%2F2018%2F10%2F16%2FJava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[Java反射机制Java反射机制是在运行状态中，对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。 用来编写一些通用性较高的代码或者框架的时候使用。 Java反射对象： Class：Class类的实例表示正在运行的Java应用程序中的类和接口 Constructor：类的单个构造方法的信息以及对它的访问权限 Field：提供有关类或接口的单个字段的信息，以及对它的动态访问权限 Method：提供关于类或接口上单独某个方法的信息 Class类 下面是通过第三种方法获得有参或者无参的构造方法要注意的是Class.forName()需要抛出异常，而且其中的字符串是类的所在位置，注意它的写法“.”。 12345678910111213141516171819202122232425262728import java.lang.reflect.Constructor;import org.junit.Test;public class ConstructorTest &#123; @Test /** * 获得无参数的构造方法 * */ public void demo1() throws Exception &#123; Class class1 = Class.forName(&quot;reflect.Person&quot;); Constructor c = class1.getConstructor(); //相当于Person person = new Person(); Person person = (Person) c.newInstance(); person.eat(); &#125; @Test /* * 获得有参数的构造方法 */ public void demo2() throws Exception&#123; Class class2 = Class.forName(&quot;reflect.Person&quot;); Constructor constructor = class2.getConstructor(String.class,String.class); //Person person = new Person(&quot;张三&quot;,&quot;男&quot;); Person person = (Person) constructor.newInstance(&quot;张三&quot;,&quot;男&quot;); System.out.println(person); &#125;&#125; Person类： 12345678910111213141516171819202122232425262728293031323334353637383940public class Person &#123; private String name; private String sex; public Person() &#123; super(); &#125; public Person(String name, String sex) &#123; this.name = name; this.sex = sex; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public void eat() &#123; System.out.println(&quot;吃饭&quot;); &#125; @Override public String toString() &#123; return &quot;Person [name=&quot; + name + &quot;, sex=&quot; + sex + &quot;]&quot;; &#125; &#125; Constructor类c是字节码文件。getDeclaredFields()获得私有的。 反射Constructor类的步骤： 先加载字节码文件(Class.forName(“”)) 获得构造方法(class1.getConstructor(“”)/class1.getConstructors()获得所有构造方法) 通过构造方法对象调用newInstance()方法实例化对象 此对象可以调用它的方法 Field类 FieldTest源码：123456789101112131415161718192021222324252627282930313233package reflect;import java.lang.reflect.Field;import org.junit.Test;public class FieldTest &#123; @Test public void demo() throws Exception&#123; Class c = Class.forName(&quot;reflect.Person&quot;); Field field = c.getField(&quot;age&quot;); Person person = (Person)c.newInstance(); field.set(person, 20); Object object = field.get(person); System.out.println(object); &#125; @Test public void demo2() throws Exception&#123; Class c = Class.forName(&quot;reflect.Person&quot;); Field field = c.getDeclaredField(&quot;name&quot;); Person person = (Person)c.newInstance();// 私有属性要多一个设置访问权限 field.setAccessible(true); field.set(person, &quot;卡兹克&quot;); Object object = field.get(person); System.out.println(object); &#125;&#125; 反射Filed类的步骤（包括私有变量）： 先加载字节码文件(Class.forName(“”)) 通过字节码文件获得Field对象(class1.getField(“”)/class1.getDeclaredField(“”)获得私有/class1.getFields()获得所有成员变量) 如果是私有变量需要添加这一步：Field对象调用setAccessible(boolean)设置是否可以访问 通过字节码文件调用newInstance()方法实例化对象 Field对象调用set(obj,value)方法来设置变量值。这里的obj参数就是上面实例化的对象 Field对象调用get(obj)方法来获取变量值。这里的obj参数就是上面实例化的对象 Method类 MethodTest源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package reflect;import org.junit.Test;import java.lang.reflect.Method;public class MethodTest &#123; @Test //测试公有方法 public void demo1() throws Exception &#123; Class class1 = Class.forName(&quot;reflect.Person&quot;); //通过字节码文件实例化对象 Person person = (Person)class1.newInstance();// 获得公有的方法 Method method = class1.getMethod(&quot;eat&quot;); //执行该方法 method.invoke(person); //Person.eat(); &#125; //测试私有方法 @Test public void demo2() throws Exception&#123; Class class1 = Class.forName(&quot;reflect.Person&quot;);// 实例化 Person person = (Person)class1.newInstance();// 获得私有方法 Method method = class1.getDeclaredMethod(&quot;lashi&quot;);// 设置私有属性的访问权限 method.setAccessible(true);// 执行该方法 method.invoke(person); &#125; @Test// 测试带参数的私有方法 public void demo3() throws Exception&#123; Class class1 = Class.forName(&quot;reflect.Person&quot;);// 实例化 Person person = (Person)class1.newInstance();// 获得带参数的方法，并指定参数类型的class Method method = class1.getDeclaredMethod(&quot;sayHello&quot;,String.class);// 设置方法访问权限 method.setAccessible(true);// 执行方法 System.out.println(method.invoke(person, &quot;Jack&quot;)); &#125;&#125; 反射Method类的步骤： 先加载字节码文件(Class.forName(“”)) 实例化对象：class1.newInstance() 获得Method类对象，通过getMethod(“”)/getDeclaredMethod(“”) 如果方法是私有的必须要设置访问权限：method.setAccessible(true) 方法执行，method.invoke(person,参数);这里的invoke方法返回的是一个obj对象]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML]]></title>
    <url>%2F2018%2F10%2F15%2FHTML%2F</url>
    <content type="text"><![CDATA[HTMLHypeerText Markup Language:超文本 标记 语言 &lt;html&gt;&lt;/html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 一个简单的html表单12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;表单&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=""&gt; &lt;input type="text" name="这是一个输入框" maxlength="10" /&gt; &lt;br&gt; &lt;input type="password" value="我是默认密码"&gt; &lt;br&gt; &lt;input type="radio" checked="" name="gender"&gt;男 &lt;input type="radio" name="gender"&gt;女 &lt;br&gt; &lt;input type="checkbox" name="" value="0"&gt;电影 &lt;input type="checkbox" checked name="" value="1"&gt;音乐 &lt;input type="checkbox" name="" value="2"&gt;美术 &lt;br&gt; &lt;input type="button" name="" value="我是按钮"&gt; &lt;br&gt; &lt;input type="number" name=""&gt; &lt;br&gt; &lt;input type="date" name=""&gt; &lt;br&gt; &lt;input type="color" name=""&gt; &lt;br&gt; &lt;input type="range" name="" max="5" min="1"&gt; &lt;br&gt; &lt;input type="email" name=""&gt; &lt;br&gt; &lt;input type="submit" name=""&gt; &lt;br&gt; &lt;input type="url" name=""&gt; &lt;br&gt; &lt;input type="file" name="" multiple="multiple"&gt; &lt;br&gt; &lt;select&gt; &lt;option value="0"&gt;苹果&lt;/option&gt; &lt;option value="1"&gt;葡萄&lt;/option&gt; &lt;option value="2"&gt;香蕉&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;style&gt; textarea&#123; resize: none; &#125; &lt;/style&gt; &lt;textarea cols="12" rows="2"&gt;我是一段文本&lt;/textarea&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 如下是当前html的表现： 如下是表单&lt;form&gt;中的属性使用： 如下是html表格： html总结： CSSCascading Style Sheets:层叠样式表可以让相同的一个页面在不同的浏览器中呈现相同的样式。 为什么使用CSS？ 样式定义如何显示HTML元素 是为了解决内容与表现分离的问题 内容主要指HTML中的元素 表现是内容在浏览器中呈现的样式 CSS基础语法 background-color 样式属性 : 操作符 ; 分隔符 #FFFFFF 样式值 CSS内联级别高于外联级别 CSS选择器 ID选择器 元素选择器 类选择器 属性选择器 一般选用属性选择器和类选择器即span和.class还有三个子元素选择器： A E 后代选择器 A+E 兄弟选择器 A&gt;E 子元素选择器 伪类 :link 向未被访问的链接添加样式 :hover 当鼠标悬浮在元素上方时，向元素添加样式 :active 向被激活的元素添加样式 :visited 向已被访问的链接添加样式 伪元素(添加两个虚拟的子元素) ::before ::after 选择器的优先级别： 类选择器的优先级别高于元素选择器 id选择器的优先级别高于类选择器和元素选择器 内联样式&gt;id选择器&gt;类选择器&gt;元素选择器 带有!import是提高至最高级 CSS样式背景文本字体列表表格如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;表格&lt;/title&gt; &lt;style&gt; table,th,td &#123; border: 1px lightgray solid; border-collapse: collapse; &#125; table&#123; width: 80%; margin: 0px auto; &#125; th,td&#123; padding: 5px; text-align: center; &#125; th&#123; background-color: lightcoral; color: white; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt; &lt;tr&gt; &lt;th&gt;英雄名称&lt;/th&gt; &lt;th&gt;定位&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;放逐之刃&lt;/td&gt; &lt;td&gt;Top&lt;/td&gt; &lt;td&gt;6300&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;狂战士&lt;/td&gt; &lt;td&gt;Jungle&lt;/td&gt; &lt;td&gt;1350&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;圣枪游侠&lt;/td&gt; &lt;td&gt;ADC&lt;/td&gt; &lt;td&gt;6300&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; CSS布局两行三列布局：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;两行三列布局&lt;/title&gt; &lt;style&gt; html,body&#123; margin: 0px; &#125; header&#123; background-color: lightcoral; height: 150px; &#125; #container&#123; background-color: lightgray; height: 450px; &#125; nav&#123; background-color: darkgreen; height: 100%; width: 150px; float: left; &#125; aside&#123; background-color: blue; height: 100%; width: 150px; float: right; &#125; article&#123; background-color: aqua; height: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt;&lt;/header&gt;&lt;div id=&quot;container&quot;&gt; &lt;nav&gt;&lt;/nav&gt; &lt;aside&gt;&lt;/aside&gt; &lt;article&gt;&lt;/article&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 三行两列布局：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;三行两列布局&lt;/title&gt; &lt;style&gt; html,body&#123; margin: 0px; &#125; header&#123; background-color: lightcoral; height: 150px; &#125; #container&#123; background-color: lightgray; height: 450px; &#125; nav&#123; background-color: darkgreen; height: 100%; width: 150px; float: left; &#125; article&#123; background-color: aqua; height: 100%; margin-left: 150px; &#125; footer&#123; background-color: firebrick; height: 50px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt;&lt;/header&gt;&lt;div id=&quot;container&quot;&gt; &lt;nav&gt;&lt;/nav&gt; &lt;article&gt;&lt;/article&gt;&lt;/div&gt;&lt;footer&gt;&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; CSS盒子模型padding: top right bottom left; CSS中的floatfloat中的四个参数： float: left float: right float: none float: inherit float属性实现文本环绕效果清除浮动的解决办法 CSS的position属性 static relative absolute fixed sticky static静态定位 relative相对定位 absolute绝对定位相对于最近的祖先元素定位（没有就相对于body）。 fixed固定定位不会随着视口滚动而滚动。继承absolute特点。与absolute绝对定位的区别就在于相对谁做绝对滚动。例如：一些小说网站上，右下角的贪玩蓝月广告。 sticky磁贴定位 一个最左侧fix固定定位导航栏例子:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;position&lt;/title&gt; &lt;style&gt; *&#123; padding: 0; margin: 0; &#125; .page&#123; width: 100%; height: 1080px; background: url(&quot;./images/background.png&quot;) center top no-repeat; &#125; .nav&#123; width: 160px; height: auto; position: fixed; left: 0; top: 50%; margin-top: ; &#125; .nav-li&#123; width: 160px; height: auto; border-bottom: 1px solid #FFF; background: #333; text-align: center; line-height: 40px; color: #FFF; cursor: pointer; &#125; .nav-li ul&#123; width: 160px; height: auto; background: #FFF; display: none; &#125; .nav-li ul li&#123; width: 160px; height: 40px; border-bottom: 1px dashed #666; color: #333; text-align: center; line-height: 40px; position: relative; &#125; .nav-li ul li:hover .list-3&#123; display: block; &#125; .tit&#123; width: 160px; height: 40px; &#125; .nav-li:hover ul&#123; display: block; &#125; .list-3&#123; width: 160px; height: auto; position: absolute; left: 150px; top: 0px; display: none; &#125; .list-3Dom&#123; width: 160px; height: 40px; background: #444; border-bottom: 1px solid #FFF; text-align: center; line-height: 40px; color: #FFF; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;page&quot;&gt; &lt;div class=&quot;nav&quot;&gt; &lt;div class=&quot;nav-li&quot;&gt; &lt;div class=&quot;tit&quot;&gt;这是一个导航&lt;/div&gt; &lt;ul&gt; &lt;li&gt; 二级栏目 &lt;div class=&quot;list-3&quot;&gt; &lt;div class=&quot;list-3Dom&quot;&gt; 三级栏目 &lt;/div&gt; &lt;div class=&quot;list-3Dom&quot;&gt; 三级栏目 &lt;/div&gt; &lt;div class=&quot;list-3Dom&quot;&gt; 三级栏目 &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; 二级栏目 &lt;div class=&quot;list-3&quot;&gt; &lt;div class=&quot;list-3Dom&quot;&gt; 三级栏目 &lt;/div&gt; &lt;div class=&quot;list-3Dom&quot;&gt; 三级栏目 &lt;/div&gt; &lt;div class=&quot;list-3Dom&quot;&gt; 三级栏目 &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; 二级栏目 &lt;div class=&quot;list-3&quot;&gt; &lt;div class=&quot;list-3Dom&quot;&gt; 三级栏目 &lt;/div&gt; &lt;div class=&quot;list-3Dom&quot;&gt; 三级栏目 &lt;/div&gt; &lt;div class=&quot;list-3Dom&quot;&gt; 三级栏目 &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;nav-li&quot;&gt; &lt;div class=&quot;tit&quot;&gt;这是一个导航&lt;/div&gt; &lt;ul&gt; &lt;li&gt; 二级栏目 &lt;/li&gt; &lt;li&gt; 二级栏目 &lt;/li&gt; &lt;li&gt; 二级栏目 &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;nav-li&quot;&gt; &lt;div class=&quot;tit&quot;&gt;这是一个导航&lt;/div&gt; &lt;ul&gt; &lt;li&gt; 二级栏目 &lt;/li&gt; &lt;li&gt; 二级栏目 &lt;/li&gt; &lt;li&gt; 二级栏目 &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;nav-li&quot;&gt; &lt;div class=&quot;tit&quot;&gt;这是一个导航&lt;/div&gt; &lt;ul&gt; &lt;li&gt; 二级栏目 &lt;/li&gt; &lt;li&gt; 二级栏目 &lt;/li&gt; &lt;li&gt; 二级栏目 &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;nav-li&quot;&gt; &lt;div class=&quot;tit&quot;&gt;这是一个导航&lt;/div&gt; &lt;ul&gt; &lt;li&gt; 二级栏目 &lt;/li&gt; &lt;li&gt; 二级栏目 &lt;/li&gt; &lt;li&gt; 二级栏目 &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编程基础笔记（一）]]></title>
    <url>%2F2018%2F10%2F13%2F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[byte类型取值范围为什么是127到-128？因为第一位是符号位，所以二进制数0111 1111是表示最大的正数：127；计算机中存储的是补码，正数的补码（反码）还是原码，0111 1111 。既然有127那么就有-127。 -127的原码是1111 1111，负数的补码是原码取反(符号位不取反)加1。 -127的原码 1111 1111，反码 1000 0000 ，补码 1000 0001。 下面解释-128从哪来的: -0的原码 1000 0000，反码 1111 1111 ，补码: 反码加1以后就是1000 0000。 +0的原码 0000 0000 反码补码都0000 0000 。因为日常生活中没有-0， 所以规定0在计算机中表示为0000 0000。 以0开头的补码已经全部使用，因为正数原码补码都一样，所以0000 0000到0111 1111补码已经全部占用，表示0~127。以1开头的原码，即补码1000 0001到补码1111 1111是表示-127到-1， -1 -127 原码 1000 0001 1111 1111 补码 1111 1111 1000 0001 这时还剩下一串补码 1000 0000就把这串码表示成-128，也可以这样想，127……1存在，所以也有相应的，-1……-127存在，除去0，补码还剩一串 1000 0000所以规定为-128。 Java基础访问控制修饰符 即访问权限排序：public&gt;protected&gt;default&gt;private Java运算符算术运算符：例如数学中的运算符，它和数学中的作用是一样的。不过它多了一组++和–。例如：下面的Test类运算结果是：a++ = 10;a– = 11;d++ = 25;++d = 27; 12345678910111213public class Test &#123; public static void main(String[] args) &#123; int a = 10; int d = 25; System.out.println("a++ = " + (a++) ); System.out.println("a-- = " + (a--) ); // 查看 d++ 与 ++d 的不同 System.out.println("d++ = " + (d++) ); System.out.println("++d = " + (++d) ); &#125;&#125; 由此例能看出，++与–是一种运算，在输出语句中，它的运算优先级和++与–所在的位置前后有关。当运算符在前，就先对这个数进行操作再进行输出语句；运算符在后，就先运行输出语句，再计算。而且a++与++a的运行结果都是a+1。 例如：selfAddMinus类 1234567891011public class selfAddMinus&#123; public static void main(String[] args)&#123; int a = 5;//定义一个变量； int b = 5; int x = 2*++a; int y = 2*b++; System.out.println("自增运算符前缀运算后a="+a+",x="+x); System.out.println("自增运算符后缀运算后b="+b+",y="+y); &#125;&#125; 结果是a=6,x=12;b=6,y=10; 关系运算符!= ; &gt;= ; &lt;=; 赋值运算符+= ：他把左操作数和右操作数相加赋值给左操作数。c+=a等价于c=c+a。-=、*=、/=、&lt;&lt;=、&gt;&gt;=、&amp;=、^=、|= 都是类似的，左操作数在前，右操作数在后，操作符在中间。不过这里的&gt;&gt;=和&lt;&lt;=是箭尖指的方向就是这个数的十六进制中每一位的位移方向。 Java循环do…while循环它于while的区别是，do…while语句能在即使条件不满足的情况下，也执行一次。 Java增强for循环1234for(声明语句 : 表达式)&#123; //代码句子&#125; 声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。它的限定域在循环代码块，它的值和此时数组元素的值相同。 表达式：是要访问的数组名，或者是能返回数组的方法。 continue关键字在do..while语句中，执行continue就跳转到while判断语句； 在for循环中，执行continue就跳转到更新语句。 数据库初识数据库表可以使用什么赋予别名？ tbl_name alias_name tbl_name AS alias_name 有关预编译SQL的说法错误的是哪一个？（A）A:预编译SQL的占位符既可以代替数据库，也可以替代表达式的数据，甚至是子查询语句 B:预编译SQL可以被PreparedStatement反复执行 C:预编译SQL语句在PreparedStatement对象创建之后就被传递给数据库解析，之后PreparedStatement执行预编译的时候，其实传递给数据库的只有占位符的参数 D:预编译SQL的安全性好，可以低于数据库脚本的注入攻击，而这是Statement不具备的 不是MySql的退出命令的是？（C）A: mysql &gt; quit; B: mysql &gt; \q; C: mysql &gt; die; D: mysql &gt; exit; 以下关于数据库连接池的说法错误的是？（B）A: 不适用数据库连接池，每次访问都需要创建连接，极大地浪费数据库资源，造成数据库服务器的内存溢出 B: 使用数据库连接池相对于传统方式并不会提高系统的执行效率 C: 数据库连接池是创建和管理连接欸数据库缓冲池的技术，这些连接准备好被任何需要使用它们的线程使用 D: C3P0也是数据库连接池的一种 如何创建C3P0的数据库连接池对象？ComboPooledDataSource 有关Connection描述错误的是？（B）A: 只有MySQL数据库的JDBC程序需要创建Connection对象，其他数据库的JDBC程序不需要创建Connection对象就可以执行 B: Connection是Java程序与数据库建立的连接对象，这个对象只能用来连接数据库，不能执行SQL语句 C: JDBC的数据库事务控制要靠Connection对象完成 D: Connection对象使用完毕后要及时关闭，否则会对数据库造成负担 以下关于Class对象说法正确的是？（B）A: 类的构造方法编译后可以通过class对象获取 B: 类的字节码文件被加载到内存中所形成的一个对象，称为Class对象 C: 类中的属性和普通方法编译为字节码后可以通过class对象获取 D: 类文件就可以成为class对象 包含事务控制方法setAutoCommit,commit,rollback的类是Connection在测试方法中，如果某个方法要优先执行，需要使用@Before注解##]]></content>
      <categories>
        <category>编程基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IDEA使用技巧]]></title>
    <url>%2F2018%2F10%2F12%2FIDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[快捷键搜索action：ctrl+shift+a 定位代码 Alt+数字 :用来跳转例如project的窗口 文件之间跳转 Ctrl+N ： 快速搜索打开指定class 文件和编辑的跳转：Alt+1和esc 文件搜索：ctrl+shift+n shift+f6：重构变量（名称） 抽取： 抽取变量：ctrl+v 抽取静态变量：ctrl+c 抽取成员变量：ctrl+f 抽取函数：ctrl+alt+m IDEA添加方法注释 ctrl+shift+a搜索live temp；（带setting的） 在template text:中添加 12345/** *@Description $description$$param$ *@return $return$ **/ 点击edit variables，在param中添加 1groovyScript(&quot;def result=&apos;&apos;; def params=\&quot;$&#123;_1&#125;\&quot;.replaceAll(&apos;[\\\\[|\\\\]|\\\\s]&apos;, &apos;&apos;).split(&apos;,&apos;).toList(); for(i = 0; i &lt; params.size(); i++) &#123;result+=&apos; * @param &apos; + params[i] + &apos;\\t&apos; + ((i &lt; params.size() - 1) ? &apos;\\n&apos; : &apos;&apos;)&#125;; return result&quot;, methodParameters())]]></content>
      <categories>
        <category>工具的使用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[淘宝电商项目]]></title>
    <url>%2F2018%2F10%2F03%2F%E7%94%B5%E5%95%86%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[nginx的安装nginx安装包 配置信息 配置nginx解压缩后目录下的conf目录中的nginx.conf： 12345678910111213141516171819202122232425262728293031 #location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;============vhost=================== include vhost/*.conf; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; 在conf目录下新建vhost文件夹，在文件夹中添加abc.com: 123456789101112131415161718server &#123; listen 80; autoindex off; server_name abc.com; access_log c:/access.log combined; index index.html index.htm index.jsp index.php; #error_page 404 /404.html;if ( $query_string ~* &quot;.*[\;&apos;\&lt;\&gt;].*&quot; )&#123; return 404; &#125; location ~ /(mmall_fe|mmall_admin_fe)/dist/view/* &#123; deny all; &#125; location / &#123; root C:\ftpfile\img; add_header Access-Control-Allow-Origin *; &#125; &#125; 在C:\Windows\System32\drivers\etc中打开host，在最后一行添加127.0.0.1 abc.com 在Windows PowerShell中进入nginx的目录下，使用.\nginx -t测试配置文件是否成功；再用 tasklist /fi “imagename eq nginx.exe”查看已经开启的进程。 如果在浏览器中输入abc.com能看见nginx的提示成功页面；再输入abc.com/a.jpg出现404故障，就在进程管理中关闭所有nginx的进程。再重新开启nginx 数据库的创建创建mmall数据库，在库中有八张表： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122create table mmall_user( id int(11) not null auto_increment comment &apos;用户表id&apos;, username varchar(50) not null comment &apos;用户名&apos;, password varchar(50) not null comment &apos;用户密码，MD5加密&apos;, email varchar(50) default null, phone varchar(20) default null, question varchar(100) default null comment &apos;找回密码问题&apos;, answer varchar(100) default null comment &apos;找回密码答案&apos;, role int(4) not null comment &apos;角色0-管理员，1-用户&apos;, create_time datetime not null comment &apos;创建时间&apos;, update_time datetime not null comment &apos;最后一次更新时间&apos;, primary key (id), unique key user_name_unique (username) using btree) ENGINE=InnoDB auto_increment=21 default charset=utf8; create table mmall_category( id int(11) not null auto_increment comment &apos;类别id&apos;, parent_id int(11) default null comment &apos;父类别id当id=0时说明是根节点，一级类别&apos;, name varchar(50) default null comment &apos;类别名称&apos;, status tinyint(1) default &apos;1&apos; comment &apos;类别状态1-正常，2-已废弃&apos;, sort_order int(4) default null comment &apos;排序编号，同类展示顺序，数值相等则自然排序&apos;, create_time datetime default null comment &apos;创建时间&apos;, update_time datetime default null comment &apos;更新时间&apos;, primary key (id) )ENGINE=InnoDB AUTO_INCREMENT=100032 DEFAULT CHARSET=utf8; create table mmall_product( id int(11) not null auto_increment comment &apos;商品id&apos;, category_id int(11) not null comment &apos;分类id，对应mmall_category表的主键&apos;, name varchar(100) not null comment &apos;商品名称&apos;, subtitle varchar(200) default null comment &apos;商品副标题&apos;, main_image varchar(500) default null comment &apos;产品主图，url相对地址&apos;, sub_image text comment &apos;图片地址，json格式，扩展用&apos;, detail text comment &apos;商品详情&apos;, price decimal(20,2) not null comment &apos;价格，单位-元，保留两位小数&apos;, stock int(11) not null comment &apos;库存数量&apos;, status int(6) default &apos;1&apos; comment &apos;商品状态，1-在售，2-下架，3-删除&apos;, create_time datetime default null comment &apos;创建时间&apos;, update_time datetime default null comment &apos;更新时间&apos;, primary key (id))ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8; create table mmall_cart( id int(11) not null auto_increment, user_id int(11) not null, product_id int(11) default null comment &apos;商品id&apos;, quantity int(11) default null comment &apos;数量&apos;, checked int(11) default null comment &apos;是否选择，0=未选择，1-已选择&apos;, create_time datetime default null comment &apos;创建时间&apos;, update_time datetime default null comment &apos;更新时间&apos;, primary key (id), key user_id_index (user_id) using btree)ENGINE=InnoDB AUTO_INCREMENT=121 DEFAULT CHARSET=utf8;create table mmall_pay_info( id int(11) not null auto_increment, user_id int(11) default null comment &apos;用户id&apos;, order_no bigint(20) default null comment &apos;订单号&apos;, pay_platform int(10) default null comment &apos;支付平台，1-支付宝，2-微信&apos;, platform_number varchar(200) default null comment &apos;支付宝支付流水号&apos;, platform_status varchar(20) default null comment &apos;支付宝支付状态&apos;, create_time datetime default null comment &apos;创建时间&apos;, update_time datetime default null comment &apos;更新时间&apos;, primary key (id))ENGINE=InnoDB AUTO_INCREMENT=53 DEFAULT CHARSET=utf8;create table mmall_order( id int(11) not null auto_increment comment &apos;订单id&apos;, order_no bigint(20) default null comment &apos;订单号&apos;, user_id int(11) default null comment &apos;用户id&apos;, shipping_id int(11) default null, payment decimal(20,2) default null comment &apos;实际付款金额，单位是元，保留两位小数&apos;, payment_type int(4) default null comment &apos;支付类型，1-在线支付&apos;, postage int(10) default null comment &apos;运费，单位是元&apos;, status int(10) default null comment &apos;订单状态：0-已取消，10-未付款，20-已付款，40-已发货，50-交易成功，60，交易关闭&apos;, payment_time datetime default null comment &apos;支付时间&apos;, send_time datetime default null comment &apos;发货时间&apos;, end_time datetime default null comment &apos;交易完成时间&apos;, close_time datetime default null comment &apos;交易关闭时间&apos;, create_time datetime default null comment &apos;创建时间&apos;, update_time datetime default null comment &apos;更新时间&apos;, primary key (id), unique key order_no_index (order_no) using btree )ENGINE=InnoDB AUTO_INCREMENT=103 DEFAULT CHARSET=utf8; create table mmall_order_item( id int(11) not null auto_increment comment &apos;订单子表id&apos;, user_id int(11) default null, order_no bigint(20) default null, product_id int(11) default null comment &apos;商品id&apos;, product_name varchar(100) default null comment &apos;商品名称&apos;, product_image varchar(500) default null comment &apos;商品图片地址&apos;, current_unit_price decimal(20,2) default null comment &apos;生成订单时的商品价格，单位是元，保留两位小数&apos;, quantity int(10) default null comment &apos;商品数量&apos;, total_price decimal(20,2) default null comment &apos;商品总价，单位是元，保留两位小数&apos;, create_time datetime default null comment &apos;创建时间&apos;, update_time datetime default null comment &apos;更新时间&apos;, primary key (id), key order_no_index (order_no) using btree, key order_no_user_id_index (user_id,order_no) using btree )ENGINE=InnoDB AUTO_INCREMENT=113 DEFAULT CHARSET=utf8; create table mmall_shipping( id int(11) not null auto_increment, user_id int(11) default null comment &apos;用户id&apos;, receiver_name varchar(20) default null comment &apos;收货人姓名&apos;, receiver_phone varchar(20) default null comment &apos;收货人固定电话&apos;, receiver_mobile varchar(20) default null comment &apos;收货人移动电话&apos;, receiver_province varchar(20) default null comment &apos;省份&apos;, receiver_city varchar(20) default null comment &apos;城市&apos;, receiver_district varchar(20) default null comment &apos;区/县&apos;, receiver_address varchar(200) default null comment &apos;详细地址&apos;, receiver_zip varchar(6) default null comment &apos;邮编&apos;, create_time datetime default null comment &apos;创建时间&apos;, update_time datetime default null comment &apos;更新时间&apos;, primary key (id))ENGINE=InnoDB AUTO_INCREMENT=32 DEFAULT CHARSET=utf8; 项目初始化初始化maven项目配置tomcat： 选择自己的tomcat目录，在选项Deployment下没有出现artifacts时，需要在IDEA的setting中找到添加。 windows常用新建文件命令：创建文件夹：md 文件夹名创建空的文件：type nul&gt;文件名创建有内容文件：echo “内容”&gt;文件名查看文件内容：type +文件名查看目录及子文件：dir删除空文件夹：rd 文件夹名删除文件及所有子文件：rd /s/q 文件夹名删除文件：del 文件名 项目的git基本配置：新建.gitignore和README.md文件 type nul&gt;.gitignoretype nul&gt;.README.md 初始化仓库： git init 查看仓库状态： git status 添加进暂存区： git add . 提交到版本库： git commit -m “first commit init project” 关联到远程仓库： git remote add origin git@github.com:Luotianhao343/mmall_learning.git 查看分支： git branch 推送： git pull 强制推送到远程主分支： git push -u -f origin master 查看远程分支; git branch -r 创建分支： git checkout -b v1.0 origin/master 将当前分支推送到远程同名目录下： git push origin HEAD -u]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java基础（十七）]]></title>
    <url>%2F2018%2F09%2F25%2F9.26%2F</url>
    <content type="text"><![CDATA[千里之台起于累土File类用来将文件或者文件夹封装成对象。方便对文件与文件夹的属性信息进行操作。File对象可以作为参数传递给流的构造函数。流不能操作文件夹，不能操作文件属性。 File类是文件和文件夹的抽象形式。 File类的常见方法 创建boolean createNewFile();在指定位置创建文件，如果该文件已经存在，则不创建，返回false。和输出流不一样，输出流对象一建立创建文件，就覆盖之前的文件。boolean mkdir();在指定位置创建目录。boolean mkdirs();创建多级目录。 删除boolean delete();删除指定文件。void deleteOnExit();在程序退出时删除指定文件 判断boolean canExecute();文件是否能被执行boolean exists();文件是否存在isFile();isDirectory();isHidden();isAbsolute()判断文件对象是否是文件或目录时，必须要先判断文件对象封装的内容是否存在。通过exists()判断。 获取信息getName();getPath();getParent();该方法返回绝对路径下的父目录。如果获取的是相对路径，返回null。如果相对路径中有上一层目录，该目录就是返回结果。getAbsolutePath();lastModified();返回此抽象路径名指定文件最后一次被修改的时间。 递归函数自身调用自身，这种表现形式称为递归。递归使用注意： 注意限定 看递归算法：现有一个方法体中调用自身方法体；开始，传入参数，判断是否满足自定义的条件；调用自身方法体，开始执行一个新的方法体；在新的方法体中，继续判断是否满足自定义条件，再调用方法体；直到最后的方法体执行退出，然后返回上一级方法体，执行到结束；再向上返回，执行至结束。 删除一个带内容的目录删除原理：在Windows中，删除目录是从里面往外面删除的。需要用到递归。Java删除不走回收站。 Properties Properties是hashtable的子类。也就是说它具有map集合的特点，而且它里面存储的键值对都是字符串。 Properties是集合中和IO技术结合的集合容器。该对象的特点：可以用于键值对形式的配置文件。在加载数据时都要有固定格式，键=值。有方法： setProperty(String key,String value); getProperty(String key); 练习：记录应用程序运行次数，如果使用次数已到，那么给出注册提示。 很容易能联想到：计数器。该计数器定义在程序中，随着程序的运行而在内存中存在，并进行自增。可是随着该应用程序的退出，该计数器也在内存中消失了。下一次再启动该程序时，又重新开始从0计数。这不能用。应该是，程序即使结束，该计数器的值也存在，下次程序启动会在加载该计数器的值并加1后再重新存储起来。所以要建立一个配置文件，用于记录该软件的使用次数。 使用键值对的形式，这样便于阅读数据，并操作数据。键值对数据是map集合，数据是以文件形式存储，使用io技术。那么io+map–》properties。配置文件可以实现应用程序数据的共享。 123456789101112131415161718192021222324252627282930import java.util.*;import java.io.*;class n1 &#123; public static void main(String[] args) throws IOException&#123; Properties prop = new Properties(); File file = new File(&quot;count.ini&quot;); if(!file.exists())&#123; file.createNewFile(); &#125; FileInputStream fis = new FileInputStream(file); prop.load(fis); int count = 0; String value = prop.getProperty(&quot;time&quot;); if(value!=null)&#123; count = Integer.parseInt(value); if(count&gt;=5)&#123; System.out.println(&quot;您好，使用次数已到，请付钱&quot;); return; &#125; &#125; count++; prop.setProperty(&quot;time&quot;,count+&quot;&quot;); FileOutputStream fos = new FileOutputStream(file); prop.store(fos,&quot;&quot;); fos.close(); fis.close(); &#125; &#125; 复杂的配置文件描述使用xml文件。 IO流的其他类打印流提供了打印方法，可以将各种数据类型的数据都原样打印。 字节打印流：PrintStream构造函数可以接收的参数类型： file对象 字符串路径 字节输出流OutputStream 字符打印流：PrintWriter file对象 字符串路径 字节输出流OutputStream 字符输出流Writer SequenceInputStream类（合并流）表示其他输入流的逻辑串联。 切割文件通过固定数组大小实现切割。 操作对象ObjectInputStream与ObjectOutputStream类 操作对象]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL语句]]></title>
    <url>%2F2018%2F09%2F25%2F9.25%2F</url>
    <content type="text"><![CDATA[数据定义模式的定义与删除定义模式 CREATE SCHEMA &lt;模式名&gt; AUTHOTIZATION &lt;用户名&gt; [&lt;表定义子句&gt; |&lt;视图定义子句&gt; |&lt;授权定义子句&gt;]; 为用户WANG定义一个学生-课程模式S-T:CREATE SCHEMA &quot;S-T&quot; AUTHORIZATION WANG; 为用户ZHANG创建一个模式TEST，并且在其中定义一个表TAB1:1234567CREATE SCHEMA TEST AUTHORIZATION ZHANG CREATE TABLE TAB1(COL1 SMALLINT, COL2 INT, COL3 CHAR(20), COL4 NUMBERIC(10,3), COL5 DECIMAL(5,2) ); 删除模式 DROP SCHEMA &lt;模式名&gt;&lt;CASCADE|RESTRICT&gt;; CASCADE级联，表示在删除模式的同时把该模式下所有的数据库对象全部删除；RESTRICT限制，表示如果该模式中已经定义了下属的数据库对象（如表、图等），则拒绝该删除语句的执行。 DROP SCHEMA ZHANG CASCADE; 该语句删除了模式ZHANG，同时，该模式中已经定义的TAB1也被删除。 表的定义修改与删除定义基本表 CREATE TABLE &lt;表名&gt;(&lt;列名&gt;&lt;数据类型&gt;[列级完整性约束条件]….[,&lt;表级完整性约束条件&gt;]); 创建一个“学生”表Student。1234567CREATE TABLE Student( Sno CHAR(9) PRIMARY KEY, Sname CHAR(20) UNIQUE, Ssex CHAR(2), Sage SMALLINT, Sdept CHAR(20) ); 创建一个“课程“表Course。12345678CREATE TABLE Course( Cno CHAR(4) PRIMARY KEY, Cname CHAR(40) NOT NULL, Cpno CHAR(4), Ccredit SMALLINT, FOREIGN KEY(Cpno) REFERENCES Course(Cno) /* 表级完整性约束条件，Cpno是外码，被参照表是Course，被参照列是Cno */ ); 本例书名参照表和被参照表可以是同一个表。 建立学生选课表SC。12345678CREATE TABLE SC( Sno CHAR(9), Cno CHAR(4), Grade SMALLINT, PRIMARY KEY (Sno,Cno), /* 主码由两个属性构成，必须作为表级完整性进行定义 */ FOREIGN KEY (Sno) REFERENCES Student(Sno), /* 表级完整性约束条件，Sno是外码，被参照表是Student */ FOREIGN KEY (Cno) REFERENCES Course(Cno) /* 表级完整性约束条件，Cno是外码，被参照表是Course */ ); 修改基本表 ALTER TABLE &lt;表名&gt;[ADD [COLUMN] &lt;新列名&gt;&lt;数据类型&gt;[完整性约束条件]][ADD &lt;表级完整性约束&gt;][DROP [COLUMN] &lt;列名&gt; [CASCADE|RESTRICT]][DROP CONSTRAINT &lt;完整性约束条件&gt; [CASCADE|RESTRICT]][ALTER COLUMN &lt;列名&gt;&lt;数据类型&gt;]; 向Student表增加“入学时间”列，其数据类型为日期型。ALTER TABLE Student ADD S_entrance DATE; 将年龄的数据类型由字符型（假设原来为字符型）改为整数。ALTER TABLE Student ALTER COLUMN Sage INT; 增加课程名称必须取唯一值的约束条件。ALTER TABLE Course ADD UNIQUE(Cname); 删除基本表 DROP TABLE &lt;表名&gt; [RESTRICT|CASCADE]; 若选择RESTRICT，则该表的删除是有限制条件的。欲删除的表不能被其他表的约束所引用，不能有视图，不能有触发器，不能有存储过程或函数等。若选择CASCADE，则该表的删除没有限制条件。在删除表的同时，相关的依赖对象，即将被一起删除。 删除Student表DROP TABLE Student CASCADE; 索引的建立与删除建立索引 CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt; ON &lt;表名&gt;(&lt;列名&gt; [&lt;次序&gt;] [,&lt;列名&gt;[&lt;次序&gt;]]…); UNIQUE表明此索引的每一个索引值只对应唯一的数据记录。CLUSTER表示要建立的索引是聚族索引。 为学生-课程数据库中的Student、Course和SC三个表建立索引。其中Student表按学号升序建唯一索引，Course表按课程号升序建唯一索引，SC表按学号升序和课程号降序建唯一索引。 123CREATE UNIQUE INDEX Stusno ON Student(Sno);CREATE UNIQUE INDEX Coucno ON Course(Cno);CREATE UNIQUE INDEX SCno ON SC(Sno ASC,Cno DESC); 修改索引 ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;; 将SC表的SCno索引名改为SCSno。ALTER INDEX SCno RENAME TO SCSno; 删除索引 DROP INDEX &lt;表名&gt; &lt;索引名&gt;; 数据查询数据查询的一般格式为： SELECT [ALL | DISTINCT] &lt;目标列表达式&gt;[,&lt;目标列表达式&gt;]…FROM &lt;表名或视图名&gt;[,&lt;表名或视图名&gt;…] | (&lt; SELECT语句 &gt;) [AS] &lt;别名&gt;[WHERE &lt;条件表达式&gt;][GROUP BY &lt;列名 1&gt; [HAVING &lt;条件表达式&gt;]][ORDER BY &lt;列名 2&gt; [ASC|DESC]]; 单表查询选择表中若干列查询全体学生的学号和姓名。12SELECT Sno,SnameFROM Student; 查询全体学生的姓名、学号、所在系。12SELECT Sname,Sno,SdeptFROM Student; 查询全体学生的详细记录。12SELECT *FROM Student; 查询全体学生的姓名及出生年份。12SELECT Sname,2014-SageFROM Student; 查询全体学生的姓名、出生年份和所在的院系，要求用小写字母表示系名。并给出别名NAME,BIRTH,BIRTHDAY,DEPARTMENT表示123SELECT Sname NAME,&apos;Year of Birth&apos; BIRTH,2014-Sage BIRTHDAY,LOWER(Sdept) DEPARTMENTFROM Student; 选择表中的若干元组查询选修了课程的学生学号，并去除重复的行。12SELECT DISTINCT SnoFROM SC; 查询计算机科学系全体学生的名单。123SELECT SnameFROM StudentWHERE Sdept=&apos;CS&apos;; 查询年龄(不)在20~23岁（包括20岁和23岁）之间的学生的姓名、系别和年龄。123SELECT Sname,Sdept,SageFROM StudentWHERE Sage (NOT) BETWEEN 20 AND 23; 查询(全不是)计算机科学系CS，数学系MA，信息系IS学生的姓名和性别。123SELECT Sname,SsexFROM StudentWHERE Sdept (NOT) IN(&apos;CS&apos;,&apos;MA&apos;,&apos;IS&apos;); 字符匹配 [NOT] LIKE ‘&lt;匹配串&gt;’ [ESCAPE ‘&lt;换码字符&gt;’] 其含义是查找指定的属性列值与&lt;匹配串&gt;相匹配的元组。&lt;匹配串&gt;可以是一个完整的字符串，也可以是含有通配符%和_ %代表任意长度的字符串（可为0） _代表任意单个字符 查询所有姓刘的学生的姓名、学号和性别。123SELECT Sname,Sno,SsexFROM StudentWHERE Sname LIKE &apos;刘%&apos;; 查询姓“欧阳”且全名为三个汉字的学生的姓名。123SELECT SnameFROM StudentWHERE Sname LIKE &apos;欧阳_&apos;; 查询名字中第二个字为“阳”的学生的姓名和学号。123SELECT Sname,SnoFROM StudentWHERE Sname LIKE &apos;_阳%&apos;; 查询DB_Design课程的课程号和学分。123SELECT Cno,CcreditFROM CourseWHERE Cname LIKE &apos;DB\_Design&apos; ESCAPE&apos;\&apos;; ESCAPE’\’表示“\“为换码字符。 查询以”DB_“开头，且倒数第三个字符为i的课程的详细情况。123SELECT *FROM CourseWHERE Cname LIKE &apos;DB\_%i__&apos; ESCAPE&apos;\&apos;; 多重条件查询查询计算机科学系年龄在20岁以下的学生姓名。123SELECT SnameFROM StudentWHERE Sdept=&apos;CS&apos; AND Sage&lt;20; ORDER BY子句查询选修了3号课程的学生的学号及其成绩，查询结果按分数的降序排列。1234SELECT Sno,GradeFROM SCWHERE Cno=&apos;3&apos;ORDER BY Grade DESC; 聚集函数查询学生总人数。12SELECT COUNT(*)FROM Student; 查询选修了课程的学生人数。12SELECT COUNT(DISTINCT Sno)FROM SC; 查询选修1号课程的学生的平均成绩。123SELECT AVG(Grade)FROM SCWHERE Cno=&apos;1&apos;; 查询选修1号课程的学生的最高分。123SELECT MAX(Grade)FROM SCWHERE Cno=&apos;1&apos;; 查询学生201215012选修课程的总学分数。1234SELECT SUM(Ccredit)FROM SC,CourseWHERE Sno=&apos;201215012&apos; AND SC.Cno=Course.Cno; 聚集函数只能用于SELECT子句和GROUP BY中的HAVING子句。 GROUP BY子句GROUP BY子句将查询结果按某一列或多列的值分组，值相等的为一组。分组的目的是为了细化聚集函数的作用对象。分组后，聚集函数将作用于每组，即每一组都有一个函数值。 求各个课程号及相应的选课人数。123SELECT Cno,COUNT(Sno)FROM SCGROUP BY Cno; 该语句对查询结果按Cno的值分组，所有具有相同Cno值的元组为一组，然后对每组作用的聚集函数COUNT进行计算，以求得该组的学生人数。 查询选修了三门以上课程的学生学号。1234SELECT SnoFROM SCGROUP BY SnoHAVING COUNT(*)&gt;3; COUNT(*)统计元组个数。COUNT(列名 1)统计1列中值的个数。 查询平均成绩大于等于90分的学生学号和平均成绩。1234SELECT Sno,AVG(Grade)FROM SCGROUP BY SnoHAVING AVG(Grad)&gt;=90; 连接查询等值与非等值连接查询连接查询的WHERE子句用来连接两个表的条件称为连接条件或连接谓词，其一般格式为： [&lt;表名 1&gt;.]&lt;列名 1&gt;&lt;比较运算符&gt;[&lt;表名 2.&gt;]&lt;列名 2&gt; 其中比较运算符主要有=、&gt;、&lt;、&gt;=、&lt;=、!=(或&lt;&gt;)等。当连接运算符为=时，称为等值连接。使用其他运算符称为非等值连接。 查询每个学生及其选修课程的情况。123SELECT Student.*,SC.*FROM Student,SCWHERE Student.Sno=SC.Sno; 一条SQL语句可以同时完成选择和连接查询，这时WHERE子句是由连接谓词和选择谓词组成的复合条件。（连接谓词：连接不同条件的；选择谓词：条件中的判断） 查询选修2号课程且成绩在90分以上的所有学生的学号和姓名。1234SELECT Student.Sno,SnameFROM Student,SCWHERE Student.Sno=SC.Sno AND /*连接谓词*/ SC.Cno=&apos;2&apos; AND SC.Grade&gt;90; /*其他限定条件*/ 自身连接外连接多表连接查询每个学生的学号、姓名、选修的课程名及成绩。123SELECT Student.Sno,Sname,Cname,GradeFROM Student,SC,CourseWHERE Student.Sno=SC.Sno AND SC.Cno=Course.Cno; 关系数据库管理系统在执行多表连接时，通常是先进行两个表的连接操作，再将其连接结果与第三个表进行连接。 嵌套查询在SQL语言中，一个SELECT-FROM-WHERE语句称为一个查询块。将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询。SQL语言支持多层嵌套查询。但是子查询的SELECT语句中不能使用ORDER BY子句，ORDER BY子句只能对最终查询结果排序。 带IN的子查询查询与”刘晨“在同一个系学习的学生。123456789101112131415①SELECT SdeptFROM StudentWHERE Sname=&apos;刘晨&apos;;结果为CS②SELECT Sno,Sname,SdeptFROM StudentWHERE Sdept=&apos;CS&apos;;将第一步插入第二步的查询条件中，SELECT Sno,Sname,SdeptFROM StudentWHERE Sdept IN (SELECT Sdept FROM Student WHERE Sname=&apos;刘晨&apos;); 本例中，子查询的查询条件不依赖于父查询，称为不相关子查询。 带有比较运算符的子查询找出每个学生超过他自己选修课程平均成绩的课程号。12345SELECT Sno,CnoFROM SC xWHERE Grade&gt;=(SELECT AVG(Grade) FROM SC y WHERE y.Sno=x.Sno); x是SC的别名，又称为元组变量，可以用来表示SC的一个元组。内层查询是求一个学生选修课程平均成绩的，至于是哪个学生的平均成绩要看参数x.Sno的值，而该值是与父查询相关的，因此此类查询称为相关子查询。 带有ANY(SOME)或ALL谓词的子查询 查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄。123456SELECT Sname,SageFROM StudentWHERE Sage&lt;ANY(SELECT Sage FROM Student WHERE Sdept=&apos;CS&apos;)AND Sdept&lt;&gt;&apos;CS&apos;; /*注意这是父查询块中的条件*/ 带有EXISTS谓词的子查询EXISTS代表存在量词带有EXISTS谓词的子查询不返回任何数据，只产生逻辑真或者假。查询没有选修1号课程的学生姓名。123456SELECT SnameFROM StudentWHERE NOT EXISTS (SELECT * FROM SC WHERE Sno=Student.Sno AND Cno=&apos;1&apos;); 由EXISTS引出的子查询，其目标列表达式通常都用*，因为带EXISTS的子查询只返回真值，给出列名没有实际意义。 集合查询SELECT语句的查询结果是元组的集合，所以多个SELECT语句的结果可进行集合操作。集合操作主要包括并操作UNION，交操作INTERSECT和差操作EXCEPT。参加集合操作的各查询结果的列数必须相同；对应项的数据类型也必须相同。 查询计算机科学系的学生及年龄不大于19岁的学生。1234567SELECT *FROM StudentWHERE Sdept=&apos;CS&apos;UNIONSELECT *FROM StudentWHERE Sage&lt;=&apos;19&apos;; 数据更新插入数据插入元组 INSERTINTO &lt;表名&gt; [(&lt;属性列 1&gt;[,&lt;属性列 2&gt;]…)]VALUES(&lt;常量 1&gt;[,&lt;常量 2&gt;]….); 将一个新学生元组（学号：201215128，姓名：陈东，性别：男，所在系：CS，年龄：18岁）插入到Student表中。123INSERTINTO Student(Sno,Sname,Ssex,Sdept,Sage)VALUES(&apos;201215128&apos;,&apos;陈东&apos;,&apos;男&apos;,&apos;CS&apos;,18); 字符串常数要用单引号括起来。 插入子查询结果 INSERTINTO &lt;表名&gt; [(&lt;属性列 1&gt;[,&lt;属性列 2&gt;…])]子查询; 对每一个系，求学生的平均年龄，并把结果存入数据库。123456789CREATE TABLE Dept_age (Sdept CHAR(15), Avg_age SMALLINT);INSERTINTO Dept_age(Sdept,Avg_age)SELECT Sdept,AVG(Sage)FROM StudentGROUP BY Sdept; 修改数据 UPDATE &lt;表名&gt;SET&lt;列名&gt;=&lt;表达式&gt;[,&lt;列名&gt;=&lt;表达式&gt;]…[WHERE &lt;条件&gt;]; 用来修改指定表中满足WHERE子句条件的元组。如果省略WHERE子句，则表示要修改表中的所有元组。 修改某一个元组的值将学生201215121的年龄改为22岁。123UPDATE StudentSET Sage=22WHERE Sno=&apos;201215121&apos;; 修改多个元组的值将所有学生的年龄增加1岁。12UPDATE StudentSET Sage=Sage+1; 带子查询的修改语句将计算机科学系全体学生的成绩置零。1234567UPDATE SCSET Grade=0WHERE Sno IN (SELETE Sno FROM Student WHERE Sdept=&apos;CS&apos; ); 删除数据 DELETEFROM &lt;表名&gt;[WHERE &lt;条件&gt;]; 删除一个元组的值删除学号为201215128的学生记录。123DELETE FROM StudentWHERE Sno=&apos;201215128&apos;; 删除多个元组的值删除所有学生的选课记录。12DELETE FROM SC; 带子查询的删除语句删除计算机科学系所有学生的选课记录。1234567DELETEFROM SCWHERE Sno IN (SELECT Sno FROM Student WHERE Sdept=&apos;CS&apos; ); 视图定义视图建立视图 CREATE VIEW &lt;视图名&gt;[(&lt;列名&gt;[,&lt;列名&gt;]…)]AS &lt;子查询&gt;[WITH CHECK OPTION]; 建立信息系学生的视图。12345CREATE VIEW IS_StudentASSELECT Sno,Sname,SageFROM StudentWHERE Sdept=&apos;IS&apos;; 建立信息系学生的视图，并要求进行修改和插入操作时仍需保证该视图只有信息系的学生。123456CREATE VIEW IS_StudentASSELECT Sno,Sname,SageFROM StudentWHERE Sdept=&apos;IS&apos;WITH CHECK OPTION; 在定义视图时，加上了WITH CHECK OPTION子句，以后对该视图进行插入、删除、修改操作时，关系数据库管理系统会自动加上Sdept_’IS’的条件。（即子查询中的条件表达式） 建立信息系选修了1号课程的学生的视图（包括学号、姓名、成绩）。1234567CREATE VIEW IS_S1(Sno,Sname,Grade)ASSELECT Student.Sno,Sname,GradeFROM Student,SCWHERE Sdept=&apos;IS&apos; AND Student.Sno=SC.Sno AND SC.Cno=&apos;1&apos;; 用带有聚集函数和GROUP BY子句的查询来定义视图，这种视图叫分组视图。 将学生的学号及平均成绩定义成一个视图。12345CREATE VIEW S_G(Sno,Gavg)ASSELECT Sno,AVG(Grade)FROM SCGROUP BY Sno; 删除视图 DROP VIEW &lt;视图名&gt; [CASCADE]; 查询视图在信息系学生的视图中找出年龄小于20岁的学生。123SELECT Sno,SageFROM IS_StudentWHERE Sage&lt;20; 更新视图由于视图是不实际存在的虚表，因此对视图的更新最终要转换为对基本表的操作。 将信息系学生视图IS_Student中学号为“201215122”的学生姓名改为“刘晨”。1234567UPDATE IS_StudentSET Sname=&apos;刘晨&apos;WHERE Sno=&apos;201215122&apos;;转换后的更新语句为UPDATE StudentSET Sname=&apos;刘晨&apos;WHERE Sno=&apos;201215122&apos; AND Sdept=&apos;IS&apos;; 视图的作用视图能够简化用户的操作。视图使用户能以多种角度看待同一数据。视图对重构数据库提供了一定程度的逻辑独立性。视图能对机密数据提供安全保护。适当利用视图可以更清晰地表达查询。]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java基础（十六）]]></title>
    <url>%2F2018%2F09%2F23%2F9.23%2F</url>
    <content type="text"><![CDATA[千里之台起于累土IO字节流字符流： FileReader FileWriter BufferedReader BufferedWriter 字节流:FileInputStream,FileOutputStream，BufferedInputStream，BufferedOutputStream OutputStream：此抽象类是表示输出字节流的所有类的超类FileOutputStream：文件输出流是用于将数据写入 File 或 FileDescriptor 的输出流InputStream：此抽象类是表示字节输入流的所有类的超类。FileInputStream：FileInputStream 从文件系统中的某个文件中获得输入字节。FileInputStream 用于读取诸如图像数据之类的原始字节流。要读取字符流，请考虑使用 FileReader。 FileInputStream类其中方法： available()：获取文件中字符个数。/n/r表示一个回车，也是两个字符串。不过这个方法对于较大数据会导致内存溢出。 不用flush()。 BufferedWriterStream该类实现缓冲的输出流。通过设置这种输出流，应用程序就可以将各个字节写入底层输出流中，而不必针对每次字节写入调用底层系统。 BufferedInputStream用来为另一个输入流添加一些功能。在创建 BufferedInputStream 时，会创建一个内部缓冲区数组。 读取键盘录入读取键盘录入：System.out:对应的是标准输出设备，控制台。System.in:对应的是标准输入设备，键盘。 12345678910111213141516171819202122232425import java.io.*;class ReadInDemo&#123; public static void main(String[] args) throws IOException&#123; InputStream in = System.in; StringBuilder sb = new StringBuilder(); /* while((ch = in.read())!=-1)&#123; System.out.println(ch); */ while(true)&#123; int ch = in.read(); if(ch==&apos;\r&apos;) continue; else if(ch==&apos;\n&apos;)&#123; String s = sb.toString(); if(s.equals(&quot;over&quot;)) break; System.out.println(s); /* 下面的delete()方法是用来在输出字符串之后清空StringBuilder的。 */ sb.delete(0,sb.length()); &#125; else sb.append((char)ch); &#125; &#125;&#125; 读取转换流readLine()方法是字符流BufferedReader类中的方法。而键盘录入的read方法是字节流InputStream的方法。 InputStreamReader是字节流通向字符流的桥梁。继承Reader类（字符流）。 12345678910111213141516171819202122import java.io.*;class TransStreamDemo&#123; public static void main(String[] args) throws IOException&#123; //获取键盘录入对象 InputStream in =System.in; //将字节流对象转成字符流对象，使用转换流InputStreamReader。 InputStreamReader isr = new InputStreamReader(in); //为了提高效率，将字符串进行缓冲区技术高效操作，使用BufferedReader BufferedReader bufr = new BufferedReader(isr); String line = null; while((line = bufr.readLine())!=null)&#123; if(&quot;over&quot;.equals(line)) break; System.out.println(line.toUpperCase()); &#125; bufr.close(); &#125;&#125; 写入转换流OutputStreamWriter 是字符流通向字节流的桥梁。继承Writer类。 1234567891011121314151617181920212223242526272829303132333435import java.io.*;class TransStreamDemo&#123; public static void main(String[] args) throws IOException&#123; //获取键盘录入对象 InputStream in =System.in; //将字节流对象转成字符流对象，使用转换流InputStreamReader。 InputStreamReader isr = new InputStreamReader(in); //为了提高效率，将字符串进行缓冲区技术高效操作，使用BufferedReader BufferedReader bufr = new BufferedReader(isr); //System.out 是“标准”输出流。此流已打开并准备接受输出数据。用父类OutputStream来接收 OutputStream out = System.out; //创建使用默认字符编码的OutputStreamWriter；是 //字符流通向字节流的桥梁（不就是互通吗？）；是Writer的子类，也是字符流啊！ OutputStreamWriter osw = new OutputStreamWriter(out); //BufferedWriter用来将文本写入字符输出流，缓冲各个字符。 //下面的构造方法是创建一个使用osw大小缓冲区的缓冲字符输出流 BufferedWriter bfw = new BufferedWriter(osw); String line = null; while((line = bufr.readLine())!=null)&#123; if(&quot;over&quot;.equals(line)) break; //将字符串line写入到bfw中 bfw.write(line); //写入一个行分隔符。（因为可能在Windows和Linux下运行，他们的换行符不同，不是固定的串） bfw.newLine(); //刷新该流的缓冲。如果该流已保存缓冲区中各种 write() 方法的所有字符，则立即将它们写入预期目标。 bfw.flush(); &#125; bufr.close(); &#125;&#125; 流操作规律流操作的基本规律：流的对象有很多。要选择哪个来使用？通过三个明确来选择： 明确源和目的 源：输入流。InputStream、Reader 目的：输出流。OutputStream、Writer 操作的数据是否是纯文本 是：字符流 不是：字节流 当体系明确后，在明确要使用哪个具体的对象，通过设备来区分 源设备：内存、硬盘、键盘 目的设备：内存、硬盘、控制台 例如： 将一个文本文件中数据存储到另一个文件中。即复制文件。 源：因为是源，所以使用读取流，InputStream和Reader 是不是操作文本文件 是！选择Reader 接下来明确使用该体系中哪个对象。 明确设备：硬盘。 Reader体系中可以操作文件的对象是FileReader 是否需要提高效率：是！加入Reader体系中缓冲区BufferedReader。 FileReader fr = new FileReader(“a.txt”);BufferedReader buff =new BufferedReader(fr); 目的：OutputStream和Writer 是不是纯文本文件 是！Writer 设备：硬盘。一个文件 Writer体系中能操作文件的对象时FileWriter FileWriter fw =new FileWriter(“b.txt”); BufferedWriter bfw = new BufferedWriter(bfw); 需求：将键盘录入的数据保存到一个文件中。这个需求中有源和目的都存在那么分别分析源：InputStream Reader是不是纯文本？是！Reader 设备：键盘。对应的对象是System.in。但是需要使用Reader，但这里的System.in是字节流？为了操作键盘的文本数据方便。转成字符流按照字符串操作是最方便的。所以既然明确了Reader，那么就将System.in转换成Reader。这就需要Reader体系下的读取转换流InputStreamReader InputStreamReader isr = new InputStreamReader(System.in); 需要提高效率吗？需要！BufferedReaderBufferedReader bufr = new BuffereReader(isr); 目的：OutputStream和Writer是纯文本文件：Writer设备：文件中。使用FileWriter。所以FileWriter fw =new FileWriter(“a.txt”);需不需要提高效率需要：BufferedWriter bw = new BufferedWriter(fw); 扩展，想要把录入的数据按照指定的编码表（utf-8），将数据存到文件中。 目的：OutputStream Writer是否是纯文本？是！Writer设备：硬盘。一个文件。使用FileWriter。但是FileWriter是使用的默认编码表。GBK。 但是存储时，需要加入指定编码表utf-8。而指定的编码表只有转换流可以指定。所以要使用的对象是OutputStreamWriter。而该转换流对象要接收一个字节输入流。而且还可以操作的文件的字节输出流。FileOutputStreamOutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(“d.txt”),”UTF-8”);需要高效吗？需要BufferedWriter bufw = new BufferWriter(osw); 转换流什么时候使用？字符和字节之间的桥梁，通常，涉及到字符编码转换时，需要用到转换流。 打印系统信息到文件12Properties prop = System.getProperties();prop.list(new PrintStream(&quot;sysinfo.txt&quot;));]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java基础（十五）]]></title>
    <url>%2F2018%2F09%2F21%2F9.21%2F</url>
    <content type="text"><![CDATA[BufferedReader 从字符输入流中读取文本，缓冲各个字符，从实现字符、数组和行的高效读取。 readLine()：读取一个文本行。返回包含该行内容的字符串，不包含任何终止符，如果到达流末尾，则返回null。 下面是一个通过BufferedReader和BufferedWriter拷贝文件的类。 1234567891011121314151617181920212223242526272829303132333435package io;import java.io.*;public class BufferedReaderDemo &#123; public static void main(String[] args) &#123; BufferedReader bufr = null; BufferedWriter bufw = null; try &#123; bufr = new BufferedReader(new FileReader(&quot;buf.txt&quot;)); bufw = new BufferedWriter(new FileWriter(&quot;buf_copy.txt&quot;)); String line = null; while ((line = bufr.readLine()) != null) &#123; bufw.write(line); bufw.newLine(); bufw.flush(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; bufw.close(); &#125; catch (IOException e) &#123; System.out.println(&quot;写入缓冲区失败&quot;); &#125; try &#123; bufr.close(); &#125; catch (IOException e) &#123; System.out.println(&quot;读取缓冲区失败&quot;); &#125; &#125; &#125;&#125; 装饰设计模式当想要对已有的对象进行功能增强时，可以定义类，将已有对象传入，基于已有的功能，并提供加强功能。那么自定义的该类为装饰类。装饰类通常会通过构造方法接受被增强的对象；并基于被装饰的对象的功能，提供更强的功能。 1234567891011121314151617181920212223242526class Person&#123; public void chifan()&#123; System.out.println(&quot;吃饭&quot;); &#125;&#125;class SuperPerson&#123; private Person p; SuperPerson(Person p)&#123; this.p = p; &#125; public void superchifan()&#123; System.out.println(&quot;胃酒&quot;); p.chifan(); System.out.println(&quot;甜点&quot;); System.out.println(&quot;来一根烟&quot;); &#125;&#125;class PersonDemo&#123; public static void main(String[] args)&#123; Person p =new Person(); SuperPerson p1 = new SuperPerson(p); p1.superchifan(); &#125;&#125; 装饰与继承的区别123456789101112131415161718192021MyReader//专门用于读取数据的类。 |--MyTextReader |--MyBufferTextReader |--MyMediaReader |--MyBufferMediaReader上面是通过继承的方式实现Buffer功能class MyBufferReader&#123; MyBufferReader(MyTextReader)&#123;&#125; MyBufferReader(MyMediaReader)&#123;&#125;&#125;上面这个类通过抽取Buffer功能重写构造函数来实现MyTextReader和MyMediaReader的Buffer功能。这个类扩展性太差，找到其参数的共同类型。通过多态的形式，可以提高扩展性。class MyBufferReader extends MyReader&#123; private MyReader r; MyBuffereder(MyReader r)&#123;&#125;&#125;MyReader//专门用于读取数据的类。 |--MyTextReader |--MyMediaReader这就是装饰设计模式，十分优化，扩展性增强 装饰模式比继承灵活，避免了继承体系臃肿。降低了类与类之间的关系。 装饰类因为是增强已有对象，具备的功能和已有对象的功能是相同的，只不过提供了更强功能。所以装饰类和被装饰类通常都是一个体系中的。 LineNumberReaderLineNumberReader,跟踪行号的缓冲字符输入流。有方法： getLineNumber()：获得当前行号；反会int型 readLine():读取文本行；返回字符串型 setLineNumber(int lineNumber)：设置开头字符串的当前行号 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.io.*;class MyLineNumberReader&#123; private Reader r; private int lineNumber; MyLineNumberReader(Reader r)&#123; this.r = r; &#125; public String myReadLine() throws IOException&#123; /*此方法用来模拟BufferedReader的readLine()方法；方法在调用时都必须带上()；涉及到IO流，方法都得抛IOException*/ lineNumber++; StringBuilder sb = new StringBuilder(); int ch = 0; while((ch=r.read())!=-1)&#123; if(ch==&apos;\r&apos;) continue; if(ch==&apos;\n&apos;) return sb.toString(); else sb.append((char)ch); &#125; if(sb.length()!=0) return sb.toString(); return null; &#125; public void setlineNumber(int lineNumber) &#123; this.lineNumber=lineNumber; &#125; public int getlineNumber()&#123; return lineNumber; &#125; public void myClose() throws IOException&#123; r.close(); &#125;&#125;class MyLineNumberReaderDemo&#123; public static void main(String[] args) throws IOException &#123; FileReader fr = new FileReader(&quot;Test.txt&quot;); MyLineNumberReader mylnr = new MyLineNumberReader(fr); String line = null; while((line = mylnr.myReadLine())!=null) &#123; System.out.println(mylnr.getlineNumber()+&quot;:&quot;+line); &#125; mylnr.myClose(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java基础（十四）]]></title>
    <url>%2F2018%2F09%2F20%2F9.20java%2F</url>
    <content type="text"><![CDATA[日积月累System类1.字段摘要 err：错误输出流 in：输入流 2.方法摘要System:类中的方法和属性都是静态的。 gerProperties()：获取系统属性信息。因为Properties是Hashtable的子类，也就是Map集合的一个子类对象。那么可以通过map的方法取出该集合中的元素。该集合中存储的都是字符串，没有泛型定义。 setProperty(String key, String value):设置指定键指示的系统属性 currentTimeMillis():返回以毫秒为单位的当前时间。 gc()：运行垃圾回收器 java -D:在JVM启动时，动态加载一些属性信息 Runtime类 该类中没有提供构造函数，说明不可以new对象，那么会直接想到该类中的方法是静态的。发现该类中还有非静态方法，说明该类肯定会提供了方法来获取本类对象，而且该方法是静态的，并返回值类型是本类类型。 这个特点表示了该类使用了单例设计模式。该方法是static Runtime getRuntime()。 Date类 Date类的构造方法返回的对象是系统时间。 想要对系统时间进行格式化需要使用DateFormat，然而DateFormat类是抽象的，不能返回对象；使用继承DateFormat类的SimpleDateFormat类来实例化对象。此对象调用父类的format(Date date)方法对系统时间进行格式化。 Calendar类 Calendar类是抽象类，通过getInstance()方法获取对象。 可以通过查表法来将月份和星期几给格式化输出；如：一月星期三（Calendar对象get出的是0和3）。 add(int field, int amount)方法：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 例子：获取任意年的二月有多少天。思路：根据指定年设置一个时间就是c.set(year,2,1)//某一年的3月1日。c.add(Calenar.DAY_OF_MONTH,-1)//3月1日，往前推一天，就是2月最后一天。 例子：获取昨天的现在这个时刻。c.add(Calendar.DAY_OF_MONTH,-1)。 Math类 final修饰的类，Math类包含用于执行基本数学运算的方法。 ceil()方法返回大于指定数据的最小整数。 floor()方法返回小宇指定数据的最大整数 round()方法返回四舍五入的整数 pow(double a,double b)方法返回第一个参数的第二个参数次幂的值 random()方法返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。返回值是一个伪随机选择的数（是通过算法实现的），在该范围内（近似）均匀分布。 IO流 IO流用来处理设备之间的数据传输。流按操作数据分为两种：字节流和字符流。按流向分为：输入流，输出流。 IO流常用基类：字节流的抽象基类：InputStream，OutputStream。字符流的抽象基类：Reader，Writer。由这四个类派生出的子类的名称都是以其其父类名字作为后缀的。 FileWriterWriter是写入字符流的抽象类。子类必须要实现的方法仅有write()和flush()和close()。FileWriter的前缀名表示流对象的功能，后缀名是父类名。 通过FileWriter类的构造方法，创建一个FileWriter对象。该对象一被初始化就必须要明确被操作的文件（明确目录）。而且该文件会被创建到指定目录下。如果该目录下已有同名文件，则将被覆盖。这一步明确数据要存放的目的地。 创建FileWriter对象后，FileWriter对象调用父类write()方法，将字符串写入流；对象再调用flush()方法刷新流对象中的缓冲中的数据，将数据刷到目的地中。 close()方法关闭流，但是关闭前会刷新一次内部缓冲中的数据。将数据刷到目的地中。和flush()的区别：flush刷新后，流可以继续使用，close刷新后，会将流关闭。 IO异常处理方式123456789101112131415161718192021222324252627package io;import java.io.*;public class FileWriterDemo &#123; public static void main(String[] args) &#123;// 在try语句中创建的fw对象，在finally语句中不能调用；因此需要在外面声明变量 FileWriter fw = null;// FileWriter这种IO流的类在创建对象和调用方法时都要try和catch。 try &#123; fw = new FileWriter(&quot;demo.txt&quot;); fw.write(&quot;ada&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123;// 关闭资源的方法放在finally中，fw对象使用close方法时也要try和catch try &#123;// 判断一下fw是否为空，这样增强了代码的健壮性 if(fw!=null) fw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 文件的续写FileWriter的构造方法中有一个是：FileWriter(String fileName,boolean append)。传递一个true参数，表示可以附加写入数据，在已有文件末尾处添加数据。 文本文件的读取方式 通过FileReader()构造方法创建一个新的FileReader对象，和指定名称的文件相关联。要保证该文件是已经存在的，如果不存在，会发生异常FileNotFoundException FileReader对象调用读取流对象的read方法。read()方法：一次读取一个字符，而且会自动往下读，返回int型。如果已到达流的末尾，则返回 -1 。 read(char[] char)方法，通过字符数组进行读取。将读到的数据写入char数组。返回的也是int型。 拷贝文件 BufferedWriter 功能：将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。 缓冲区的出现是为了提高流的操作效率而出现的。所以在创建缓冲区之前，必须要先有流对象。 只需要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可。 通过缓冲区的构造函数新建的对象能调用父类的方法进行write和flush和close。不过缓冲区的close方法其实是关闭了FileWriter对象（缓冲区中的流对象）。 newLine()方法：写入一个行分隔符，能跨平台。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>第18天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java后端学习线路]]></title>
    <url>%2F2018%2F09%2F19%2F9.19%E5%AD%A6%E4%B9%A0%E7%BA%BF%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[Java后端学习线路图（转自CSDN和开源中国等学习网站）Java工程师学习线路 Java工程师学习线路详细 Java后端工程师技能树]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库创建]]></title>
    <url>%2F2018%2F09%2F18%2F9.18%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[mysql建数据库的字符集与排序规则说明字符集说明一般选择utf8，utf8mb4兼容utf8，且比utf8能表示更多的字符。unicode编码区从1 ～ 126就属于传统utf8区，当然utf8mb4也兼容这个区，126行以下就是utf8mb4扩充区，什么时候你需要存储那些字符，你才用utf8mb4,否则只是浪费空间。 排序说明排序一般分为两种：utf_bin和utf_general_cibin 是二进制, a 和 A 会别区别对待.例如你运行:SELECT * FROM table WHERE txt = ‘a’那么在utf8_bin中你就找不到 txt = ‘A’ 的那一行, 而 utf8_general_ci 则可以.utf8_general_ci 不区分大小写，这个你在注册用户名和邮箱的时候就要使用。utf8_general_cs 区分大小写，如果用户名和邮箱用这个不便于管理。 SQL命令参考网站：W3school JDBC教程参考网站：https://www.yiibai.com/jdbc/jdbc-sql-syntax.html sql创建表语句123456CREATE TABLE tab_sersor(date datetime not null PRIMARY KEY ,temp numeric(6,2) NOT NULL,humi numeric(6,2) NOT NULL,illu INT(6) NOT NULL); 1234567CREATE TABLE tab_sensor(id int primary key auto_increment,temp numeric(6,2) ,humi numeric(6,2) ,illu INT(6) ,date datetime );]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>数据库的字符集与排序规则说明</tag>
        <tag>SQL命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql8.0.12版本安装]]></title>
    <url>%2F2018%2F09%2F17%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[mysql8.0.12版本zip格式安装mysql8.0.12下载地址:https://dev.mysql.com/downloads/mysql/5.5.html#downloads 安装步骤：1. 解压。2. 新建配置文件my.ini文件（有则不建）；将如下代码中的mysql安装目录和mysql数据库的存放目录修改后，拷入my.ini配置文件。123456789101112131415161718192021222324[mysqld]# 设置3306端口port=3306# 设置mysql的安装目录basedir=D:\mysql-8.0.12-winx64# 设置mysql数据库的数据的存放目录datadir=D:\mysql-8.0.12-winx64\data# 允许最大连接数max_connections=200# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统max_connect_errors=10# 服务端使用的字符集默认为UTF8character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证default_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8 3. 数据库配置通过管理员权限进入CMD（必须使用管理员权限），进入mysql安装目录下的bin目录下。按照如下步骤依次输入命令行：①输入mysqld –initialize –console，在root@localhost: 后的就是root用户的初始密码，必须要记下它，下面的登录步骤会用到。如果不小心没记住，可以删掉初始化的data目录，再执行一遍初始化命令又会重新生成。②输入mysqld –install安装mysql服务，输入net start mysql启动服务。（mysqld –remove是卸载MySql服务，net stop mysql是停止服务。）③输入mysql -u root -p，会提示让输入之前第一步中root的密码，输入正确后会提示Welcome to the MySQL monitor.④输入ALTER USER ‘root‘@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘新密码’;。如果出现了Query OK,0 rows affected表示更改成功 —mysql8.0.12安装完成— 4.数据库相关配置查看默认数据库：show databases;选择mysql数据库: use mysql查看默认MySQL用户： select host,user,authentication_string,plugin from user;创建新用户： CREATE USER ‘用户名‘@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘密码’;给新用户授权： GRANT ALL PRIVILEGES ON *.* TO ‘用户名‘@’localhost’;刷新权限： FLUSH PRIVILEGES; 本文参考CSDN文章MySQL8.0.12 安装及配置]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>mysql安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[课设传感器]]></title>
    <url>%2F2018%2F09%2F17%2F9.17%E8%AF%BE%E8%AE%BE%2F</url>
    <content type="text"><![CDATA[传感器的网络地址与数据单独只开光照传感器 第一次取样：02 08 18 00 F1 FD 66 01 7F AE AA02 08 18 00 F1 FD 66 01 BC AD 6A02 08 18 00 F1 FD 66 01 BC AD 6A02 08 18 00 F1 FD 66 01 B8 9F 5C02 08 18 00 F1 FD 66 01 32 9E D7第二次取样：02 08 18 00 F1 FD 66 01 9A AB 4A02 08 18 00 F1 FD 66 01 FE AA 2F02 08 18 00 F1 FD 66 01 9A AB 4A02 08 18 00 F1 FD 66 01 5D AC 8A02 08 18 00 F1 FD 66 01 C1 AB 11 66 FD是光照传感器的网络地址（第6,7个字符串)。 123456789AE 7F 44671AD BC 444769F B8 408889E 32 40498AB 9A 43930AA FE 43774AB 9A 43930AC 5D 44125AB C1 43969 分析可知，第9,10个字符串的逆序就是传感器采集出的光照数据。 单独只开温湿度传感器 第一次取样：02 08 18 00 F1 F5 3D 01 84 F0 5C02 08 18 00 F1 F5 3D 02 10 27 1C02 14 18 00 F1 A1 92 01 02 5D E053 05 00 4B 12 00 00 00 63 F0 0B E702 08 18 00 F1 F5 3D 01 84 F0 5C02 08 18 00 F1 F5 3D 02 10 27 1C02 08 18 00 F1 F5 3D 01 84 F0 5C02 08 18 00 F1 F5 3D 02 10 27 1C 其中3D F5是网络地址（第6,7个字符）01 代表温度传感器 02 代表湿度传感器 12345F0 84 6157227 10 100005D 02 23810F0 84 6157227 10 10000 分析可知，第9,10个字符串的逆序表示温度或者湿度。 02 08 18 00 F1 26 87 01 84 F0 3502 08 18 00 F1 26 87 01 84 F0 3502 08 18 00 F1 26 87 02 10 27 7502 08 18 00 F1 26 87 01 84 F0 3502 08 18 00 F1 26 87 02 10 27 75 02 08 18 00 F1 B3 56 01 BC AD 1402 08 18 00 F1 B3 56 01 E3 AD 4B02 08 18 00 F1 B3 56 01 0A AE A1 控制器的控制4个指示灯全部关闭02 07 18 00 F1 82 31 01 00 5C02 07 18 00 F1 82 31 01 00 5C开D1002 07 18 00 F1 82 31 01 04 58开D10,D502 07 18 00 F1 82 31 01 05 59全开02 07 18 00 F1 82 31 01 0F 53开D5,D702 07 18 00 F1 82 31 01 03 5F 可以得出在控制器上，四个指示灯对应4位二进制数，表示了控制器状态的16进制数据。 读取zigbee传感器数据的jar包参考文章： Java使用开源Rxtx实现串口通讯(串口开发) Rxtx开源包下载地址]]></content>
      <categories>
        <category>大四课设</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[简历规范]]></title>
    <url>%2F2018%2F09%2F15%2F9.15%2F</url>
    <content type="text"><![CDATA[安卓基础开发基础设施 软件开发基础设施 安装金山打字通，现场测速测规范 常用Windows快捷键 win + D显示桌面 win + E打开文件资源管理器 win + R ncpa.cpl打开网络连接 firewall.cpl打开防火墙 calc打开计算器 contorl打开控制面板 services.msc打开服务 mspaint打开画板 notepad打卡记事本 msconfig打开系统配置 regdit打开注册表 文本编辑器 Atom Notepad++ Subline UltraEdit VS Code Xmind 专业浏览器 Chrome FireFox Opera 如何高效搜索网络资源 需要学习的网站 dzone.com csdn.net 51cto.com.cn iteye.com Git基础操作 代码规范检查工具CheckStyle、代码缺陷检查工具PMD WLS，IDM Linux云端部署]]></content>
      <categories>
        <category>就业</category>
      </categories>
      <tags>
        <tag>简历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构（一）]]></title>
    <url>%2F2018%2F09%2F13%2F9.13%2F</url>
    <content type="text"><![CDATA[数据结构概论数据结构基本概念 数据类型由数据属性和运算集合组成。反映了数据的取值范围和对这类数据可以施加的运算。 面向对象：每一种基本的数据类型都有一组与其相关的运算，而这组运算的具体实现都被封装起来，人们不知道也不必去关心这些细节。 时间复杂度和空间复杂度采用算法执行过程中其基本操作的执行次数，即计算量来度量。]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>数据结构基本概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础（十三）]]></title>
    <url>%2F2018%2F09%2F12%2Fjava17%2F</url>
    <content type="text"><![CDATA[日积月累集合框架的工具类CollectionsCollections类： 如果为此类的方法所提供的 collection 或类对象为 null，则这些方法都将抛出 NullPointerException。 public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List list)方法，根据元素的自然顺序对指定列表按升序进行排序。列表中的所有元素都必须实现 Comparable 接口。此外，列表中的所有元素都必须是可相互比较的。此排序方法具有稳定性：不会因调用 sort 方法而对相等的元素进行重新排序 public static void sort(List list,Comparator&lt;? super T&gt; c)方法，根据指定比较器产生的顺序对指定列表进行排序。此列表内的所有元素都必须可使用指定比较器相互比较。此排序方法具有稳定性：不会因调用 sort 方法而对相等的元素进行重新排序 Collections两个排序方法测试： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package Collection;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;public class CollectionsTest &#123; public static void main(String[] args) &#123; sortDemo(); sortDemo2(); &#125; public static List creatList() &#123; List list = new ArrayList(); list.add(&quot;adfa&quot;); list.add(&quot;asd&quot;); list.add(&quot;dfd&quot;); list.add(&quot;aa&quot;); sop(&quot;原串&quot; + list); return list; &#125; public static void sortDemo() &#123; List list = creatList(); Collections.sort(list); sop(&quot;自然顺序&quot; + list); &#125; public static void sortDemo2() &#123; List list = creatList(); Collections.sort(list, new StrLenComparator()); sop(&quot;按长度&quot; + list); &#125; static class StrLenComparator implements Comparator&lt;String&gt; &#123; @Override public int compare(String o1, String o2) &#123; if (o1.length() &gt; o2.length()) return 1; if (o1.length() &lt; o2.length()) return -1; return o1.compareTo(o2); &#125; &#125; public static void sop(Object obj) &#123; System.out.println(obj); &#125;&#125; public static int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list,T key)；如果搜索键包含在列表中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。插入点 被定义为将键插入列表的那一点：即第一个大于此键的元素索引；如果列表中的所有元素都小于指定的键，则为 list.size()。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。 public static void fill(List&lt;? super T&gt; list,T obj)；使用指定元素替换指定列表中的所有元素。 public static boolean replaceAll(List list,T oldVal,T newVal)使用另一个值替换列表中出现的所有某一指定值。更确切地讲，使用 newVal 替换 list 中满足(oldVal==null ? e==null : oldVal.equals(e)) 的每个 e 元素。 Arrayspublic static List asList(T… a)；参数a - 支持列表的数组。返回指定数组的列表视图。这个方法能将数组变为list集合。这样可以使用集合的思想和方法来操作数组中的元素。注意：不可以使用集合的增删方法，因为数组的长度是固定的；可以使用contains,get,indexOf().subList()方法。如果增删，会发生UnsupportedOperationException异常 集合变数组，Collection接口中的toArray方法。1.指定类型的数组到底要定义多长呢？当指定类型的数组长度小于了集合的size，那么该方法内部会创建一个新的数组。长度为集合的size。当指定类型的数组长度大于了集合的size，就不会新创建了数组。而是使用传递进来的数组。所以创建一个刚刚好的数组最优。2.为什么要将集合变数组？为了限定对元素的操作，不需要进行增删了。 高级for循环1234格式：for(数据类型 变量名:被遍历的集合（collection）或者数组）&#123;&#125; 高级for循环，对集合进行遍历。只能获取集合元素，但是不能对集合进行操作。 迭代器除了遍历，还可以进行remove集合中元素的动作。如果是用ListIterator，还可以在遍历过程中对集合进行增删改查的动作。 高级for有一个局限性，必须有被遍历的目标。在遍历数组时，希望使用传统for循环，传统for循环可以使用角标 可变参数可变参数：其实就是数组参数的简写形式。不用每一次都手动的建立数组对象。只要将要操作的元素作为参数传递即可。隐式将这些参数封装成了数组。 使用可变参数时注意：可变参数一定要定义在参数列表的最后一项。 123456789101112131415161718192021package Collection;public class ParamMethodDemo &#123; public static void main(String[] args) &#123; show(2, 4, 3, 4, 5, 6); show(1, 5, 4, 8, 7, 6, 7); show(1, 5, 4, 8, 7, 6, 7, 5); &#125; private static void show(int... arr) &#123; sop(&quot;[&quot;); for (int i : arr) &#123; sop(i + &quot;,&quot;); &#125; sop(&quot;]&quot;); &#125; public static void sop(Object obj) &#123; System.out.print(obj); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>第17天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础（十二）]]></title>
    <url>%2F2018%2F09%2F11%2Fjava16%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[日积月累Map 接口Map&lt;K,V&gt;的特点：该集合存储键值对，一对一对存，而且要保持键的唯一性。 添加：put(K key, V value), putAll(Map&lt;? extends K,? extends V&gt; m) 删除：clear(),remove(Object key) 判断：containsKey(Object key),containsValue(Object value),isEmpty() 获取：get(Object key),size(), values() 已知实现类：HashMap：底层是哈希表数据结构，可以存入null键null值，该线程是不同步的Hashtable：底层是哈希表数据结构，不可以存入null键null值，该线程是同步的TreeMap：底层是二叉树数据结构，线程不同步，可以用于给Map集合中的键进行排序。 获取map集合中所有的值。Collection coll = map.values()。添加元素put方法，如果出现添加时有相同的键，那么后添加的值会覆盖原有的键对应值，并返回被覆盖的值。 map集合的两中取出方式：①Set keySet：将map中所有的键存入到Set集合。因为set具备迭代器，所以可以迭代方式取出所有的键，在根据get方法，获取每一个键对应的值。②Set&lt;Map.Entry&lt;k,v&gt;&gt; entrySet():将map集合中的映射关系存入到了set集合中，而这个关系的数据类型就是：Map.Entry。Entry也是一个接口，它是Map接口中的一个内部接口。 练习：获取”abcdaaaffec”字符串中的字母出现的次数；希望打印结果:a(4)f(2)… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package Collection;import java.util.Iterator;import java.util.Map;import java.util.Set;import java.util.TreeMap;//练习：获取&quot;abcdaaaffec&quot;字符串中的字母出现的次数；希望打印结果:a(4)f(2)...通过结果发现，// 每一个字母都有对应的次数，说明字母和次数之间有映射关系。可以选择map集合，因为map集合中存放的是映射关系//思路：1.将字符串转换成字符数组。因为要对每一个字母进行操作。2.定义一个map集合，因为打印结果的字母有顺序，所以使用treemap集合//3.遍历字符数组：将每一个字母作为键值对插入map集合；如果返回null，将该字母和1存入到map集合中；// 如果返回不是null，说明该字母存在并有对应次数， 那么获取该次数并进行自增，//然后将该字母和自增后的次数存入到map集合中，覆盖掉原来键所对应的值。4.将map集合中的数据变成指定的字符串形式返回。public class MapTest &#123; public static void main(String[] args) &#123; System.out.println(charCount(&quot;abcdaaaffec&quot;)); &#125; // 定义实现计算字符串中字母出现次数的方法 public static String charCount(String str) &#123;// 将字符串转化为字符数组 char[] chs = str.toCharArray();// 字母与它出现的次数是一一对应关系，是映射关系；映射关系就选择Map&lt;&gt;接口；又因为需要对映射关系排序，故使用TreeMap集合// 类 TreeMap&lt;K,V&gt;; K - 此映射维护的键的类型 V - 映射值的类型// TreeMap&lt;K,V&gt;；该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。 TreeMap&lt;Character, Integer&gt; tm = new TreeMap&lt;Character, Integer&gt;(); int count = 0;// put(K key, V value) 将指定值与此映射中的指定键进行关联。如果该映射以前包含此键的映射关系，那么将替换旧值。// public V get(Object key)。返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null// 遍历整个字符数组将每一个字母作为键值对插入map集合；// 调用get方法，如果返回null，说明不包含映射关系，则将该字母和1存入到map集合中；// 如果返回不是null，说明该字母存在并有对应次数（映射）， 那么获取该次数并进行自增，// 然后将该字母和自增后的次数存入到map集合中，覆盖掉原来键所对应的值。 for (int x = 0; x &lt; chs.length; x++) &#123; Integer value = tm.get(chs[x]); if (value != null) &#123; count = value; &#125;// 自增 count++; tm.put(chs[x], count);// 必须将count重置为0,；因为，当count自增到某一值时，对应下一个字母恰好是map集合中不存在的键，那么该count值会直接作为这个键的值 count = 0;// if (value==null)&#123;// tm.put(chs[x],1);// &#125;// else &#123;// value = value +1;// tm.put(chs[x],value);// &#125; &#125;// StringBuilder一个可变的字符序列（从1.5版本开始使用）。用于同步是不安全的，需要同步则用StringBuffer。 StringBuilder sb = new StringBuilder();// public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()；返回此映射中包含的映射关系的 Set 视图。（是TreeMap的方法） Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entrySet = tm.entrySet();// 创建Set接口的迭代器对象 Iterator&lt;Map.Entry&lt;Character, Integer&gt;&gt; iterator = entrySet.iterator(); while (iterator.hasNext()) &#123; Map.Entry&lt;Character, Integer&gt; me = iterator.next(); Character cha = me.getKey(); Integer in = me.getValue(); sb.append(cha + &quot;(&quot; + in + &quot;)&quot;); &#125; return sb.toString(); &#125;&#125; Map集合的扩展Map集合被使用是因为：它具备映射关系。练习：一个学校有多个教室，一对多，一个教室有多个学生集合(封装好的)，有映射关系。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package Collection;//import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.List;public class MapTest2 &#123; public static void main(String[] args) &#123;// HashMap&lt;String,HashMap&lt;String,String&gt;&gt; czbk = new HashMap&lt;&gt;();// HashMap&lt;String,String&gt; yure = new HashMap&lt;&gt;();// HashMap&lt;String,String&gt; jiuye = new HashMap&lt;&gt;();// yure.put(&quot;01&quot;,&quot;zhangsan&quot;);// yure.put(&quot;02&quot;,&quot;lisi&quot;);//// jiuye.put(&quot;01&quot;,&quot;zhaoliu&quot;);// jiuye.put(&quot;02&quot;,&quot;wangwu&quot;);////// czbk.put(&quot;yureban&quot;,yure);// czbk.put(&quot;jiuyeban&quot;,jiuye);// 遍历czbk集合，获取所有的教室// Iterator&lt;String&gt; it = czbk.keySet().iterator();// while (it.hasNext())&#123;// String roomaName = it.next();// HashMap&lt;String,String&gt; room = czbk.get(roomaName);//// System.out.println(roomaName);// getStudentInfo(room);// &#125; demo(); &#125; static class Student &#123; private String id; private String name; public Student(String id, String name) &#123; this.id = id; this.name = name; &#125; public String toString() &#123; return id + &quot;:::&quot; + name; &#125; &#125; public static void demo() &#123;// 在一个教室里，学生与学生对象没有映射关系；教室与学生的集合有映射关系// 可以使用list&lt;&gt;集合将Student对象存入java.util 接口 List&lt;E&gt;，是一个有序的collection（序列） HashMap&lt;String, List&lt;Student&gt;&gt; czbk = new HashMap&lt;&gt;();//List对象可以通过子类产生 List&lt;Student&gt; yure = new ArrayList&lt;Student&gt;(); List&lt;Student&gt; jiuye = new ArrayList&lt;Student&gt;();//插入映射的键值对 czbk.put(&quot;yureban&quot;, yure); czbk.put(&quot;jiuyeban&quot;, jiuye);// 将学生对象（指定的元素）添加到此列表的尾部。 yure.add(new Student(&quot;01&quot;, &quot;zhangsan&quot;)); yure.add(new Student(&quot;04&quot;, &quot;lisi&quot;)); jiuye.add(new Student(&quot;01&quot;, &quot;wangwu&quot;)); jiuye.add(new Student(&quot;02&quot;, &quot;zhaoli&quot;));//该映射的set视图的迭代器 Iterator&lt;String&gt; it = czbk.keySet().iterator(); while (it.hasNext()) &#123; String roomaName = it.next(); List&lt;Student&gt; room = czbk.get(roomaName); System.out.println(roomaName); getInfo(room); &#125; &#125; public static void getInfo(List&lt;Student&gt; list) &#123; Iterator&lt;Student&gt; it = list.iterator(); while (it.hasNext()) &#123; Student s = it.next(); System.out.println(s); &#125; &#125;// public static void getStudentInfo(HashMap&lt;String,String&gt; roomMap)&#123;// Iterator&lt;String&gt; it = roomMap.keySet().iterator();//// while (it.hasNext())&#123;// String id = it.next();// String name = roomMap.get(id);// System.out.println(id+&quot;:&quot;+name);// &#125;// &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>第16天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础（十一）]]></title>
    <url>%2F2018%2F09%2F11%2Fjava15%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[日积月累升级：安全，高效，简化 集合框架二叉树二叉树减少比较次数、提高效率。 泛型泛型格式：&lt;&gt;来定义要操作的引用数据类型。修饰方法时：必须放在返回值类型的前面，修饰符的后面。 在使用Java提供的对象时，什么时候写泛型呢？ 通常在集合框架中很常见，只要见到&lt;&gt;就要定义泛型；&lt;&gt;就是用来接收类型的。当使用集合时，将集合中要存储的数据类型作为参数传递到&lt;&gt;中即可 什么时候定义泛型类？ 当类中要操作的引用数据类型不确定的时候，早期定义Object来完成扩展，现在用泛型实现。泛型类定义的泛型，在整个类中有效，如果被方法使用，那么泛型类的对象明确要操作的具体类型后，所有要操作的类型就已经固定了。 为了让不同方法可以操作不同类型，而且类型还不确定。那么可以将泛型定义在方法上。 特殊之处：静态方法不可以访问类上定义的泛型，如果静态方法操作的应用数据类型不确定，可以将泛型定义在方法上。 123456789101112131415161718192021222324252627package Collection;import java.util.ArrayList;import java.util.Iterator;//JDK1.5 版本之后出现了新特性。用于解决安全问题，是一个类型安全机制//好处：1.将运行时期出现问题ClassCastException，转移到了编译时期，// 方便程序员解决问题，让运行时期问题减少。2.避免了强制转换的麻烦。public class FanXingTest &#123; public static void main(String[] args) &#123;//&lt;&gt;这就是泛型，定义了一个ArrayList容器，容器中元素类型是String ArrayList&lt;String&gt; a1 = new ArrayList&lt;String&gt;(); a1.add(&quot;abc01&quot;); a1.add(&quot;abc0991&quot;); a1.add(&quot;abc014&quot;);//迭代器中存的是add添加的元素，所以迭代器也要指定类型 Iterator&lt;String&gt; it = a1.iterator(); while (it.hasNext()) &#123;// 不用强制转换 String s = it.next(); System.out.println(s + &quot;:&quot; + s.length()); &#125; &#125;&#125; 泛型限定用&lt;?&gt;来代表通用类型；代表“明确的”类型。?通配符，占位符&lt;? extends E&gt;这就是泛型限定，用于泛型扩展。上限:可以接受E类型或者E子类型。&lt;? super E&gt;,下限:可以接收E类型或者E的父类型]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>第15天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[体测]]></title>
    <url>%2F2018%2F09%2F10%2Ftest%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java基础（十）]]></title>
    <url>%2F2018%2F09%2F09%2Fjava14%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[日积月累集合类 为什么会出现这么多的容器呢？因为每一个容器对数据的存储方式都有不同，我们称之为：数据结构。 Collection接口：add(E e):add方法的参数类型是Object，以便于接受任意类型对象。集合中存储的的地址remove(Object o):从此collection中移除指定元素的单个实例removeAll(Collection&lt;?&gt; c):移除collection中那些包含在指定collection中的所有元素clear():移除此collection中的所有元素contains(Object o):如果此collection包含指定的元素，则返回trueisEmpty():如果此collection中不包含元素，则返回trueretainAll(Collection&lt;?&gt; c):用来取交集并存储。 集合中存储的都是对象的引用（地址） 每一个集合都会有判断和取出方法，就把取出方式定义在集合的内部，这样取出方式就被定义成了内部类。而每一个容器的数据结构不同，所以取出的动作细节也不同，但是都有共性内容判断和取出。那么可以进行共性抽取。那么这些内部类都符合一个规则，该规则就是Iterator。如何获取集合的取出对象呢？通过一个对外提供的方法iterator()，返回在此collection的元素上进行迭代的迭代器。 Iterator接口是对collection进行迭代的迭代器。其实就是集合的取出元素的方式。Iterator接口的方法：hasNext()： 如果仍有元素可以迭代，则返回 true,next()：返回迭代的下一个元素,remove()：从迭代器指向的 collection 中移除迭代器返回的最后一个元素 List Collection List：元素是有序的，元素可以重复，因为该集合体系有索引 ArrayList:底层的数据结构是数组结构。特点：查询速度很快，但是增删很慢。 LinkedList:底层使用的是链表数据结构。特点：增删速度很快，查询稍慢。 vector:底层是数组数据结构。线程同步。被ArrayList替代了。其中有个特殊方法elements()，返回的是Enumeration接口对象（枚举）；枚举就是Vector特有的取出方式，其实枚举和迭代是一样的。 set：元素是无序的，元素不可以重复 List特有方法：凡是可以操作角标的方法都是该体系特有的方法。 增：add(index,element)在列表的指定位置插入指定元素;addAll(index,collection)添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序 删: remove(index) 移除列表中指定位置的元素 改：set(index,element) 用指定元素替换列表中指定位置的元素 查：get(index);subList(from,to);listIterator() List集合特有的迭代器：ListIterator()是Iterator的子接口。 在迭代时，不可以通过集合对象的方法操作集合中的元素。因为会发生ConcurrentModificationExcption异常（当方法检测到对象的并发修改，但不允许这种修改时，抛出此异常。）。 所以，在迭代时，只能用迭代器的方法操作元素，可是Iterator方法是有限的，只能对元素进行判断、取出、删除操作，如果想要其他的操作如添加、修改等，就需要使用其子接口，ListIterator。该接口之能通过List集合的listIterator()方法完成。 Linkedlist特有方法： addFirst():将指定元素插入此列表的开头 addLast():将指定元素插入此列表的结尾 getFirst():返回此列表的第一个元素 getLast():返回此列表的最后一个元素 removeFirst():移除并返回此列表的第一个元素，如果集合中没有元素，会出现NoSuchElementException removeLast():移除并返回此列表的最后一个元素，如果集合中没有元素，会出现NoSuchElementException 在JDK 1.6 出现了以上方法的替代方法 使用LinkedList模拟一个堆栈或者队列数据结构。堆栈：先进后出 如同一个杯子队列：先进先出(FIFO) 如同一个水管队列的实现：通过链表的方法。如如下代码块。堆栈同理。 12345678910111213141516171819202122232425262728293031323334353637383940package Collection;import java.util.LinkedList;//定义一个队列类，类中有构造方法产生链表对象，和对队列操作的方法class Queue &#123; private LinkedList list; Queue() &#123; list = new LinkedList(); &#125; public void myAdd(Object obj) &#123; list.addFirst(obj); &#125; public Object myGet() &#123; return list.removeLast(); &#125; public boolean isNull() &#123; return list.isEmpty(); &#125;&#125;public class LinkeListTest &#123; public static void main(String[] args) &#123;// 创建队列对象 Queue queue = new Queue();// 向队列对象中添加obj，实际上是给链表添加元素 queue.myAdd(&quot;Hello LinkedList---1&quot;); queue.myAdd(&quot;Hello LinkedList---2&quot;); queue.myAdd(&quot;Hello LinkedList---3&quot;); queue.myAdd(&quot;Hello LinkedList---4&quot;);//队列对象经过removeLast方法后，只要不为空，进行输出 while (!queue.isNull()) &#123; System.out.println(queue.myGet()); &#125; &#125;&#125; ArrayList练习：去除ArrayList集合中的重复元素 12345678910111213141516171819202122232425262728293031323334package Collection;/*去除ArrayList集合中重复的元素; * 思路： * 1. 新建一个数组集合用来保存不重复的元素 * 2. 遍历包含重复元素的数组集合，其中每一个元素都与新建的那个数组集合判断是否被包含，没有就加入这个数组集合*/import java.util.ArrayList;import java.util.Iterator;public class ArrayListTest &#123; // 去除重复元素的方法 public static ArrayList singleElement(ArrayList arrayList) &#123; ArrayList newAl = new ArrayList();//返回一个需要去除重复元素的数组集合的迭代器 Iterator it = arrayList.iterator();//循环判断每一个元素 while (it.hasNext()) &#123; Object obj = it.next(); if (!newAl.contains(obj)) newAl.add(obj); &#125; return newAl; &#125; public static void main(String[] args) &#123; ArrayList a1 = new ArrayList(); a1.add(&quot;Hello ArrayList---1&quot;); a1.add(&quot;Hello ArrayList---2&quot;); a1.add(&quot;Hello ArrayList---3&quot;); a1.add(&quot;Hello ArrayList---2&quot;); a1.add(&quot;Hello ArrayList---1&quot;); System.out.println(singleElement(a1)); &#125;&#125; 在迭代时循环中next调用一次，就要hasNext判断一次。 List集合判断元素是否相同，依据的是元素的equels方法 HashSetSet:元素是无序（存入和取出的顺序不一定一致），元素不可以重复 常见子类： HashSet:底层数据结构是哈希表。HashSet是如何保证元素唯一性的呢？是通过元素的两个方法，hashCode和equals来完成。如果元素的HashCode值相同，才会判断equals是否为true。如果元素的HashCode值不同，不会调用equals。 注意对于判断元素是否存在以及删除等操作，依赖的方法是元素的hashCode和equels方法。 TreeSet:可以对Set集合中的元素进行排序。 排序时，当主要条件相同时，一定要判断一下次要条件。底层数据结构是二叉树，保证元素唯一性的依据：compareTo方法返回0。 TreeSet排序的第一种方式：让元素自身具备比较性。元素需要实现Comparable接口，覆盖compareTo方法；这种方式也成为元素的自然顺序，或者叫默认顺序。 第二种排序方式：当元素自身不具备比较性，或者具备的比较性不是所需要的。这时就需要让集合自身具备比较性，在集合一初始化时，就有了比较方式。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>第14天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础（九）]]></title>
    <url>%2F2018%2F09%2F08%2Fjava13%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[日积月累String类 String s1 = “abc”;//s1是一个类类型变量，”abc”是一个对象 。字符串最大特点：一旦被初始化就不可以被改变。 String类复写了Object类中equals方法，该方法用于判断字符串内容是否相同。 String s1 = “abc”;String s2 = new String(“abc”);s1和s2有什么区别？s1在内存中一个对象，s2在内存中两个对象(new，”abc”)； String类提供的常见操作？”abcd” 获取 字符串中的包含的字符数，也就是字符串的长度。int length()。 数组的length是属性，没有() 根据位置获取位置上某个字符。char charAt(int index) 根据字符获取该字符在字符串中位置。int indexOf(int ch)：返回的是ch在字符串中第一次出现的位置。int indexOf(int ch,int fromIndex):从fromIndex指定位置开始，获取ch在字符串中的位置。如果没有找到返回-1. 判断 字符串中是否包含某一个子串 字符中是否有内容 字符串是否是以指定内容开头 字符串是否以指定内容结尾 字符串内容是 否相同 判断内容是否 相同，并忽略大小写 转换 将字符数组转成字符串 将字符串转成字符数组 将字节数组转成字符串 将字符串转成字节数组 替换 切割 子串 转换 StringBuffer StringBuffer是字符串缓冲区。是一个容器 而且长度可变化，可以直接操作多个数据类型，最终会通过toString()方法变成字符串。能进行增删改查 append(); 123StringBuffer sb = new StringBuffer();StringBuffer sb1 = sh.append(34);sout(sb == sb1)//true insert(index,数据); delete（start,end）; StringBuilder在JDK 1.5 版本之后出现，StringBuffer是线程同步的。StringBuilder是线程不同步的。StringBuilder提高效率，比较安全（减少并发）。 基本数据类型对象包装类 基本数据类型对象包装类的最常见作用：就是用于基本数据类型和字符串类型之间做转换 基本数据类型转成字符串。如基本数据类型+””；或者基本数据类型.toString(基本数据类型值）。字符串转成基本数据类型。如基本数据类型.paseInt(字符串); 十进制转成其他进制：toBinaryString();toHexString();toOctalString();其他进制转成十进制:parseInt(string,radix); 1234567Integer m = 128;Integer n = 128;sout(m==n)//falseInteger a = 127;Integer b = 127;sout(a==b)//true.因为a和b指向了同一个Integer对象。因为当数值在byte范围内容，对于新特性，如果该数值已经存在，则不会在开辟新的空间。 String字符串练习 模拟一个trim方法，去除字符串两端的空格。 思路： 判断字符串第一个位置是否是空格，如果是继续向下判断，直到不是空格为止；结尾处判断空格也是如此 当开始和结尾都怕短到不是空格时，就是要获取的字符串 12345678910111213141516171819202122232425262728293031package StringTest;/** 模拟一个trim方法，去除字符串两端的空格。*/public class TestOne &#123; public static void sop(String str)&#123; //定义一个输出方法 System.out.println(str); &#125; public static void main(String[] args) &#123; String s = &quot; ab cd &quot;; sop(&quot;(&quot;+s+&quot;)&quot;); //对字符串进行myTrim操作 s = myTrim(s); sop(&quot;(&quot;+s+&quot;)&quot;); &#125; public static String myTrim(String str)&#123; int start = 0; int end = str.length()-1; //从第一个位置开始查找空格，直到查到字符，停止查找，并返回当前的start值 while (start&lt;=end &amp;&amp; str.charAt(start)==&apos; &apos;) start++; //从最后一个位置开始从右至左查找空格，直到查到字符，停止查找，并返回当前的end值 while (start&lt;=end &amp;&amp; str.charAt(end)==&apos; &apos;) end--; //返回String对象，通过substring(start,end)方法获取子串，end位置的字符不计入子串。 return str.substring(start,end+1); &#125;&#125; 练习二:将一个字符串进行反转，将字符串中指定部分进行反转，“abcdefg”;abfedcg思路：1.知道如何对数组元素进行反转2.将字符串变成数组，进行反转3.将反转后的数组变成字符串4.只要将反转的部分的开始和结束位置作为参数传递即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package StringTest;/*将一个字符串进行反转，将字符串中指定部分进行反转，“abcdefg”;abfedcg思路：1.知道如何对数组元素进行反转2.将字符串变成数组，进行反转3.将反转后的数组变成字符串4.只要将反转的部分的开始和结束位置作为参数传递即可*/public class TestTwo &#123; public static void sop(String str) &#123; //定义一个输出方法 System.out.println(str); &#125; public static String reverseString(String s) &#123;// 字符串变成数组 char[] chars = s.toCharArray();// 反转数组 reverse(chars);// 将数组变成字符串,使用构造函数 return new String(chars); &#125; //方法的重载 public static String reverseString(String s, int start, int end) &#123; // 字符串变成数组 char[] chars = s.toCharArray();// 反转数组 reverse(chars, start, end); // 将数组变成字符串,使用构造函数 return new String(chars); &#125; private static void reverse(char[] chars, int x, int y) &#123; for (int start = x, end = y - 1; start &lt; end; start++, end--) &#123; swap(chars, start, end); &#125; &#125; //方法的重载 private static void reverse(char[] chars) &#123; for (int start = 0, end = chars.length - 1; start &lt; end; start++, end--) &#123; swap(chars, start, end); &#125; &#125;// 数组反转 private static void swap(char[] chars, int start, int end) &#123; char temp = chars[start]; chars[start] = chars[end]; chars[end] = temp; &#125; public static void main(String[] args) &#123; String s = &quot;abcdefg&quot;; sop(&quot;No reverse--&quot;+s); sop(&quot;absolute reverse---&quot;+reverseString(s)); sop(&quot;part reverse==&quot;+reverseString(s, 2, 6)); &#125;&#125; 练习：获取一个字符串在另一个字符串中出现的次数.”abkkcdkkefkkakk”思路：1.定义计数器2.获取“kk”第一次出现的位置3.从第一次出现位置后剩余的字符串中继续获取kk出现的位置，每获取一次就计数一次4.当获取不到时，计数完成 123456789101112131415161718192021222324252627282930313233343536package StringTest;/*获取一个字符串在另一个字符串中出现的次数.&quot;abkkcdkkefkkakk&quot; * 思路： * 1.定义计数器 * 2.获取“kk”第一次出现的位置 * 3.从第一次出现位置后剩余的字符串中继续获取kk出现的位置，每获取一次就计数一次 * 4.当获取不到时，计数完成*/public class TestThree &#123; public static void sop(String str) &#123; //定义一个输出方法 System.out.println(str); &#125; //定义获取出现重复kk次数的方法 public static int getSubCount(String str, String key) &#123;// 定义一个count用来计数，index用来记录出现kk的索引 int count = 0; int index = 0;//if判断只执行一次，while当条件为true就一直执行；indexOf(key)每次都是从0开始查找；indexOf(key,fromIndex)从指定位置开始查找。更高效 while ((index = str.indexOf(key, index)) != -1) &#123; sop(&quot;index=&quot; + index);// subString()方法：返回一个新的字符串，它是此字符串的一个子字符串。// 该子字符串从指定索引处的字符开始，直到此字符串末尾。str = str.substring(index + key.length()); index = index + key.length();// 计数 count++; &#125; return count; &#125; public static void main(String[] args) &#123; String str = &quot;abkkcdkkefkkakk&quot;; sop(&quot;count=&quot; + getSubCount(str, &quot;kk&quot;)); &#125;&#125; 练习：获取两个字符串中最大相同子串。第一个动作，将短的那个串进行长度一次递减的子串打印 “abcwerthelloyuicdef””cvhellobnm*思路：1.将短的那个子串按照长度递减的方式获取到2.将每获取到的子串去长串中判断是否包含，如果包含，已经找到！ 123456789101112131415161718192021222324252627282930313233343536373839404142package StringTest;/*获取两个字符串中最大相同子串。第一个动作，将短的那个串进行长度一次递减的子串打印 * “abcwerthelloyuicdef” * &quot;cvhellobnm* * 思路： * 1.将短的那个子串按照长度递减的方式获取到 * 2.将每获取到的子串去长串中判断是否包含，如果包含，已经找到！*/public class TestFour &#123; public static void sop(String str) &#123; //定义一个输出方法 System.out.println(str); &#125; // 定义一个获取最大相同子串的方法，比较的是两个字符串，局部变量就是两个字符串 public static String getMaxSubString(String s1, String s2) &#123; String max = s1.length() &gt;= s2.length() ? s1 : s2; String min = max == s1 ? s2 : s1;// 外层循环是控制短串需要进行多少次指针偏移，即要找多少次子串 for (int x = 0; x &lt; min.length(); x++) &#123;// 内层循环是控制当前长度的对应子串有多少个，y为头位置，z为尾标，当z的位置超过子串应有长度// （substring(start,end)方法中end位置字符不计入子串）停止查找 for (int y = 0, z = min.length() - x; z != min.length() + 1; y++, z++) &#123; String temp = min.substring(y, z);// sop(temp);// 如果长串中有包含短串中查找到的子串，返回一个String对象（temp） if (max.contains(temp)) return temp; &#125; &#125; return &quot;&quot;; &#125; public static void main(String[] args) &#123; String s2 = &quot;abcwerthelloyuicdef&quot;; String s1 = &quot;cvhellobnmaf&quot;;// 输出最大相同子串 sop(getMaxSubString(s1, s2)); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>第13天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础（八）]]></title>
    <url>%2F2018%2F09%2F08%2Fjava12%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[日积月累多线程间通信 线程间通讯：其实就是多个线程在操作同一个资源，但是操作的动作不同。 线程间通信，解决安全问题，同步的两个前提必须满足。 等待唤醒机制。wait():notify():notifyAll():都是用在同步中，因为要对持有监视器（锁）的线程操作。所以要使用在同步中，因为只有同步才具有锁。为什么这些操作线程的方法要定义在Object类中呢？因为这些方法在操作同步中线程时，都必须要标识他们所操作线程只有的锁，只有同一个锁上的被等待线程，可以被同一个锁上notify唤醒，不可以对不同锁中的线程进行唤醒。也就是说，等待和唤醒必须是同一个锁。而锁可以是任意对象，所以可以被任意对象调用的方法定义在Object类中。 当有多个生产者消费者，必须要用while循环，判断标记，唤醒全部线程。因为，让被唤醒的线程再一次判断标记。为什么定义notifyAll，因为需要唤醒对方线程。因为只用notify，容易出现只唤醒本方线程的情况，导致程序中的所有线程都等待。 JDK1.5 中提供了多线程升级解决方案。将同步Synchronized替换成Lock操作。将Object中的wait，notify，notifyAll，替换成Condition对象。该对象能Lock锁，进行获取。 多线程停止 如何停止线程？只有一种，run方法结束。开启多线程运行，运行代码通常是循环结构。只要控制住循环，就可以让run方法结束，也就是线程结束。当没有指定的方式让冻结的线程恢复到运行状态时，这时需要对冻结进行清除。强制让线程恢复到运行状态中来。这样就可以操作标记让线程结束。 守护线程。 Join方法：抢夺cpu执行权。当A线程执行到了B线程的.join方法时，A就会等待，等待B线程都执行完，A才执行。join可以用来临时加入线程执行。 优先级.setPriority() .yield()暂停当前正在执行的线程，让其他线程执行。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>第12天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础（七）]]></title>
    <url>%2F2018%2F09%2F07%2Fjava%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[日积月累多线程 进程：是一个正在执行中的程序。每一个进程执行都有一个执行顺序。该顺序是一个执行路径，或者叫一个控制单元。 线程：就是进程中的一个独立的控制单元。线程在控制着进程的执行。 一个进程中至少有一个线程。 java虚拟机启动的时候会有一个进程java.exe。该进程中至少有一个线程负责java程序的执行。而且这个线程运行的代码存在于main方法中，该线程称之为主线程。其实更细节说明jvm，jvm不止一个线程，还有负责垃圾回收机制的线程。 多线程的意义： 如何在自定义的代码中定义线程：①继承Thread类（1.定义类继承Thread 2.复写Thread类中的run方法（将自定义代码存储在run方法中，让线程运行） 3.调用线程的start方法，该方法有两个作用：启动线程，调用run方法） ②实现Runnable接口 为什么要复写run方法：Thread类用于描述线程。该类就定义了一个功能，用于存储线程要运行的代码。该存储功能就是run方法。也就是说Thread中run方法，用于存储要运行的代码 创建线程 static Thread currentThread():获取当前线程对象。getName():获取线程名称设置线程名称:setName或者构造函数 实现Runnable接口：步骤：1.定义类实现Runnable接口 2.覆盖Runnable接口中的run方法（将线程要运行的代码放在run方法中） 3.通过Thread类建立线程对象 4.将Runnable接口的子类对象作为实际参数传给Thread类的构造函数（为什么要将Runnable接口的子类对象传递给Thread的构造函数？因为，自定义的run方法所属的对象是Runnable接口的子类对象；所以要让线程去指定指定对象的run方法，就必须明确该run方法所属对象。） 5.调用Thread类的start方法开启线程并调用Runnable接口子类的run方法。 实现方式和继承方式有什么区别？实现方式好处在于避免了单继承的局限性。在定义线程时，建议使用实现方式。（继承一个父类的同时实现Runnable接口）两种方式的区别：继承Thread：线程代码存放在Thread子类run方法中。实现Runable：线程代码存放在接口的子类的run方法。 多线程的运行出现了安全问题。问题的原因：当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完；另一个线程参与进来执行，导致共享数据的错误。解决办法：对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程无法参与执行。Java对于多线程的安全问题提供了专业的解决方式，就是同步代码块。synchronized(对象){需要被同步的代码}需要被同步的代码是操作共享数据的代码，对象可以用Object对象。对象如同锁，持有锁的线程可以在同步中执行。没有持有锁的线程即使获取cpu的执行权，也进不去，因为没有获取锁。（如火车的卫生间）同步的前提：①必须要有两个或者两个以上的线程②必须是多个线程使用同一个锁必须保证同步中只能有一个线程在运行。好处：解决了多线程的安全问题弊端：多个线程需要判断锁，较为消耗资源 如何判断程序是否有安全问题？ 明确哪些代码是多线程运行代码 明确共享数据 明确多线程运行代码中哪些语句是操作共享数据的 同步是有同步函数和同步代码块两种写法。同步函数用的是哪一个锁？函数需要被对象调用，那么函数都有一个所属对象引用，就是this，所以同步函数使用的锁是this 如果同步函数被静态修饰后，使用的锁是什么呢？肯定不是this，因为静态方法中也不可以定义this。静态进内存时，内存中没有本类对象，但是一定有该类对应的字节码文件对象, 类名.class，该对象的类型是class。静态的同步方法，使用的锁是该方法所在类的字节码文件对象。类名.class 懒汉式特点在于实例的延时加载，如果多线程访问会出现安全问题，可以加同步，但是有点低效，可以用双重判断提高一点效率，锁是该类的字节码.class。（请写出延时加载的单例设计模式）。 class Single { private static Single s = null; private Single() { } public static Single getInstance() { if(s==null) { synchronized(Single.class) { if(s==null) s=new Single(); } } return s; } } 多线程的死锁程序！]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>第11天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础（六）]]></title>
    <url>%2F2018%2F09%2F07%2Fjava%E7%AC%AC%E5%8D%81%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[日积月累异常finally finally中定义的代码一定是会运行的代码。比如用在数据的关闭，避免占用数据库连接。通常用于关闭资源。 记住一点，catch是用于处理异常，如果没有catch就代表异常没有被处理过，如果该异常时检测时异常，那么必须声明。 异常在子父类覆盖中的体现： 子类在覆盖父类时，如果父类的方法抛出异常，那么子类的覆盖方法，只能抛出父类的异常或者该异常的子类 如果父类抛出多个异常，那么子类在覆盖该方法时，只能抛出父类异常的子集 如果父类或者接口的方法中没有异常抛出，那么子类在覆盖方法时，也不可以抛出异常。如果子类方法发生了异常，就必须要进行try处理。绝对不能抛。 异常练习 有一个圆形和长方形。都可以获取面积，对于面积如果出现非法的数值，视为是获取面积时出现问题。问题通过异常来表示。 异常总结 异常：是对问题的描述，将问题进行封装。 异常体系： Throwable Error Exception RuntimeException 异常体系的特点：异常体系中的所有类以及建立的对象都具有可抛性。也就是说可以被throw和throws关键字所操作。只有异常体系具备这个特点。 throw和throws的用法：throw定义在函数内，用于抛出异常对象。throws定义在函数上，用于抛出异常类，可以抛出多个用逗号隔开。 当函数内容有throw抛出异常对象，并未进行try处理，必须要在函数上声明，都在编译失败。注意，RuntimeException除外。也就是说，函数内如果抛出的RuntimeException异常，函数上可以不用声明。如果函数声明了异常，调用者需要进行处理。处理方法可以throws可以try。异常有两种： 编译时被检测异常；该异常在编译时，如果没有处理（没有抛出，没有try），编译失败 运行时异常（编译时不检测）；在编译时，不需要处理，编译器不检查。该异常的发生，建议不处理，让程序停止。需要对代码进行修正。 finally中定义的通常是关闭资源代码，因为资源必须释放 finally只有一种情况无法执行，那就是当执行到System.exit(0);finally不会执行 自定义异常：定义类继承Exception或者RuntimeException。为了让该自定义类具备可抛性；让该类具备操作异常的共性方法。当要定义自定义的信息时，可以使用父类已经定义好的功能。异常信息传递给父类的构造函数 自定义异常：按照java的面向对象思想，将程序中出现的特有问题进行封装 异常的好处：将问题进行封装。将正常流程代码和问题处理代码向分离，方便于阅读 异常的处理原则：处理方式有两种：try或者throws。调用到抛出异常的功能时，抛出几个，就处理几个。（一个try对应多个catch）。多个catch，父类的catch放到最下面。catch内，需要定义针对性的处理方式。不要简单的定义printStackTrace，输出语句。也不要不写。当捕获到的异常，本功能处理不了时，可以继续在catch中抛出。如果该异常处理不了，但并不属于该功能出现的异常。可以将异常转换后，再抛出和该功能相关的异常。或者异常可以处理，当需要将异常产生的和本功能相关的问题提供出去，当调用者知道，并处理。也可以将捕获异常处理后，转换新的异常。 异常的注意事项：在子父类覆盖时，子类抛出的异常必须是父类的异常的子类或者子集。如果父类或者接口没有异常抛出时，子类覆盖出现异常，只能try不能抛。 包package 包对类文件进行分类管理。给类提供多层命名空间。写在程序文件的第一行。类名的全称的是 包名.类名。包也是一种封装形式。 包与包之间访问，被访问的包中的类以及类中的成员，需要public修饰。 不同包中的子类还可以直接访问父类中protected权限修饰的成员。 public protected default private 为了简化类名的书写，就使用一个关键字，import。import导入的是包中的类。所以import packb.*;与import packb.haha.*;不太一样。建议：不要写通配符*，需要用到包中的哪个类，就写到哪]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>第十天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础（五）]]></title>
    <url>%2F2018%2F09%2F07%2Fjava%E7%AC%AC%E4%B9%9D%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[日积月累内部类 内部类好处：可以不用创建对象就能直接访问相对内部类的外部类的成员 内部类访问规则:①内部类可以直接访问外部类中的成员，包括私有。之所以能直接访问外部类中的成员，是因为内部类中持有一个外部类的引用，格式：外部类名.this②外部类访问内部类，必须要建立内部类对象。 访问格式：当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中直接建立内部类对象。 格式： 外部类名.内部类名 变量名 = 外部类对象.内部类对象；如 Outer.Innter in = new Outer().new Inner()； 当内部类在成员位置上，就可以被成员修饰符所修饰。比如，private:将内部类在外部类中进行封装。 static：内部类就具有静态特性；当内部类被static修饰后，只能直接访问外部类中的static成员，出现了访问局限。在外部其他类中，如何直接访问static内部类的非静态成员呢？new Outer.Inner().function();在外部其他类中，如何直接访问static内部类的静态成员呢？Outer.Inner.function();注意：当内部类中定义了静态成员，该内部类必须是static。当外部类中的静态方法访问内部类时，内部类也必须是static的 什么时候使用内部类？当描述事物时，事物的内部还有事物，该事物用内部类来描述。因为内部事物在使用外部事物的内容。 1234class Body&#123; private class Heart&#123;&#125;&#125; 内部类定义在局部时，①不可以被成员修饰符修饰②可以直接访问外部类中的成员，因为还持有外部类中的引用。但是不可以访问他所在的局部中的变量，只能访问被final修饰的局部变量。 匿名内部类 匿名内部类：匿名内部类其实就是内部类的简写格式。 定义匿名内部类的前提：内部类必须是继承一个类或者实现接口 匿名内部类的格式： new 父类或者接口(){定义子类的内容} 其实匿名内部类就是一个匿名子类对象。这个对象带有内容。 匿名内部类中定义的方法最好不要超过2个。 new Object();与new Object(){};的区别：new Object(); 是创建Object对象。new Object(){}; 是创建Object子类对象。 异常概述 异常：就是程序在运行时出现不正常情况。 异常由来：问题也是现实生活中一个具体的事物，也已通过java的类的形式进行描述。并封装成对象。其实就是java对不正常情况进行描述后的对象体现。 对于问题的划分：两种：一种是严重的问题；一种是非严重的问题。对于严重的，java通过Error类进行描述。对于非严重的，java通过Exception类进行描述。对于Error一般不编写针对性的代码进行处理；对于Exception可以使用针对性的处理方式进行处理。 无论Error或者Exception都具有一些共性内容。比如：不正常情况的信息，引发原因等。 异常的处理java提供了特有的语句处理： 123456789101112try&#123; 需要被检测的代码&#125;catch(异常类 变量)&#123; 处理异常的代码（处理方式）&#125;finally&#123; 一定会执行的语句&#125; 对捕获到的异常对象进行常见方法操作。其实jvm默认的异常处理机制，就是在调用printStackTrace方法。打印异常的堆栈的跟踪信息。 throws异常声明：在功能上通过throws的关键字声明了该功能有可能会出现问题。 对多异常的处理：①声明异常时，建议声明更为具体的异常。这样处理的可以更具体。②处理形式是多加catch，处理对应的异常③函数中有异常抛出就停止运行了；所以不会同时出现多个异常④对方声明几个异常，就对应几个catch块。如果多个catch块中的异常出现继承关系，父类异常catch块放在最下面。⑤建议在进行catch处理时，catch中一定要定义具体的处理方式，不要简单定义一句e.printStackTrace(),也不要简单的就书写一条输出语句。 因为项目中会出现特有的问题，而这些问题并未对java所描述并封装对象。所以对于这些特有的问题可以按照java的对问题封装的思想。将特有的问题，进行自定义的异常封装。 自定义异常。 当在函数内部出现了throw抛出异常对象，那么就必须要给对应的处理动作。要么在内部try catch处理，要么在函数上声明让调用者处理。一般情况，在函数内出现异常，函数上需要声明（throws）。 如何定义异常信息呢？因为父类中已经把异常信息的操作都完成了。所以子类只要在构造时，将异常信息传递给父类通过super语句。那么就可以直接通过getMessage方法获取自定义的异常信息。 自定义异常：必须是自定义类继承Exception。继承Exception原因：异常体系有一个特点：因为异常类和异常对象都被抛出。他们都具备可抛性。这个可抛性是Throwable这个体系中独有的特点。只有这个体系中的类和对象才可以被throws和throw操作 throw和throws的区别。throw使用在函数内。throws使用在函数上。throw后跟的是异常对象。throws后跟的是异常类，可以跟多个；用逗号隔开。 Exception中有一个特殊的子类异常RuntimeException运行时异常。如果在函数内容抛出该异常，函数上可以不用声明，编译一样通过。如果在函数上声明了该异常。调用者可以不用进行处理。编译一样通过。之所以不用在函数中声明，是因为不需要让调用者处理。当该异常发生，希望程序停止。因为在运行时，出现了无法继续运算的情况，希望停止程序后，程序员对代码进行修正。 自定义异常时，如果该异常的发生，无法再继续进行运算，就让自定义异常继承RuntimeException。 对于异常分两种：①编译时被检测的异常②编译时不被检测的异常（运行时异常，RuntimeException以及其子类） throw其实也是语句结束的标识，当抛出异常，程序停止运行了；所以在throw下面不要写其他的方法，因为不会执行。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>第九天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础（四）]]></title>
    <url>%2F2018%2F09%2F06%2Fjava%E7%AC%AC%E5%85%AB%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[日积月累多态 多态：可以理解为事物存在的多种体现形式。如人分为男人女人；动物：猫狗。猫 x = new 猫()；动物 x = new 猫(); 多态的体现：强迫子类重写方法；父类的引用指向了自己的子类对象。父类的引用也可以接受自己的子对象 多态的前提：①必须是类与类之间有关系，要么继承要么实现。②通常还有一个前提：存在覆盖 多态的弊端：提高了扩展性，但是只能使用父类的引用访问父类中的成员 多态的好处：提高了程序的扩展性 多态的应用 1234567Animal a = new Cat();//类型提升，向上转型a.eat();//如果想要调用猫特有方法时，如何操作？//强制将父类中的引用,转成子类类型。向下转型。Cat c = (Cat)a;c.catchMouse();//千万不能将父类对象转成子类类型。能转换的是父类引用指向了自己的子类对象时，该引用可以被提升，也可以被强制转换。多态自始至终都是子类对象在做变化。 多态使用的注意事项： 在多态中成员函数的特点：在编译时期：参阅引用型变量所属的类中是否有调用的方法。如果有，编译通过，如果没有编译失败。在运行时期：参阅对象所属的类中是否有调用的方法。简单总结就是：成员函数在多态调用时，编译看左边，运行看右边。如，Fu f=new Zi(); 在多态中，成员变量的特点：无论编译和运行，都参考左边（引用变量的类） 在多态中，静态成员函数的特点：无论编译和运行，都参考左边 多态的扩展示例 数据库的操作： 连接数据库。JDBC Hibernate 操作数据库。c creat r read u update d delete 关闭数据库连接 dao: data access object object类 Object：是所有对象的直接后者间接父类，传说中的上帝。该类中定义的肯定是所有对象都具备的功能 equals比较地址值。Object类中已经提供了对对象是否相同的比较方法。如果自定义类中也有比较相同的功能，没有必要重新定义。只要沿袭父类中的功能，建立自己特有的比较内容即可。这就是覆盖 toString()。对象都有自己的地址。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>第八天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础（三）]]></title>
    <url>%2F2018%2F09%2F06%2Fjava%E7%AC%AC%E4%B8%83%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[日积月累继承 例如学生和工人的共性都有姓名和年龄，那么可以将共性描述提取出来，单独进行描述；只要让学生和工人与单独描述的这个类有关系，就可以了。 继承：①提高了代码的复用性②让类与类之间产生了关系，有了这个关系，才有了多态的特性 注意：千万不要为了获取其他类的功能，简化代码而继承；必须是类与类之间有所属关系才可以继承。所属关系是is a。 父类是不断从子类中抽取出的共性体现。 Java语言中：java只支持单继承，不支持多继承。因为多继承容易带来安全隐患：当多个父类中定义了相同功能，当功能内容不同时，子类对象不确定要运行哪一个。优化了c++的多继承，java保留了这种机制，并用另一种体现形式来完成表示，多实现。 java支持多层继承。（爷爷-父亲-儿子）也就是一个继承体系，如何使用一个继承体系中的功能呢？想要使用体系，先查阅体系中父类的描述，因为父类中定义的是该体系中共性功能。通过了解共性功能，就可以知道该体系的基本功能。那么这个体系已经可以基本使用了。那么在具体调用时，要创建最子类的对象，为什么呢？一是因为有可能父类不能创建对象，二是创建子类可以使用更多的功能，包括基本的也包括特有的。 简单一句话：查阅父类功能，创建子类对象使用功能。（java中类只能有一个父亲） 聚集关系 聚合：一个球队有多名球员 组合：手是身体的一部分，心脏是身体的一部分。手和心脏就是组合关系。 球员少一个没关系，手（心脏）不能少 子父类中变量的特点 子父类出现后，类成员的特点：类中成员：变量，函数，构造函数。①变量：this是本类的引用，super是父类的引用。如果子父类中出现非私有的同名成员变量时，子类要访问本类中的变量，用this；子类要访问父类中的同名变量，用super。super的使用和this的使用几乎一致。this代表的是本类对象的引用。super代表的是父类对象的引用。 子父类中函数的特点 覆盖（重写）：当子类出现和父类一模一样的函数时，当子类对象调用该函数，会允许子类函数的内容。如同父类的函数被覆盖一样。 当子类继承了父类，沿袭了父类的功能到子类中；但是子类中虽具有该功能，但是功能的内容和父类不一致，这时，没有必要定义新功能，而是覆盖，保留父类的功能定义，并重写父类的功能方法。 提高扩展性 覆盖注意事项：①子类覆盖父类，必须保证子类权限大于等于父类权限，才可以覆盖，否则编译失败②静态只能覆盖静态 重载：只看同名函数的参数列表。重写：子父类方法要一模一样 子父类中的构造函数 在对子类对象进行初始化时，父类的构造函数也在运行；那是因为子类的构造函数默认第一行有一条隐式的语句super（）；super（）：会访问父类中空参数的构造函数，而且子类中所有的构造函数默认第一行都是super（）。 为什么子类一定要访问父类中的构造函数？因为父类中的数据，子类可以直接获取，所以子类对象获取时，需要查看父类是如何对这些数据进行初始化的。所以子类在初始化对象时，需要先访问一下父类中的构造函数。如果要访问父类中指定的构造函数，可以通过手动定义super函数语句来指定。 super语句一定要放在子类构造函数的第一行。 结论：子类的所有的构造函数，默认都会访问父类中空参数的构造函数。因为子类中每一个构造函数内的第一行都有一句隐式super（）。当父类中没有空参数的构造函数时，子类必须手动通过super语句形式来指定要访问的构造函数。当然子类的构造函数第一行也可以手动指定this语句来访问本类中的构造函数。子类中至少会有一个构造函数会访问父类中的构造函数。 final关键字 final：最终。作为一个修饰符。①可以修饰类，函数，变量②被final修饰的类不可以被继承。防止被子类复写。③被final修饰的方法不可以被复写④被final修饰的变量时一个常量，只能赋值一次，既可以修饰成员变量，又可以修饰局部变量⑤内部类定义在类中的局部位置上时，只能访问该局部被final修饰的局部变量。 当在描述事物时，一些数据的出现值是固定得而，那么这是为了增强阅读性，都给这些值起一个名字，方便阅读。而这个值不需要被改变，所以加上final关键字。作为常量，常量的书写规范所有字母都大写，如果多个单词组成。单词间通过_连接。 抽象类 当多个类中出现了相同功能，但是功能主体不同，这时可以进行向上抽取。这时，只抽取功能定义，而不抽取功能功能主体。 抽象：看不懂的功能。 抽象方法一定在抽象类中 抽象方法和抽象类都必须被abstract关键字修饰 抽象类不可以用new创建对象。因为调用抽象方法没意义 抽象类中的抽象方法要被使用，必须由子类复写起所有的抽象方法后，建立子类对象调用。如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类 抽象类和一般类没有太大不同。该如何描述事物，就如何描述事物，只不过，该事物出现了一些看不懂的东西。这些不确定的部分，也是该事物的功能，需要明确出现。但是无法定义主体。通过抽象方法来表示。 抽象类比一般类多了抽象函数。就是类中可以定义抽象方法。抽象类不能实例化。 特殊情况：抽象类中可以不定义抽象方法，这样做仅仅是不让该类建立对象 模范方法模式 什么是模板方法呢？在定义功能时，功能的一部分是确定的，但是有一部分是不确定，而确定的部分在使用不确定的部分；那么这时就将不确定的部分暴露出去，由该类的子类去完成。 接口 接口：初期理解，可以认为是一个特殊的抽象类；当抽象类中的方法都是抽象的，那么该类可以通过接口的形式来表示。 class用于定义类，interface用于定义接口 接口定义时，格式特点： 接口中常见定义：常量，抽象方法 接口中的成员都有固定修饰符。常量：public static final。方法：public abstract 接口中的成员都是public的 类与类之间继承关系，类与接口之间实现关系。继承，子类能直接用父类中的一些东西，不用很辛苦；实现，子类必须重写接口的所有抽象方法，非常辛苦。 接口不能创建对象，因为有抽象方法。需要被子类实现，子类对接口中的抽象方法全都覆盖后，子类才可以实例化，否则子类是一个抽象类。 接口可以被类多实现，也是对多继承不支持的转换形式，java支持多形式。 接口间的关系可以是（多）继承 接口的特点： 接口是对外暴露的规则 接口是程序的功能扩展 接口可以用来多实现 类与接口之间是实现关系，而且类可以继承一个类的同时实现多个接口 接口与接口之间可以有继承关系]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>第七天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础（二）]]></title>
    <url>%2F2018%2F09%2F06%2Fjava%E7%AC%AC%E5%85%AD%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[日积月累静态代码块 格式： 1234static&#123; 静态代码块中的执行语句&#125; 特点：随着类的加载而执行，只执行一次，并优先于主函数执行。用于给类进行初始化的。 设计模式 其实是一种思想，用来解决问题最有效的方法。 java中有23种设计模式： 单例设计模式：解决一个类在内存中只存在一个对象。想要保证对象唯一：①为了避免其他程序过多建立该类对象，先禁止其他程序建立该类对象②还为了想让其他程序可以访问到该类对象，只好在本类中，自定义一个对象③为了方便其他程序对自定义对象的访问，可以对外提供一些访问方式。怎么用代码体现这三步？①将构造函数私有化②在类中创建一个本类对象③提供一个方法可以获取到该对象 对于事物该怎么描述，还怎么描述。当需要将事物的对象保证在内存中唯一时，就将以上三步加上即可。如果方法要被调用，要用类.方法名()获得一个实例化，必须使用static关键字来修饰方法；该方法只能使用静态成员变量。 区分饿汉式和懒汉式：懒汉式对象初始化为null（延时加载）。饿汉式：类一进内存，就已经创建好了对象。懒汉式：类进内存，对象还没有存在，只有调用了获取对象方法时，才建立对象。开发时其实经常用饿汉式，这样比较安全；因为懒汉式被多个人同时调用时，会同时进行，被卡住，但是可以用synchronized关键字进行锁住，并多重判断； 记住原则：定义单例，建议使用饿汉式]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>第六天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础（一）]]></title>
    <url>%2F2018%2F09%2F05%2F9.5.1%2F</url>
    <content type="text"><![CDATA[日积月累构造函数 当一个类中没有定义构造函数时，那么系统会默认给该类加入一个空参数的构造函数 当定义了构造函数之后，不会再给出默认的构造函数 不同的构造函数对不同的对象进行初始化 构造函数主要帮助进行对象初始化 构造函数和一般函数在写法上有不同 构造函数是在对象一建立就运行。给对象初始化 一般方法是对象调用才执行，给是对象添加对象具备的功能 一个对象建立，构造函数只运行一次；而一般方法能被该对象调用多次 什么时候定义构造函数呢？当分析事物时，该事务存在就具备一些特性或者行为，那么这些内容定义在构造函数中 构造代码块 作用：给对象进行初始化。对象一建立就运行，而且优先于构造函数执行。和构造函数的区别：构造代码块是给所有对象进行统一初始化（不同对象共性的初始化内容）。而构造函数是给对应的对象初始化 this关键词 局部变量的名称和成员变量名称相同时，用来区分；用于构造函数间调用，一般函数不能调用构造函数，this用于构造函数 this为什么能解决这个问题？代表对象 this到底代表什么？this就代表本类的对象，到底代表哪一个呢？（可以new很多对象）this代表它所在函数所属对象的引用。简单说：哪个对象在调用this所在的函数，this就代表哪个对象 this的应用：当定义类中功能时，该函数内部要用到调用该函数对象时，这时就用this来表示这个对象。但凡本类中功能内部都使用了本类对象，都用this表示 构造函数间调用只能使用this this语句只能定义在构造函数的第一行，this()。 Static关键字 static静态，用法：是一个修饰符，用于修饰成员（成员变量，成员函数）。static修饰的内容被共享，不再放在堆内存中（在方法区，共享区，数据区），节约了内存开销 当成员被静态修饰后，就多了一个调用方式，除了可以被对象调用外，还可以直接被类名调用。（类名.静态成员） static特点：①随着类的加载而加载，随类的消失而消失。说明他的生命周期最长②优先于对象存在。明确一点：静态是先存在，对象是后存在③被所有对象所共享④可以被类名直接调用 被多个对象共有就可以用静态 实例变量和类变量的区别（静态成员变量）：①类变量随着累的加载而存在于方法区中。实例变量随着对象的建立而存在于堆内存中②生命周期：类变量生命周期最长，随着类的消失而消失。实例变量生命周期随着对象的消失而消失。 静态的使用注意事项：①静态方法只能访问静态成员。非静态方法能既可以访问静态，也可以访问非静态②静态方法中不可以定义this，super关键字。因为静态优先于对象存在，所以静态方法中不可以出现this③主函数是静态的 静态有利有弊：利：对对象的共享数据进行单独空间的存储，节省空间。没有必要每个对象中都存储一份。可以直接被类名调用。弊端：生命周期过长。访问出现局限性。（静态虽好，只能访问静态） main函数 主函数：是一个特殊的函数，作为程序的入口，可以被jvm调用 主函数的定义：public：代表着该函数访问权限是最大的static:代表主函数随着累的加载就已经存在了void：主函数没有具体的返回值main：不是关键字，是一个特殊的单词，能被jvm识别函数的参数：（String[] args)，参数类型是一个数组，该数组中的元素是字符串。字符串类型的数组。 主函数是固定格式的:jvm识别。主函数中唯一能改的地方是args。jvm在调用主函数时，传入的是new String[0]（长度为0）； 静态什么时候使用 要从两方面下手：因为静态修饰的内容有成员变量和函数。什么时候定义静态变量（类变量）呢？当对象中出现共享数据时，该数据被静态所修饰。对象中的特有数据要定义成非静态存在于堆内存中 什么时候定义静态函数呢？当功能内部没有访问到非静态数据（对象的特有数据），那么该功能可以定义成静态的。 静态函数只能调用静态函数 每一个应用程序中都有共性的功能，可以将这些功能进行抽取，独立封装，以便复用。 假如我们定义一个数组工具类，我们可以建立对象使用类中的方法，对数组操作。但是，对象并未封装特有数据；操作数组的每一个方法都没有用到类对象中的特有数据。这时就考虑，让程序更严谨，是不需要对象的。可以将工具类中的方法定义成static的，直接通过类名调用即可。将方法都静态后，可以方便于使用，但是该类还是可以被其他程序建立对象的。为了更加严谨，该类不能建立对象，可以将构造函数设置为私有化，防止被别人使用构造方法。 java说明书 通过文档注释来完成。 @author 张三 @version V1.1]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于ZigBee的温室大棚监测]]></title>
    <url>%2F2018%2F09%2F05%2F9.5%2F</url>
    <content type="text"><![CDATA[项目实现项目需要实现的功能ZigBee传感器 ZigBee需要的传感器获取数据 通过温湿度传感器获取大棚温度和湿度 光照传感器获取大棚内的光照强度 传感器数据发送包到协调器 服务器端 服务器解析由协调器发送来的包得到三种属性值 将三种属性值插入数据库 接收客户端的指令，进行操作 对数据库进行查询操作 对传感器发送指令，并让传感器做出相应的操作 客户端 查询大棚的温湿度、光强 读取天气预报 农作物生长最适宜的温湿度和光强查询]]></content>
      <categories>
        <category>大四课设</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编程基础笔记]]></title>
    <url>%2F2018%2F09%2F04%2F9.4.2%2F</url>
    <content type="text"><![CDATA[日积月累数据库、数据库系统和数据库管理系统三者之间的关系是( )数据库系统包括数据库和数据库管理系统 [数据库系统&gt;数据库管理系统&gt;数据库] 若用一个大小为6的数组来实现循环队列，队尾指针是rear、队头是front。当前rear和front的值分别为0和3，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为2和4 求最短路径的FLOYD算法的时间复杂度为（）。O(n3) 对n(n≥2)个权值均不相同的字符构成哈夫曼树， 下列 关于该 哈弗曼 树的叙述中，错误的是（A）A.该树一定是一棵完全二叉树B.树中一定没有度为1的结点C.树中两个权值最小的结点一定是兄弟结点D.树中任一非叶结点的权值一定不小于下一层任一结点的权值 数据库恢复的基础是利用转储的冗余数据。这些转储的冗余数据包括（ C）?A.数据字典、应用程序、审计档案、数据库后备副本B.数据字典、应用程序、日志文件、审计档案C.日志文件、数据库后备副本D.数据字典、应用程序、数据库后备副本 Which method you define as the starting point of new thread in a class from which n thread can be execution?public void run() 以下哪些不是链表的特征(ACD)？A.数据在内存中一定是连续的B.插入或删除时，无需移动其他元素C.可以随机访问表内的元素D.需要事先估计存储空间]]></content>
      <categories>
        <category>编程基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java笔记]]></title>
    <url>%2F2018%2F09%2F04%2F9.4.1%2F</url>
    <content type="text"><![CDATA[日积月累以下关于Object类的说法正确的是（A）A.Java中所有的类都直接或间接继承自Object，无论是否明确的指明，无论其是否是抽象类。B.Java中的接口(interface)也继承了Object类C.利用“==”比较两个对象时，Java调用继承自Object的equals方法，判断是否相等。D.如果类的定义中没有重新定义toString()方法，则该类创建的对象无法使用toStrig()方法。 给出以下代码1234567891011public class TestObj&#123; public static void main(String[] args)&#123; Object o=new Object()&#123; public boolean equals(Object obj)&#123; return true; &#125; &#125;; System.out.println(o.equals(“Fred”)); &#125;&#125;请给出结果:() true 关于数据库连接的程序，以下哪个语句的注释是错误的（ ）A.Class.forName(“sun.jdbc.odbc.JdbcOdbcDriver”); //指定MySQL JDBC驱动程序B.String url=“jdbc:odbc:student_access”; 指定数据源为student_accessC.Connection con=DriverManager.getConnection(url); //创建连接指定数据库的对象D.Statement stmt=con.creatStatement();//创建执行SQL语句的Statement对象 如下代码的输出是12345678910111213141516171819202122232425package Test;public class Test &#123; private static void test(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; try &#123; if (arr[i] % 2 == 0) &#123; throw new NullPointerException(); &#125; else &#123; System.out.print(i); &#125; &#125; finally &#123; System.out.print(&quot;e&quot;); &#125; &#125; &#125; public static void main(String[]args) &#123; try &#123; test(new int[] &#123;0, 1, 2, 3, 4, 5&#125;); &#125; catch (Exception e) &#123; System.out.print(&quot;E&quot;); &#125; &#125; &#125; 可以得到的结论是（ eE）]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库第一章（绪论）]]></title>
    <url>%2F2018%2F08%2F27%2F8.27%2F</url>
    <content type="text"><![CDATA[数据库基础第二章1.试述关系模型的三个组成部分关系模型是由关系数据结构、关系操作集合和关系完整性约束三部分组成。 2.简述关系数据语言的特点和分类关系代数语言关系演算语言：元组关系演算语言和域关系演算语言SQL：具有关系代数和关系演算双重特点的语言。这些关系数据语言的共同特点是，语言具有完备的表达能力，是非过程化的集合操作语言，功能强，能嵌入高级语言中使用 3.定义并理解下列术语，说明他们之间的联系与区别 域，笛卡尔积，关系，元组，属性 域：是一组具有相同数据类型的值的集合 笛卡尔积：是域上的一种集合运算 关系：D1xD2xD3x…xDn的子集在域D1,D2,D3,…,Dn上的关系表示为R(D1,D2,D3…,Dn) 元组：笛卡尔积中每一个元素(d1,d2,….,dn)叫做一个元组 属性： 主码，候选码，外码 主码：若一个关系有多个候选码，则选定其中一个为主码 候选码：关系中的某一属性的值能唯一标识一个元组，而其子集不能，则称该属性组为候选码 外码：在本关系中不是主码，在另一关系中是主码 关系模式，关系，关系数据库 关系模式：关系模式是型，关系是值。关系模式是对关系的描述 关系：关系是元组的集合，是关系模式在某一时刻的状态和内容 关系数据库：关系数据库的值是这些关系模式在某一时刻对应的关系的集合 4.试述关系模型的完整性规则。在参照完整性中，什么情况下外码属性的值可为空实体完整性规则是指若属性A是基本关系R的主属性，则属性A不能为空值。若属性F是基本关系R的外码，它与基本关系S的主码Ks相对应，则对于R中每个元组在F上的值必须为：或者取空值（F上的每个属性值均为空值）；或者等于S中某个元组的主码值。即属性F本身不是主属性，则可以取空值，否则不能取空值。 5.试述等值连接和自然连接的区别和联系连接运算符是“=”的连接运算称为等值连接。它是从关系R与S的广义笛卡尔积中选取A，B属性值相等的那些元组自然连接是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并在结果中把重复的属性列去掉 6.关系代数的基本运算有哪些？如何用这些基本的运算来表示其他运算？并，差，笛卡尔积，投影和选择5种运算为基本的运算。其他三种运算，即交，连接和除，均可以用这5种基本运算来表达。 第一章1.试述关系模型的概念，定义并解释以下术语：关系，属性，域，元组，码，分量，关系模式关系模型是最重要的一种数据模型。关系：一个关系对应通常说的一张表元组：表中的一行即为一个元组属性：表中的一列即为一个属性，给每一个属性起一个名称即属性名码：也称码键。表中的某个属性组，它可以唯一确定一个元组域：域是一组具有相同数据类型的值的集合分量：元组中的一个属性值关系模式：对关系的描述，一般表示为R(D1,D2,…Dn) 2.试述数据库系统的三级模式结构，并说明这种结构的优点是什么数据库系统的三级模式结构：外模式，模式，内模式。外模式：是数据库用户能看见和使用的局部数数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示模式：是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。模式描述的是数据的全局逻辑结构。外模式涉及的是数据的局部逻辑结构，通常是模式的子集内模式：亦称存储模式，是数据在数据库系统内部的表示，即对数据的物理结构和存储方式的描述。数据库系统的三级模式是对数据的三个抽象级别，它把数据的具体组织留给DBMS管理，使用户能逻辑抽象地处理数据而不必关心数据在计算机内的表示和存储。为了能在内部实现这三个抽象层次的联系和转换，数据库系统在咋还三级模式之间提供了两层映像：外模式/模式映像和模式/内模式映像。正是这两层映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性。 第三章1.试述SQL的特点①综合统一。SQL语言集数据定义语言DDL，数据操纵语言DML，数据控制语言DCL的功能于一体②高度非过程化③面向集合的操作方式④以同一种语法结构提供两种使用方式。SQL语言既是自含式语言，又是嵌入式语言 2.什么是基本表？什么是视图？两者的区别和联系是什么？基本表是本身独立存在的表，在SQL中一个关系就对应一个表。视图是从一个或几个基本表导出的表。视图本身不堵你存储在数据库中，是一个虚表。即数据库中只存放视图的定义而不存放视图对应的数据，这些数据仍放在导出视图的基本表中。视图在概念上与基本表等同，用户可以如同基本表那样使用视图，可以在视图上再定义视图。 3.试述视图的优点①视图能简化用户的操作②视图使用户能以多种角度看待同一数据③视图对重构数据库提供了一定程度的逻辑独立性④视图能对机密数据提供安全保护 第四章1.什么是数据库的安全性数据库的安全性是指保护数据库以防止不合法的使用所造成的数据泄露，更改或破坏 2.试述实现数据库安全性控制的常用方法和技术实现数据库安全性控制的常用方法和技术有：①用户标识和鉴别：该方法由系统提供一定的方式让用户标识自己的名字或身份。每次用户要求进入系统时，由系统进行核对，通过鉴定后才提供系统的使用权②存取控制：通过用户权限定义和合法权检查，确保只有合法权限的用户访问数据库，所有未被授权的人员无法存取数据。③视图机制：为不同的用户定义视图，通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动地对数据提供一定程度的安全保护④审计：建立审计日志，把用户对数据库的所有操作自动记录下来放入审计日志中，DBA可以利用审计跟踪的信息，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等。⑤数据加密：对存储和传输的数据进行加密处理，从而使得不知道解密算法的人无法获取数据的内容 第五章1.什么是数据库的完整性数据库的完整性是指数据的正确性和相容性 2.数据库的完整性概念和数据库的安全性概念有什么区别和联系数据的完整性和安全性是两个不同的概念，但是有一定的联系。前者是为了防止数据库中存在不符合语义的数据；防止错误信息的输入和输出，即所谓的垃圾进垃圾出所造成的无效操作和错误结果。后者是为了保护数据库防止恶意的破坏和非法的存取。也就是说，安全性措施的防范对象是非法用户和非法操作，完整性措施的防范对象是不合语义的数据。 3.什么是数据库的完整性约束条件？可分为哪几类？完整性约束条件是指数据库中的数据应该满足的语义约束条件。一般可以分为六类：静态列级约束、静态元组约束、静态关系约束、动态列级约束、动态元组约束、动态关系约束 4.DBMS的完整性控制机制应具有哪些功能？DBMS的完整性控制机制应该具有三个方面的功能：①定义功能，即提供定义完整性约束条件的机制②检查功能，即检查用户发出的操作请求是否违背了完整性约束条件③违约反应，如果发现用户的操作请求使数据违背了完整性约束条件，则采取一定的动作来保证数据的完整性 第七章1.试述数据库设计过程一、需求分析；二、概念结构设计；三、逻辑结构设计；四、数据库的物理设计；五、数据库实施；六、数据库运行和维护 2.试述数据库设计各个阶段上的设计描述一、需求分析：准确了解与分析用户需求（包括数据与处理）二、概念结构设计：通过对用户需求进行综合、归纳与抽象，形成一个独立于具体DBMS的概念模型三、逻辑结构设计：将概念模型转换为某个DBMS所支持的数据模型，并对其优化四、数据库物理设计：为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）五、数据库实施：设计人员运用DBMS提供的数据语言、工具及宿主语言，根据逻辑设计和物理设计的结果建立数据库，编制与调试应用程序，组织数据入库，并进行试运行六、数据库运行和维护：在数据库系统运行过程中对其进行评价、调整与修改 第十一章1.在数据库中为什么要用并发控制数据库是共享资源，通常有许多个事务同时运行。当多个事务并发地存取数据库时就会产生同时读取和/或修改同一数据的情况。若对并发操作不加控制就可能会存取和存储不正确的数据，破坏数据库的一致性。所以数据库管理系统必须提供并发控制机制 2.并发操作可能会产生哪几类数据不一致？用什么方法能避免各种不一致的情况并发操作带来的数据不一致性包括三类：丢失修改、不可重复读、脏数据。丢失修改：两个事务T1和T2读入同一数据并修改，T2提交的结果破坏了（覆盖了）T1提交的结果，导致T1的修改被丢失不可重复读：事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果脏数据：事务T1修改某一数据后，将其写会磁盘，事务T2读取统同一数据，T1由于某种原因撤销更改，T2读到的数据就是不正确的数据 避免不一致性的方法和技术就是并发控制。最常用的技术是封锁技术。也可以用其他技术，例如在分布式数据库系统中可采用时间戳方法来进行并发控制 3.什么是封锁？基本的封锁类型有几种？试述他们的含义封锁就是事务T在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁。加锁后事务T对该数据对象就有了一定的控制，在事务T释放它的锁之前，其他的事务不能更新此数据对象。封锁是实现并发控制的一个非常重要的技术 封锁的技术有两种：读锁（S）和写锁（X）；若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放了A的锁。若事务T对数据对象A加上S锁，则事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁 第十章1.登记日志文件时为什么必须先写日志文件，后写数据库？把对数据的修改写到数据库中和把表示这个修改的日志记录写到日志文件中是两个不同的操作。有可能在这两个操作之间发生故障，即这两个写操作只完成了一个。如果先写了数据库修改，而在运行记录中没有登记这个修改，则以后就无法恢复这个修改了。如果先写日志文件，但没有修改数据库，按日志文件恢复时只不过是多执行一次不必要的UNDO操作，并不会影响数据库的正确性。 2.针对不同的故障，试给出恢复的策略和方法事务故障的恢复：事务故障是指事务在运行至正常种终止点前被终止，这时恢复子系统应利用日志文件撤销（UNDO）此事务对数据库进行的修改。事务故障的恢复是由系统自动完成的，对用户是透明的。恢复步骤： 反向扫描日志文件，查找该事务的更新操作 对事务的更新操作进行逆操作 继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理 系统故障的恢复：系统故障造成数据库不一致状态的原因有两个，一是未完成事务对数据库的更新可能已写入数据库，二是已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库。因此恢复操作就是要撤销故障发生时未完成的事务，重做已完成的事务。恢复步骤： 正向扫描日志文件，找出在故障发生前已经提交的事务将其事务标识记入重做队列。同时找出故障发生时尚未完成的事务，将其事务标识记入撤销队列 对撤销队列中的各个事务进行撤销处理 对重做队列的各个事务进行重做处理 介质故障的恢复：发生介质故障后，磁盘上的物理数据和日志文件被破坏，这是严重的一种故障，恢复方法是重装数据库，然后重做已完成的事务。恢复步骤： 装入最新的数据库后备副本，使数据库恢复到最近一次转储的一致性状态 装入相应的日志文件副本，重做已完成的事务]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Strength]]></title>
    <url>%2F2018%2F08%2F23%2F8.23.3%2F</url>
    <content type="text"><![CDATA[健身基础全身各块肌肉，较好的训练动作每块肌肉一个专属动作： 最佳整体胸肌增长，哑铃平板卧推 最佳背阔肌宽度增长，宽握高位下拉（宽距引体） 最佳整体三角肌增长，哑铃推举 最佳二头肌增长，窄距反握引体向上 最佳三头肌增长，双杠臂屈伸 最佳股四头肌训练，颈前深蹲 最佳腘绳肌和臀部肌肉增长，罗马尼亚硬拉 最佳斜方肌增长，杠铃耸肩 最佳整体腹部训练，卷腹 最佳核心力量训练，平板支撑 最佳整体肌肉增长，深蹲 增肌9要点要点： 1个小时（训练控制在1小时内） 2个部位 3个动作 4组 一日5餐 6个部位（胸肩背腿腹臀） 7天（一个周期7天） 8RM 9个星期（开始休息1星期）]]></content>
      <categories>
        <category>fit</category>
      </categories>
      <tags>
        <tag>body</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（四十之Android网络应用）]]></title>
    <url>%2F2018%2F08%2F23%2F8.23.2%2F</url>
    <content type="text"><![CDATA[安卓基础Android完全支持JDK本身的TCP,UDP网络通信API，也可以使用ServerSocket、Socket来建立基于TCP/IP协议的网络通信，还可以使用DatagramSocaket、Datagrampacket、MulticastSocket来建立基于UDP协议的网络通信。Android也支持JDK提供的URL、URLConnection等网络通信API。 不仅如此，Android还内置了HttpClient，这样可以非常方便地发送HTTP请求，并获取HTTP响应，通过内置HttpClient，Android简化了与网站之间的交互。令人遗憾的是，Android并未内置对Web Service的支持，为了弥补这种不足，可以利用ksoap2-android项目在Android应用中调用远程Web Service。 基于TCP协议的网络通信TCP/IP通信协议是一种可靠的网络协议，它在通信的两端各建立一个Socket，从而在通信的两端之间形成了网络虚拟链路。一旦建立了它，两端的程序就可以通过它进行通信。Java对基于TCP协议的网络通信提供了良好的封装，Java使用Socket对象来代表两端的通信接口，并通过Socket产生IO流来进行网络通信。 TCP协议基础IP协议是Internet上使用的一个关键协议，它的全称是Internet Protocol，即Internet协议，简称IP协议。通过使用IP协议，使Internet成为一个允许连接不同类型的计算机和不同的操作系统的网络。要使两台计算机彼此之间进行通信，两台计算机必须使用同一种“语言”，IP协议只保证计算机能发送和接受分组数据。IP协议负责将消息从一个主机传送到另一个主机上，消息在传送的过程中被分割成一个个小包。尽管计算机通过安装IP软件，保证了计算机之间可以发送和接收数据，但IP协议还不能解决数据分组在传输过程中可能出现的问题。因此，若要解决可能出现的问题，连接上Internet的计算机还需要安装TCP协议来提供可靠并且无差错的通信服务。TCP协议被称为一种端对端协议。这是因为它为两台计算机之间的连接起了重要作用：当一台计算机需要与另一台远程计算机连接时，TCP协议会让它们建立一个连接——用于发送和接收数据的虚拟链路。TCP协议负责收集这些信息包，并将其按适当的次序放好发送，在接收端收到后再将其正确地还原。TCP协议保证了数据包在传送中准确无误。TCP协议使用重发机制：当一个通信实体发送一个消息给另一个通信实体之后，需要收到另一个通信实体的确认信息，如果没有收到另一个通信实体的确认信息，则会再次重发刚才发送的消息。 使用ServerSocket创建TCP服务器端Java中能接收其他通信实体连接请求的类是ServerSocket，ServerSocket对象用于监听来自客户端的Socket连接，如果没有连接，它将一直处于等待状态。ServerSocket包含一个监听来自客户端连接请求的方法： Socket accept()：如果接收到一个客户端Socket的连接请求，该方法将返回一个与连接客户端Socket对应的Socket；否则该方法将一直处于等待状态，线程也被阻塞 ServerSocket(int port)：用指定的端口port来创建一个ServerSocket。该端口有效整数值：0~65535 ServerSocket(int port,int backlog）：增加一个用来改变连接队列长度的参数backlog ServerSocket(int port,int backing,InetAddress localAddr)：在机器存在多个IP地址的情况下，允许通过localAddr这个参数来指定将该ServerSocket绑定到指定的IP地址 当ServerSocket使用完毕后，调用close（）方法来关闭该ServerSocket。 使用Socket进行通信客户端通常使用Socket的构造器来连接到指定服务器，Socket通常可提供如下两个构造器。 Socket(InetAddress/String remoteAddress,int port)：创建连接到指定远程主机、远程端口的Socket，该构造器没有指定本地地址、本地端口，默认使用本地主机的默认IP地址，默认使用系统动态分配的端口 Socket(InetAddress/String remoteAddress,int port,InetAddress localAddr,int localPort)：创建连接到指定远程主机、远程端口的Socket，并指定本地IP地址和本地端口，适用于本地主机有多个IP地址的情形 Socket提供了如下两个方法来获取输入流和输出流： InputStream getInputStream()：返回该Socket对象对应的输入流，让程序通过该输入流从Socket中取出数据 OutputStream getOutputStream()：返回该Socket对象对应的输入流，让程序通过该输入流向Socket中输入数据 Android已经不允许在UI线程中建立网络连接，需要启动新线程来建立网络连接。 加入多线程使用传统的BufferedReader的readLine()方法读取数据时，在该方法成功返回之前，线程被阻塞，程序无法继续执行。考虑到这个原因，服务器应该为每个Socket单独启动一条线程，每条线程负责与一个客户端进行通信。客户端读取服务器的线程同样会被阻塞，所以系统应该单独启动一条线程，该线程专门负责读取服务器数据。 每个客户端应该包含两条线程：一条负责生成主界面，响应用户动作，并将用户输入的数据写入Socket对应的输出流中；另一条负责读取Socket对应输入流中的数据（从服务器发送过来的数据），并负责将这些数据在程序界面上显示出来 使用URL访问网络资源URL(Uniform Resource Locator)对象代表统一资源定位器，它是指向互联网“资源”的指针。资源可以是简单的文件或目录，也可以是对更复杂的对象的引用，例如对数据库或搜索引擎的查询。通常情况，URL可以有协议名、主机、端口和资源组成，即满足如下格式：protocol://host:port/resourceName我们可以把URL理解成URI的特例，Java的URI不能用于定位任何资源，它的唯一作用就是解析。URL包含一个可打开到达资源的输入流。 URL类提供了多个构造器用于创建URL对象，一旦获得URL对象之后，可以调用如下常用方法来访问该URL对应的资源： String getFile()：获取此URL的资源名 String getHost()：获取此URL的主机名 String getPath()：获取此URL的路径部分 int getPort()：获取此URL的端口号 String getProtocol()：获取此URL的协议名称 String getQuery()：获取此URL的查询字符串部分 URLConnection openConnection()：返回一个URLConnection对象，它表示到URL所引用的远程对象的连接 InputStream openStream()：打开与此URL的连接，并返回一个用于读取该URL资源的InputStream 使用URL读取网络资源URL对象提供的openStream()可以读取该URL资源的InputStream，通过该方法可以非常方便地读取远程资源。 使用URLConnection提交请求URL的openConnection()方法将返回一个URLConnection对象，该对象表示应用程序和URL之间的通信连接。程序可以通过URLConnection实例向该URL发送请求，读取URL引用的资源。通常创建一个和URL的连接，并发送请求、读取此URL引用的资源需要如下几个步骤。 通过调用URL对象的openConnection()方法来创建URLConnection对象 设置URLConnection的参数和普通请求属性 如果只是发送GET请求，那么使用connect方法建立和远程资源之间的实际连接即可；如果需要发送POST方式的请求，则需要获取URLConnection实例对应的输出流来发送请求参数 远程资源变为可用，程序可以访问远程资源的头字段，或者通过输入流读取远程资源的数据 在建立和远程资源的实际连接之前，程序可以通过如下方法来设置请求头字段 setAllowUserInteraction：设置该URLConnection的allowUserInteraction请求头字段的值 setDoInput：设置该URLConnection的doInput请求头字段的值 setDoOutput：设置该URLConnection的doOutput请求头字段的值 setIfModifiedSince：设置该URLConnection的ifMOdifiedSince请求头字段的值 setUseCaches：设置该URLConnection的useCaches请求头字段的值，除此之外，还可以使用如下方法来设置或者增加通用的头字段 setRequestProperty(String key,String value)：设置该URLConnection的key请求头字段的值为value addRequestProperty(String key,String value)：为该URLConnection的key请求头字段增加value值，该方法并不会覆盖原请求头字段的值，而是将新值追加到原请求头字段中 当远程资源可用之后，程序可以使用以下方法来访问头字段和内容 Object getContent()：获取该URLConnection的内容 String getHeaderField(String name)：获取指定响应头字段的值 getInputStream()：返回该URLConnection对应的输入流，用于获取URLConnection响应的内容 getOutputStream()：返回该URLConnection对应的输出流，用于向URLConnection发送请求参数 PS：如果既要使用输入流来读取URLConnection响应的内容，也要使用输出流发送请求参数，一定要先使用输出流，再使用输入流 使用HttpURLConnectionHttpURLConnection继承了URLConnection，因此也可用于向指定网站发送GET请求、POST请求。在URLConnection的基础上提供了如下便捷的方法 int getResponseCode()：获取服务器的响应代码 String getResponseMessage()：获取服务器的响应信息 String getRequestMethod()：获取发送请求的方法 void setRequestMethod(String method)：设置发送请求的方法 为了实现多线程下载，步骤如下： 创建URL对象 获取指定URL对象所指向资源的大小（由getContentLength()方法实现），此处用到HttpURLConnection类 在本地磁盘上创建一个与网络资源相同大小的空文件夹 计算每条线程应该下载网络资源的哪个部分（从哪个字节开始，到哪个字节结束） 依次创建、启动多条线程来下载网络资源的指定部分 使用Apache HttpClient在一般情况下，如果只是需要向Web站点的某个简单页面提交请求并获取服务器响应，则完全可以使用前面所介绍的HttpURLConnection完成。但在大多数情况下，Web网页可能没这么简单，这些页面不是通过一个简单的URL就可以访问的，可能需要用户登录，而且具有相应的权限才可以访问该界面。为了更好地处理向Web站点请求，包括处理Session、Cookie等细节问题，Apache开源组织提供了一个HttpClient项目，它是一个简单的HTTP客户端，可以用于发送HTTP请求，接收HTTP响应。但不会缓存服务器的响应，不能执行HTML页面中嵌入的JavaScript代码；也不会对页面内容进行解析和处理。（HttpClient是一个增强的HttpURLConnection）使用HttpClient发送请求、接收响应，步骤： 创建HttpClient对象 如果需要发送GET请求，则创建HttpGet对象；如果需要发送POST请求，则创建HttpPost对象 如果需要发送请求参数，则可调用HttpGet、HttpPost共同的setParams(HttpParams params)方法来添加请求参数；对于HttpPost对象而言，也可调用setEntity(HttpEntity entity)方法来设置请求参数 调用HttpClient对象的execute(HttpUriRequest request)方法发送请求，执行该方法返回一个HttpResponse 调用HttpResponse的getAllHeaders()、getHeaders(String name)等方法可获取服务器的响应头；调用HttpResponse的getEntity()方法可获取HttpEntity对象，该对象包装了服务器的响应内容。程序可通过该对象获取服务器的响应内容 程序只要第一次通过HttpClient登录系统，接下来即可通过该HttpClient访问被保护的资源。 使用WebView浏览网页WebView的用法与普通ImageView组件的用法基本相似，它提供了大量方法来执行浏览器操作，例如如下常用方法： void goBack()：后退 void goForward()：前进 void loadUrl(String url)：加载指定URL对应的网页 boolean zoomln()：放大网页 boolean zoomOut()：缩小网页 通过WebView的loadUrl()方法来加载显示指定URL对应的页面 使用WebView加载HTML代码WebView提供了一个loadData(String data,String mimeType,String encoding)方法，该方法用于加载并显示HTML代码。但在实际使用过程中，当它加载包含中文的HTML内容时，WebView将会显示乱码。不过loadDataWithBaseURL(String baseUrl,String data,String mimeType,String encoding,String historyUrl)方法，该方法是loadData(String data,String mimeType,String encoding)方法的增强版，他不会产生乱码。 参数： data：指定需要加载的HTML代码 mimeType：指定HTML代码的MIME类型，对于HTML代码可指定为text/html encoding：指定HTML代码编码所使用的字符集，比如GBK 使用WebView中的JavaScript调用Android方法很多时候，WebView加载的页面是带有JavaScript脚步的，比如页面上有一个按钮，用户单击按钮时将会弹出一个提示框，或打开一个列表框。由于该按钮是HTML页面上的按钮，它只能激发一段JavaScript脚步，这就要让JavaScript脚步来调用Android方法。在WebView的JavaScript中调用Android方法只要如下三个步骤： 调用WebView关联的WebSettings的setJavaScriptEnabled(true)启用JavaScript调用功能 调用WebView的addJavascriptInterface(Object object,String name)方法将object对象暴露给JavaScript脚步 在JavaScript脚本中通过刚才暴露的name对象调用Android方法 JavaScript脚本可以直接调用Java对象的方法 使用Web Service进行网络编程为了让Android应用与远程服务器进行交互，可以借助于Java的RMI技术，但这要求远程服务器程序必须采用Java实现；也可以借助于CORBA技术，但是这种技术显得过于复杂。除此之外，Web Service是一种不错的选择。 Web Service平台概述Web Service平台主要涉及的技术有SOAP（Simple Object Access Protocol，简单对象访问协议）,WSDL（Web Service Description Language，Web Service描述语言）,UDDI（Universal Description,Description and Integration，统一描述、发现和整合协议） SOAP是一种具有扩展性的XML消息协议。SOAP允许一个应用程序向另一个应用程序发送XML消息，SOAP消息是从SOAP发送者传至SOAP接收者的单路消息，任何应用程序均可作为发送者或接收者。SOAP仅定义消息结构和消息处理的协议，与底层的传输协议独立。因此，SOAP协议能通过HTTP,JMS,SMTP协议传输 &lt;Envelope…/&gt;根元素，SOAP消息对应的XML文档以该元素作为根元素 可选的&lt;Header../&gt;元素，包含SOAP消息的头信息 必须的&lt;Body../&gt;元素，包含所有的调用和响应信息 WSDL使用XML描述Web Service，包括访问和使用Web Service所必须的信息，定义该Web Service的位置、功能及如何通信等描述信息 WHAT部分：用于定义Web Service所提供的操作或者方法。由WSDL中&lt;type../&gt;,&lt;message../&gt;和&lt;portType../&gt;元素定义 HOW部分：用于定义如何访问Web Service，包括数据格式详情和访问Web Service操作的必要协议 WHERE部分：用于定义Web Service位于何处。该部分使用&lt;service…/&gt;元素定义 UDDI是一套信息注册规范，它基于Web，是分布式。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>TCP协议基础</tag>
        <tag>使用ServerSocket创建TCP服务器端</tag>
        <tag>使用Socket进行通信</tag>
        <tag>加入多线程</tag>
        <tag>使用URL读取网络资源</tag>
        <tag>使用Apache Httpclient</tag>
        <tag>使用Web View</tag>
        <tag>使用Web Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（三十九之多媒体应用开发）]]></title>
    <url>%2F2018%2F08%2F23%2F8.23%2F</url>
    <content type="text"><![CDATA[安卓基础音频和视频的播放使用MediaPlayer播放音频当程序控制MediaPlayer对象装载音频完成之后，程序可以调用MediaPlayer的如下三个方法进行播放控制： start()：开始或恢复播放 stop() pause() 为了让MediaPlayer来装载指定音频文件，MediaPlayer提供了如下简单的静态方法： static MediaPlayer create(Context context,Uri uri)：从指定Uri来装载音频文件，并返回新创建的MediaPlayer对象 static MediaPlayer create(Context context,int resid)：从resid资源ID对应的资源文件中装载音频文件，并返回新创建的MediaPlayer对象 上面两个方法不适用于MediaPlayer循环播放多个音频文件，因为每次都会返回新创建的MediaPlayer对象。此时可通过MediaPlayer的setDataSource()方法来装载指定的音频文件。MediaPlayer提供了如下方法： setDataSource(String path)：指定装载path路径下所代表的文件 setDataSource(FileDescriptor fd,long offset,long length)：指定装载fd所代表的文件中从offset开始、长度为length的文件内容 setDataSource(FileDescriptor fd)：指定装载fd所代表的文件 setDataSource(Context context,Uri uri)：指定装载uri所代表的文件 执行了上面的setDataSource（）方法后，MediaPlayer并未真正去装载那些音频文件，还需要调用MediaPlayer的prepare（）方法去真正装载音频文件。 MediaPlayer还提供了一些绑定事件监听器的方法，用于监听MediaPlayer播放过程中所发生的特定事件。绑定事件监听器的方法如下： setOnCompletionListener(MediaPlayer.OnCompletionListener listener)：为MediaPlayer的播放完成事件绑定事件监听器 setOnErrorListener(MediaPlayer.OnErrorListener listener)：为MediaPlayer的播放错误事件绑定事件监听器 setOnPreparedListener(MediaPlayer.OnpreparedListener listener)：当MediaPlayer调用prepare()方法时触发该监听器 setOnSeekCompleteListener(MediaPlayer.OnSeekCompleteListener listener)：当MediaPlayer调用seek()方法时触发该监听器 1.播放应用的资源文件，播放应用的资源文件需要两步（音频资源文件一般放在Android应用中的/res/raw目录下）： 调用MediaPlayer的creat（Context Context,int resid）方法装载指定的资源文件 调用MediaPlayer的start(),pause(),stop()等方法控制播放即可 2.播放应用的原始资源文件： 调用Context的getAssets（）方法获取应用的AsserManager 调用AssetManager对象的openFd（String name）方法打开指定的原始资源文件，该方法返回一个AssetFileDescriptor对象 调用AssetFileDescriptor的getFileDescriptor（）、getStartOffset（）、getLength（）方法来获取音频文件的FileDescriptor、开始位置、长度等。 创建MediaPlayer对象，并调用MediaPlayer对象的setDataSource(FileDescriptor fd,long offset,long length)方法来装载音频资源 调用MediaPlayer对象的prepare（）方法准备音频 调用MediaPlayer的start（），pause（），stop（）方法控制播放 3.播放外部存储器上的音频文件 创建MediaPlayer对象，并调用MediaPlayer对象的setDataSource（String path）方法装载指定的音频文件 调用MediaPlayer对象的prepare（）方法准备音频 调用MediaPlayer的start（），pause（），stop（）方法控制播放 4.播放来自网络的音频文件 方式：①直接使用MediaPlayer的静态create（Context context，Uri uri）方法②调用MediaPlayer的setDataSource(Context context,Uri uri)方法装载指定Uri对应的音频文件 以第二种方式播放来自网络的音频文件的步骤如下： 根据网络的音频文件所在的文字创建Uri对象 创建MediaPlayer对象，并调用MediaPlayer对象的setDataSource(Context context,Uri uri)方法装载Uri对应的音频文件 调用MediaPlayer对象的prepare（）方法准备音频 调用MediaPlayer的start（），pause（），stop（）方法控制播放 MediaPlayer除了调用prepare（）方法来准备声音之外，还可以调用prepareAsync（）来准备声音。prepareAsync（）是异步的，他不会阻塞当前的UI进程 MediaPlayer的状态图： 音乐特效控制Android播放音乐的均衡器靠AudioEffect及其子类完成的。它的子类如下： AcousticEchoCanceler：取消回声控制器 AutomaticGainControl：自动增益控制器 NoiseSuppressor：噪声压制控制器 BassBoost：重低音控制器（setStrength（short strength）方法来设置重低音的强度） Equalizer：均衡控制器（getNumberOfPresets()方法获取该均衡器所有预设的音场并提供了getPresetName()方法获取预设音场名称。获取Equalizer对象后，可调用它的getNumberOfBands()方法获取该均衡器支持的总频率，再调用getCenterFreq(short band)方法根据索引来获取频率。当用户想为某个频率的均衡器设置参数值时，可调用setBandLevel(Short band,short level)方法进行设置 PresetReverb：预设音场控制器（调用setPreset(short preset)方法设置使用预设置的音场。 Visualizer：示波器（它不用于控制音乐播放效果，他只是显示音乐的播放波形。为了实时显示该示波器的数据需要为该组件设置一个OnDataCaptureListener监听器，该监听器将负责更新波形显示组件的界面） 上述前三个子类的用法很简单，只要调用它们的静态create（）方法创建相应的实例，然后调用它们的isAvailable（）方法判断是否可用，再调用setEnabled（boolean enable）方法启动相应效果即可。 后四个类，都需要调用构造器来创建实例。创建实例时，同样需要传入一个audioSession参数，为了启用他们，同样需要调用AudioEffect基类的setEnabled（true）方法。 使用SoundPool播放音效MediaPlayer存在如下缺点： 资源占用量较高，延迟时间较长 不支持多个音频同时播放 Android系统SoundPool提供了一个Builder内部类，该内部类专门用于创建SoundPool。SoundPool提供了如下4个load()重载方法： int load(Context context,int resId,int priority)：从resId所对应的资源加载声音 int load(FileDescriptor fd,long offset,long length,int priority)：加载fd所对应的文件中从offset开始、长度为length的声音 int load(AssetFileDescriptor afd,int priority)：从afd所对应的文件中加载声音 int load(String path,int priority)：从path对应的文件去加载声音 该priority参数目前没有任何作用，Android建议将该参数设为1，保持和未来的兼容性。上面4个方法加载声音之后，都会返回该声音的ID，以后程序就可以通过该声音的ID来播放指定声音了。SoundPool提供的播放指定声音的方法如下： int play(int soundID,float leftVolume,float rightVolume,int priority,int loop,float rate)：该方法的第一个参数指定播放哪个声音；priority指定播放声音的优先级，数值越大，优先级越高；loop指定是否循环，0为不循环，-1为循环；rate指定播放的比率，数字可从0.5到2,1为正常比率。 归纳起来，使用SoundPool播放声音的步骤如下： 调用SoundPool.Builder的构造器创建SoundPool.Builder对象，并可通过该Builder对象为SoundPool设置属性 调用SoundPool的构造器创建SoundPool对象 调用SoundPool对象的load()方法从指定资源、文件中加载声音。最好使用HashMap&lt;Integer,Integer&gt;来管理所加载的声音 调用SoundPool的play()方法播放声音 实际使用SoundPool播放声音时有如下几点需要注意：SoundPool虽然可以一次性加载多个声音，但由于内存限制，因此避免使用SoundPool来播放歌曲或者做游戏背景音乐，只有那些短促、密集的声音才考虑用SoundPool进行播放。 使用VideoView播放视频使用步骤： 在界面布局文件中定义VideoView组件，或者在程序中创建VideoView组件 调用VideoView的如下两个方法来加载指定视频 setVideoPath(String path) setVideoUri(Uri uri) 调用VideoView的start(),stop(),pause()方法来控制视频播放 实际上与VideoView结合使用的还有一个MediaController类，它提供一个友好的图形控制界面。 1234567//获得对象MediaController mController = new MediaController(this);//设置videoView与mController建立关联videoView.setVideoPath(video.getAbsolutePath());videoView.setMediaController(mController);mController.setMediaPlayer(videoView);videoView.requestFocus(); 使用MediaRecorder录制音频使用步骤： 创建MediaRecorder对象 调用MediaRecorder对象的setAudioSoruce()方法设置声音来源，一般传入MediaRecorder.AudioSource.MIC参数指定录制来自麦克风的声音 调用MediaRecorder对象的setOutputFormat()方法设置所录制的音频文件格式 调用MediaRecorder对象的setAudioEncoder(),setAudioEncodingBitRate(int bitRate),setAudioSamplingRate(int samplingRate)方法设置所录制的声音编码格式、编码位率、采样率等，这些参数将可以控制所录制的声音品质、文件大小。一般来说，声音品质越好，声音文件越大 调用MediaRecorder的setOutputFile(String path)方法设置所录制的音频文件的保存位置 调用MediaRecorder的prepare()方法准备录制 调用MediaRecorder对象的start()方法开始录制 录制完成，调用MediaRecorder对象的stop()方法停止录制，并调用release()方法释放资源 ps：第三步和第四步不能反；需要录制声音的权限和向外部存储器写入数据的权限 MediaRecorder的状态图： 控制摄像头拍照使用Android5.0的Camera v2拍照Android5.0的Camera v2涉及如下API： CameraManager：摄像头管理器 CameraCharacteristics：摄像头特性 CameraDevice：代表系统摄像头 CameraCaptureSession：这是一个非常重要的API，当程序需要预览、拍照时，都需要先通过该类的实例创建Session。该对象控制预览的方法为setRepeatingRequest()；控制拍照的方法为capture() CameraRequest和CameraRequest.Builder：当程序调用setRepeatingRequest()方法进行预览时，或调用capture()方法进行拍照时，都需要传入CameraRequest参数 录制视频短片MediaRecorder还可用于录制视频。为了让MediaRecorder录制时采集图像，应该在调用setAudioSource(int audio_source)方法时再调用setVideoSource(int video_source)方法来设置图像来源 Android 5.0 新增的屏幕捕捉Android 5.0 新增了MediaProjectionManager管理器，该管理器可以非常方便地实现了屏幕捕捉功能。使用步骤： 以MEDIA_PROJECTION_SERVICE为参数，调用Context.getSystemService()方法即可获取MediaProjectionManager实例 调用MediaProjectionManager对象的createScreenCaptureIntent()方法创建一个屏幕捕捉的Intent 调用startActivityForResult()方法启动第2步得到的Intent，这样即可启动屏幕捕捉的Intent 重写onActivityResult()方法，在该方法中通过MediaProjectionManager对象来获得MediaProjection对象，在该对象中即可获取被捕捉的屏幕]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>使用MediaPlayer播放音频</tag>
        <tag>音乐特效控制器</tag>
        <tag>使用SoundPool播放音乐</tag>
        <tag>使用VideoView播放视频</tag>
        <tag>使用MediaRecorder录制音频</tag>
        <tag>Android 5.0 的Camera v2拍照</tag>
        <tag>屏幕捕捉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（三十八之使用Service与BroadcastReceiver）]]></title>
    <url>%2F2018%2F08%2F22%2F8.22.2%2F</url>
    <content type="text"><![CDATA[安卓基础接受广播消息BroadcastReceiver本质上就是一个全局监听器，用于监听系统全局的广播消息。由于BroadcastReceiver是一个全局监听器，因此它可以非常方便地实现系统中不同组件之间的通信。 BroadcastReceiverBroadcastReceiver用于接受程序（包括用户开发的程序和系统内建的程序）所发出的Broadcast Intent，与应用程序启动Activity、Service相同的是，程序启动BroadcastReceiver也只需要两步： 创建需要启动的BroadcastReceiver的Intent 调用Context的sendBroadcast()或sendOrderedBroadcast()方法来启动指定的BroadcastReceiver 与Activity、Service具有完整的生命周期不同，BroadcastReceiver本质上只是一个系统级的监听器——它专门负责监听各程序所发出的Broadcast。前面介绍的各种OnXxxListener只是程序级别的监听器，这些监听器运行在指定程序所在进程中，当程序退出时，OnXxxListener监听器也就随之关闭了。但BroadcastReceiver属于系统级的监听器，他拥有自己的进程，只要存在与之匹配的Intent被广播出来，BroadcastReceiver就会被激发。实现BroadcastReceiver的方法十分简单，只要重写BroadcastReceiver的onReceive(Context context,Intent intent)方法即可。一旦实现了BroadcastReceiver，接下来就应该指定该BroadcastReceiver能匹配的Intent，此时有两种方式： 使用代码进行指定，调用BroadcastReceiver的Context的registerReceiver(BroadcastReceiver receiver,IntentFilter filter)方法指定 在AndroidManifest.xml中配置。例如如下代码： 12345&lt;receiver android:name=&quot;.IncomingSMSReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 每次系统Broadcast事件发生后，系统就会创建相应的BroadcastReceiver实例，并自动触发它的onReceive()方法，onReceive()方法执行完之后，BroadcastReceiver实例就会被销毁。如果BroadcastReceiver的onReceive（）方法不能再10秒内执行完成，Android会认为该程序无响应。所以不要在BroadcastReceiver的onReceive（）方法里执行一些耗时的操作；否则就会弹出ANR（Application No Response）对话框。**如果确实需要根据Broadcast来完成一项比较耗时的操作，则可以考虑通过Intent启动一个Service来完成该操作。不应考虑使用新线程去完成耗时的操作，因为BroadcastReceiver本身的生命周期就很短，可能出现的情况是子线程可能还没有结束，BroadcastReceiver就已经退出了。虽然该进程内还有用户启动的新线程，但由于该进程内不包含任何活动组件，因此系统可能在内存紧张时优先结束该进程。这样就可能导致BroadcastReceiver启动的子线程不能执行完成。 发送广播只要调用Context的sendBroadcast(Intent intent)方法即可，这条广播将会启动intent参数对应的BroadcastReceiver。 有序广播Broadcast分为两种： Normal Broadcast(普通广播)：Normal Broadcast是完全异步的，可以在同一时刻（逻辑上）被所有接受者接收到，消息传递的效率比较高。缺点是接受者不能将处理结果传递给下一个接收者，并且无法终止Broadcast Intent的传播 Ordered Broadcast(有序广播)：Ordered Broadcast的接受者将按预先声明的优先级高低依次接收Broadcast。优先级别声明在&lt;intent-filter…/&gt;元素的android:priority属性中，数越大优先级别越高，取值范围为-1000~1000；也可以调用IntentFilter对象的setPriority（）设置优先级别。Ordered Broadcast接收者可以终止Broadcast Intent的传播，Broadcast Intent传播一旦终止，后面的接收者就无法接收到Broadcast。另外，OrderedBroadcast的接受者可以将数据传递给下一个接收者。 对于Ordered Broadcast而言，调用BroadcastReceiver的abortBroadcast()方法即可终止Broadcast；优先接受到Broadcast的接收者可以通过setResultExtras(Bundle)方法将处理结果存入Broadcast中，然后传给下一个接收者，下一个接收者通过代码Bundle bundle = getResultExtras(true)可以获取上一个接收者存入的数据。 实例比如程序有一个Activity和Service，而且Service是通过startService（）方法气动的，正常情况下，这个Activity与通过startService（）方法启动的Service之间无法通信，但借助BroadcastReceiver的帮助，程序就可以实现两者之间的通信。 PS：对于BroadcastReceiver程序实现过程：①当实现sendBroadcast（intent）方法 ②与之intent对应绑定的BroadcastReceiver会被自动调用。 接收系统广播消息除了可以接收用户发送的广播之外，还可以接收系统广播。Android的大量系统事件会对外发送标准广播。下面是Android常见的广播Action常量： ACTION_TIME_CHANGED：系统时间被改变 ACTION_DATE_CHANGED：系统日期被改变 ACTION_TIMEZONE_CHANGED：系统时区被改变 ACTION_BOOT_COMPLETED：系统启动完成 ACTION_PACKAGE_ADDED：系统添加包 ACTION_PACKAGE_CHANGED：系统包的改变 ACTION_PACKAGE_REMOVED：系统包的删除 ACTION_PACKAGE_RESTARTED：系统的包被重启 ACTION_PACKAGE_DATA_CLEARED：系统的包数据被清空 ACTION_BATTERY_CHANGED：电池电量改变 ACTION_BATTERY_LOW：电池电量低 ACTION_POWER_CONNECTED：系统连接电源 ACTION_POWWER_DISCONNECTED：系统与电源断开 ACTION_SHUTDOWN：系统被关]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>BroadcastReceiver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（三十七之使用Service与BroadcastReceiver）]]></title>
    <url>%2F2018%2F08%2F22%2F8.22%2F</url>
    <content type="text"><![CDATA[安卓基础Service的生命周期Service生命周期图： 与多次调用startService()方法启动Service，就多次回调Service的onStartCommand()方法不同的是，多次调用bindService()方法并不会重复绑定，且只会回调一次onBind()方法。 当Activity调用bindService()绑定一个已启动的Service时，系统只是把Service内部IBinder对象传给Activity，并不会把该Service生命周期完全“绑定”到该Activity，因而当Activity调用unBindService()方法取消与该Service的绑定时，也只是切断该Activity与Service之间的关联，并不能停止该Service组件。 使用IntentServiceIntentService是Service的子类。Service本身存在两个问题： Service不会专门启动一个单独的进程，Service与它所在应用位于同一个进程中。 Service不是一条新的线程，因此不应该在Service中直接处理耗时任务。 如果开发者需要在Service中处理耗时任务，建议在Service中另外启动一条新的线程来处理该耗时任务。直接在其他程序组件中启动子线程来处理耗时任务不行吗？这种方式也不可靠，由于Activity可能会被用户退出，而BroadcastReceiver的生命周期本来就很短。可能出现：在子线程还没有结束的情况下，Activity就已经被用户退出了，或者BroadcastReceiver已经结束了。在Activity已经退出、BroadcastReceiver已经结束的情况下，此时他们所在的进程就变成了空进程（没有任何活动组件的进程），系统需要内存时可能会优先终止该进程。如果宿主进程被终止，那么该进程内的所有子线程也会被终止，这样就可能导致子线程无法执行完成。而IntentService正好可以弥补Service的上面的两个不足：IntentService将会使用队列来管理请求Intent，每当客户端代码通过Intent请求启动IntentService时，IntentService会将该Intent加入队列中，然后开启一条新的worker线程来处理该Intent。对于异步的startService()请求，IntentService会按次序依次处理队列中的Intent，该线程保证同一时刻只处理一个Intent。由于IntentService使用新的worker线程处理Intent请求，因此IntentService不会阻塞主线程，所以IntentService自己就可以处理耗时任务。归纳起来，IntentService有如下特征： IntentService会创建单独的worker线程来处理所有的Intent请求 IntentService会创建单独的worker线程来处理onHandleIntent()方法实现的代码，因此开发者无须处理多线程问题 当所有请求处理完成后，IntentService会自动停止，因此开发者无须调用stopSelf()方法来停止该Service 为Service的onBind()方法提供了默认实现，默认实现的onBind()方法返回null 为Service的onStartCommand()方法提供了默认实现，该实现将请求Intent添加到队列中 扩展IntentService实现Service无须重写onBind()和onStartCommand()方法，只要重写onHandleIntent()方法即可，在该方法中定义该Service需要完成的任务。 如果用继承Service子类的MyService来执行耗时操作，会导致UI线程阻塞（ANR异常）。 电话管理器（TelephonyManager）TelephonyManager是一个管理手机通话状态、电话网络信息的服务类，该类提供了大量getXxx()方法获取网络状态和SIM卡的相关信息。在程序中获取TelephonyManager：TelephonyManager tManager = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE) TelephonyManager还提供了一个listen(PhoneStateListener listener,int events)方法来监听通话状态。程序中要首先取得TelephonyManager对象，再创建一个PhoneStateListener，它是一个通话状态监听器，该监听器可用于对TelephonyManager进行监听。 ##短信管理器（SmsManager） SmsManager提供了一系列sendXxxMessage()方法用于发送短信，发送普通文本内容调用sendTextMessage()方法即可。 123456//获取SmsManagersManager = SmsManager.getDefault()//创建一个PendingIntent对象PendingIntent pi = PengingIntent.getActivity(MainActivity.this,0,new Intent(),0)//发送短信sManager.sendTextManage(number.getText().toString(),null,content.getText().toString(),pi,null) PendingIntent是对Intent的包装，一般通过调用PendingIntent的getActivity()、getService（）、getBroadcastReceiver（）静态方法来获取PendingIntent对象。与Intent对象不同的是，PendingIntent通常会传给其他应用组件，从而有其他应用程序来执行PendingIntent所包装的“Intent”。 音频管理器（AudioManager）程序如果需要管理系统音量，或者让系统静音，这就可借助于Android提供的AudioManager来实现。程序一样是调用getSystemService()方法来获取系统的音频管理器。 AudioManagerAudioManager对象调整手机指定类型的声音的方法： adjustStreamVolume(int streamType,int direction,int flags)。其中第一个参数streamType指定声音类型，它的值如下： STREAM_ALARM：闹钟 STREAM_DTMF：DTMF音调的声音 STREAM_MUSIC：音乐 STREAM_NOTIFICATION：系统提示 STREAM_RING：电话铃声 STREAM_SYSTEM：手机系统 STREAM_VOICE_CALL：语音电话 第二个参数对声音进行增大或者减小；第三个参数是调整声音时的标志，指定为FLAG_SHOW_UI，则调整声音时显示音量进度条。 setMicrophoneMute(boolean on)：设置是否让麦克风静音 setMode(int mode)：设置声音模式，值可为：NORMAL,RINGTONE,IN_CALL setRingerMode(int ringerMode)：设置手机的电话铃声模式。值可为： RINGER_MODE_NORMAL：正常的手机铃声 RINGER_MODE_SILENT：手机铃声静音 RINGER_MODE_VIBRATE：手机振动 setSpeakeerphoneOn(boolean on)：设置是否打开扩音器 setStreamMute(int streamType,boolean state)：将手机的指定类型的声音调整为静音。 setStreamVolume(int streamType,int index,int flags)：直接设置手机的指定类型的音量值。 振动器（Vibrator）有时候程序需要启动振动器，比如手机静音时使用振动提示用户；当玩游戏时，当系统碰撞、爆炸时使用振动带给用户更逼真的体验。系统获取Vibrator也是调用了context的getSystemService()方法。 Vibrator简介Vibrator的使用： vibrate(long milliseconds)：控制手机振动milliseconds毫秒 vibrate(long[] pattern,int repeat)：指定手机以pattern指定的模式振动。例如指定pattern为new int[400,800,1200,1600]，也就是在400ms、800ms、1200ms、1600ms这些时间点交替启动、关闭手机振动器；其中repeat指定pattern数组的索引，指定对pattern数组中从repeat索引开始的振动进行循环 cancel()：关闭手机振动 程序控制手机振动需要得到相应的权限，在AndroidManifest.xml文件中加授权代码：` ` 手机闹钟服务（AlarmManager）AlarmManager通常用来开发手机闹钟。但是，它的本质是一个全局定时器，AlarmManager可以在指定时间或者指定周期启动其他组件（包括Activity，Service，BroadcastReceiver）。 AlarmManager在Android应用程序中也是通过Context的getSystemService()方法来获取AlarmManager对象的。获得AlarmManager对象后，可调用如下方法来设置定时启动指定组件： set(int type,long triggerAtTime,PendingIntent operation):设置在triggerAtTime时间启动由operation参数指定的组件。其中第一个参数指定定时服务的类型，该参数有如下值： ELAPSED_REALTIME:指定从现在开始时间过了一定时间后启动operation所对应的组件。 ELAPSED_REALTIME_WAKEUP：指定从现在开始时间过了一定时间后启动operation所对应的组件。即使系统处于休眠状态也会启动相应组件 RTC：指定当系统调用System.currentTimeMillis()方法的返回值与triggerAtTime相等时启动operation所对应的组件 RTC_WAKEUP：指定当系统调用System.currentTimeMillis()方法的返回值与triggerAtTime相等时启动operation所对应的组件。即使系统处于休眠状态也会执行operation所对应的组件 setInexactRepeating(int type,long triggerAtTime,long interval,PendingIntent operation):设置一个非精确的周期性任务。 setRepeating(int type,long triggerAtTime,long interval,PendingIntent operation)：设置一个周期性执行的定时任务 cancel(PendingIntent operation)：取消AlarmManager的定时任务 AlarmManager新增的如下两个方法支持精确激发： setExact(int type,long triggerAtMillis,PendingIntent operation)：设置闹钟将在精确的时间被触发 setWindow(int type,long windowStartMillis,long windowLengthMillis,PendingIntent operation)：设置闹钟将在精确的时间段内被触发 其他（System.currentTimeMillis()方法）在开发过程中，通常很多人都习惯使用new Date()来获取当前时间。new Date()所做的事情其实就是调用了System.currentTimeMillis()。如果仅仅是需要或者毫秒数，那么完全可以使用System.currentTimeMillis()去代替new Date()，效率上会高一点。如果需要在同一个方法里面多次使用new Date()，通常性能就是这样一点一点地消耗掉。System.currentTimeMillis()+3600*1000)可以这样解读：System.currentTimeMillis()相当于是毫秒为单位，但是，后头成了1000，就变成了以秒为单位。那么，3600秒=1小时，所以输出为当前时间的1小时后；我们可以这样控制时间：System.currentTimeMillis()+time*1000)，里面传入的time是以秒为单位，当传入60，则输出：当前时间的一分钟后。 Calendar.getInstance()是获取一个Calendar对象并可以进行时间的计算，时区的指定；Calendar的对象和new Date()对象可以相互转化：Calendar calendar = Calendar.getInstance();Date date = calendar.getTime(); 更换壁纸（WallpaperManager）它提供了clear()方法来清除壁纸，还提供了如下方法来设置系统的壁纸： serBitmap(Bitmap bitmap)：将壁纸设置为bitmap所代表的位图 setResource(int resid)：将壁纸设置为resid资源所代表的图片 setStream(InputStream data)：将壁纸设置为data数据所代表的图片 markdown语法中转义字符123456789101112\\ 反斜杠\` 反引号\* 星号\_ 下划线\&#123;\&#125; 大括号\[\] 中括号\(\) 小括号\# 井号\+ 加号\- 减号\. 英文句号\! 感叹号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Service的生命周期</tag>
        <tag>IntentService</tag>
        <tag>PendingIntent</tag>
        <tag>电话管理器（TelephonyManager）</tag>
        <tag>短信管理器（SmsManager）</tag>
        <tag>音频管理器（AudioManager）</tag>
        <tag>振动器Vibrator</tag>
        <tag>手机闹钟服务AlarmManager</tag>
        <tag>System.currentTimeMillis()</tag>
        <tag>markdown转义字符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（三十六之使用Service与BroadcastReceiver）]]></title>
    <url>%2F2018%2F08%2F21%2F8.21.2%2F</url>
    <content type="text"><![CDATA[安卓基础Service与Activity十分相似，都代表可执行的程序；区别在于：Service一直在后台运行，它没有用户界面，不会到前台来。一旦Service被启动起来，它就与Activity一样，它完全有自己的生命周期。程序中Activity与Service的选择标准是，如果某个程序组件需要在运行时间向用户呈现某种界面，或者该程序需要与用户交互，就需要使用Activity。否则就使用Service。 ServiceService组件也是可执行的程序，它也有自己的生命周期。 创建配置Service步骤： 定义一个继承Service的子类 在AndroidManifest.xml文件中配置该Service Service和Activity都是从Context派生出来的，因此他们都可调用Context里定义的如getResources(),getContentResolver()等方法。 Service生命周期图： Service生命周期方法： IBinder onBind(Intent intent)：该方法是Service子类必须实现的方法。该方法必须返回一个IBinder对象，应用程序可以通过该对象与Service组件通信。 void onCreate()：在该Service第一次被创建后将会立即回调该方法 void onDestroy()：在该Service被关闭之前回调该方法 void onStartCommand(Intent intent,int flags,int startId)：该方法的早期版本是void onStart(Intent intent,int startId)，每次客户端调用startService(Intent intent)方法启动该Service时都会回调该方法 boolean onUnbind(Intent intent)：当该Service上绑定的所有客户端都断开连接时将会回调该方法 在AndroidManifest.xml中配置Service组件： 配置一个Service组件 -->12&lt;service android:name=&quot;&quot;&gt;&lt;/service&gt; 配置Service无须指定android:label属性——Service没有界面，指定标签意义不大。 在Android系统中运行Service有如下两种方式。 通过Context的startService()方法：访问者与Service之间没有关联，即使访问者退出了，Service仍然运行 通过Context的bindService()方法：访问者与Service之间绑定在一起，访问者退出，Service也就终止了 启动和停止Service调用Context里定义的statService(),stopService()方法即可启动，关闭Service。每当Service被创建时会回调onCreate()方法，每次Service被启动时都会回调onStartCommand()方法——多次启动一个已有的Service组件将不会再回调onCreate()方法，但每次启动时都会回调onStartCommand()方法。 绑定本地Service并与之通信当程序通过startService(),stopService()启动，关闭Service时，Service与访问者之间基本上不存在太多的关联，因此Service和访问者之间也无法进行通信、交换数据。如果Service和访问者之间需要进行方法调用或交换数据，则应该使用bindService()和unbindService()方法启动、关闭Service。 Context的bindService()方法的完整方法签名为：bindService(Intent service,ServiceConnection conn,int flags)，该方法的三个参数为： service:通过Intent指定要启动的Service。 conn：该参数是一个ServiceConnection对象，该对象用于监听访问者与Service之间的连接情况。当访问者与Service之间连接成功时回调该ServiceConnection对象的onServiceConnected(ComponentName name,IBinder service)方法，该binder对象即可实现与被绑定Service之间的通信；当Service所在的宿主进程由于异常中止或其他原因终止，导致该Service与访问者之间断开连接时回调该ServiceConnection对象的onServiceDisconnected(ComponentName name)方法。 flags：指定绑定时是否自动创建Service(如果Service还未创建）。该参数可指定为0（不自动创建）或BIND_AUTO_CREATE（自动创建） 在开发子类时提供的一个IBinder onBinder(Intent intent)方法，在绑定本地Service的情况下，onBind(Intent intent)方法所返回的IBinder对象将会传给ServiceConnection对象里onServiceConnected(ComponentName name,IBinder service)方法的service参数，这样访问者就可以通过该IBinder对象与Service进行通信了。IBinder对象相当于Service组件的内部钩子，该钩子关联到绑定的Service组件，当其他程序组件绑定到该Service时，Service将会把该IBinder对象返回给其他程序组件，其他程序组件通过该IBinder对象即可与Service组件进行实时通信。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>创建配置Service</tag>
        <tag>启动停止Service</tag>
        <tag>绑定本地Service并与之通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（三十五之使用ContentProvider实现数据共享）]]></title>
    <url>%2F2018%2F08%2F21%2F8.21%2F</url>
    <content type="text"><![CDATA[安卓基础###使用ContentProvider管理多媒体内容 Android为多媒体提供的ContentProvider的Uri如下： MediaStore.Audio.Media.EXTERNAL_CONTENT_URI MediaStore.Audio.Media.INTERNAL_CONTENT_URI MediaStore.Images.Media.EXTERNAL_CONTENT_URI MediaStore.Images.Media.INTERNAL_CONTENT_URI MediaStore.Video.Media.EXTERNAL_CONTENT_URI MediaStore.Video.Media.INTERNAL_CONTENT_URI 其中EXTERNAL标识在外部存储器，INTERNAL标识在内部存储器；Audio，Images，Video分别标识音频，图片，视频。 对外部存储修改，需要在AndroidManifest.xml文件中增加配置： 1234&lt;!-- 授予读取外部存储设备的访问权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;&lt;!-- 授予写入外部存储设备的访问权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; 监听ContentProvider的数据改变当ContentProvider将数据共享出来之后，ContentResolver会根据业务需要去主动查询ContentProvider所共享的数据。有时候，应用程序需要实时监听ContentProvider所共享数据的改变，并随着ContentProvider的数据的改变而提供响应，这就需要利用ContentObserver了。 ContentObserver监听ContentProvider数据改变的监听器需要继承ContentObserver类，并重写该基类所定义的onChange(boolean selfChange)方法———当它所监听的ContentProvider数据改变时，该onChange()方法将会被触发。为了监听指定ContentProvider的数据变化，需要通过ContentResolver向指定Uri注册ContentObserver监听器。 registerContentObserver(Uri uri,boolean notifyForDescendents,ContentObserver observer) uri:该监听器所监听的ContentProvider的Uri notifyForDescendents：如果该参数设为true，假如注册监听的Uri为content://abc,那么Uri为content://abc/xyz,content://abc/xyz/foo的数据发生改变时也会触发该监听器；如果该参数设为false，假如注册监听器为content://abc，那么只有content://abc的数据发生改变时才会触发该监听器 observer：监听器实例 PS：ContentResolver用于操作ContentProvider提供的数据；ContentObserver用于监听ContentProvider的数据改变；而ContentProvider则是所有ContentProvider组件的基类]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ContentProvider</tag>
        <tag>ContentObserver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（三十四之使用ContentProvider实现数据共享）]]></title>
    <url>%2F2018%2F08%2F20%2F8.20%2F</url>
    <content type="text"><![CDATA[安卓基础为了在应用程序之间交换数据，Android提供了ContentProvider，它是不同应用之间进行数据交换的标准API。 ContentProvider也是Android应用的四大组件之一，与Activity、Service、BroadcastReceiver相似，他们都要在AndroidManifest.xml文件中配置。 数据共享标准：ContentProviderContentProvider以某种Uri的形式对外提供数据，允许其他应用访问或修改数据；其他应用程序是哟个ContentResolver根据Uri去访问操作指定数据。 可以将ContentProvider与ContentResolver简单的类比；可以把ContentProvider当成Android系统内部的“网站”，这个网站以固定的Uri对外提供服务；而ContentResolver则可以当成Android系统内部的HttpClient，它可以向指定Uri发送“请求”（实际上是调用ContentResolver的方法），这种请求最后委托给ContentProvider处理，从而实现对“网站”（ContentProvider）内部数据进行操作。 ContentProvider简介开发一个ContentProvider步骤： 定义自己的ContentProvider类，该类需要继承Android提供的ContentProvider基类 向Android系统注册，在AndroidManifest.xml中注册ContentProvider，就像注册Activity一样。 继承了ContentProvider之外，还要提供如下方法： public boolean onCreate()：ContentProvider创建时被调用，其他应用第一次访问ContentProvider时，该ContentProvider被创建出来，并立即回调该onCreate()方法 public Uri insert(Uri uri,ContentValues values)：根据该Uri插入values对应的数据 public int delete(Uri uri,String selection,String[] selectionArgs)：根据Uri删除selection条件所匹配的全部记录 public int update(Uri uri,ContentValues values,String selection,String[] selectionArgs)：根据Uri修改selection条件所匹配的全部记录 public Cursor query(Uri uri,String[] projection,String selection,String[] selectionArgs,String sortOrder)：根据Uri查询出selection条件所匹配的全部记录，其中projection就是一个列名列表，表明只选择出指定的数据列 public String getType(Uri uri)：该方法用于返回当前Uri所代表的数据的MIME类型。如果该Uri对应的数据可能包括多条记录，那么MIME类型字符串应该以vnd.android.cursor.dir/开头；如果该Uri对应的数据只包含一条记录，那么MIME类型字符串应该以vnd.android.item/开头 Uri简介ContentProvider的Uri例如如下：content://org.crazyit.providers.dictprovider/words它可以分为如下三个部分： content://：这个部分是Android的ContentProvider规定的，就像上网的协议默认是http:// org.crazyit.providers.dictprovider：这是ContentProvider的authorities。系统是由这个部分来找到操作哪个ContentProvider的。只要访问指定的ContentProvider，这个部分就是固定的 words：资源量部分（数据部分）。访问不同资源时，这里动态改变。 为了将一个字符串转换成Uri，Uri工具类提供了parse()静态方法。例如，如下代码即可将字符串转换为Uri：Uri uri=uri.parse(&quot;content://org.crazyit.prociders.dictprovider/word&quot;) 使用ContentResolver操作数据Context提供了如下方法来获取ContentResolver对象: getContentResolver() 获取ContentResolver对象后，调用如下方法操作数据 insert(Uri uri,ContentValues values)：向Uri对应的ContentProvider中插入values对应的数据 delete(Uri uri,String where,String[] selectionArgs)：删除Uri对应的ContentProvider中where提交匹配的数据 update(Uri uri,ContentValues values,String where,String[] selectionArgs)：更新Uri对应的ContentProvider中where提交匹配的数据 query(Uri uri,String[] projection,String selection,String[] selectionArgs,String sortOrder)：查询Uri对应的ContentProvider中where提交匹配的数据 开发ContentProviderContentProvider需要与ContentResolver结合学习 ContentProvider与ContentResolver的关系Uri是ContentResolver和ContentProvider进行数据交换的标识。ContentResolver对指定的Uri执行CRUD等数据操作，但Uri并不是真正的数据中心，因为这些CRUD操作会委托给该Uri对应的ContentProvider来实现。通常来说，假如A应用通过ContentResolver执行CRUD操作，这些CRUD操作都需要指定Uri参数，Android系统就根据该Uri找到对应的ContentProvider（该ContentProvider通常属于B应用），ContentProvider则负责实现CRUD方法，完成对底层数据的增删改查等操作，这样就可以让A应用访问、修改B应用的数据了。 上图是ContentResolver、Uri、ContentProvider三者关系。通过这种关系即可实现让A应用访问、使用B应用底层的数据。 开发ContentProvider子类开发ContentProvider步骤： 开发一个ContentProvider子类，该子类需要实现query(),insert(),update()和delete()等方法 在AndroidManifest.xml中注册该ContentProvider，指定android:authorities属性 ContentProvider子类实现的CRUD方法，并不是给该应用本身调用，而是供其他应用来调用。 配置ContentProviderAndroid要求Activity、Service、ContentProvider、BroadcastReceiver都必须进行显式配置. 1234&lt;provider android:name=&quot;.FristProvider&quot; android:authorities=&quot;org.crazyit.providers.firstprovider&quot; android:exported=&quot;true&quot; 从上面的配置可以看出，配置ContentProvider时通常指定如下属性。 name:指定该ContentProvider的实现类的类名 authorities:指定该ContentProvider对应的Uri android:exporter:指定该ContentProvider是否允许其他应用调用。true代表可以被调用。 当其他ContentResolver向该Uri执行CRUD方法时： ContentResolver调用方法时参数将会传给该ContentProvider的CRUD方法 ContentResolver调用方法的返回值，也就是ContentProvider执行CRUD的返回值 使用ContentResolver调用方法Context提供了getContentResolver()方法。这表明Activity、Service等组件都可以通过getContentResolver()方法获取ContentResolver对象。 ContentResolver调用query(),insert(),update(),delete()方法，实际上就是调用uri参数对应的ContentProvider的query(),insert(),update(),delete()方法 创建ContentProvider的说明为了确定该ContentProvider实际能处理的Uri，以及确定每个方法中Uri参数所操作的数据，Android系统提供了UriMatcher工具类。UriMatcher工具类主要提供了如下两个方法： void addURI(String authority,String path,int code)：用于向UriMatcher对象注册Uri。其中authority和path组合成一个Uri，而code则代表该Uri对应的标识码 int match(Uri uri)：根据前面注册的Uri来判断指定的Uri对应的标识码。如果找不到匹配的，该方法返回-1。 除此之外，Android还提供了一个ContentUris工具类，它是一个操作Uri字符串的工具类，提供了如下两个工具方法。 withAppendedId(uri，id)：用于为路径加上ID部分 parseId(uri)：用于从指定Uri中解析出所包含的ID值 在实际项目中，都会通过采用工具类来定义各种常量的方式进行处理。 操作系统的ContentProvider例如联系人信息、系统的多媒体信息。 使用ContentProvider管理联系人Android系统用于管理联系人的ContentProvider的几个Uri如下。 ContactsContract.Contacts.CONTENT_URI：管理联系人 ContactsContract.CommonDataKinds.Phone.CONTENT_URI：管理联系人的电话 ContactsContract.CommonDataKinds.Email.CONTENT_URI：管理联系人的Email]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ContentProvider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（三十三之Android数据存储与IO）]]></title>
    <url>%2F2018%2F08%2F19%2F8.19%2F</url>
    <content type="text"><![CDATA[安卓基础轻量型数据库，不足以用来充当服务器 SQLiteDatabase简介通过SQLiteDatabase对象来管理、操作数据库。SQLiteDatabase提供了如下静态方法来打开一个文件对应的数据库。 static SQLiteDatabase openDatabase(String path,SQLiteDatabase.CursorFactory factory,int flags)：打开path文件所代表的SQLite数据库 static SQLiteDatabase openOrCreateDatabase(File file,SQLiteDatabase.CursorFactory factory)：打开或者创建file文件所代表的SQLite数据库 static SQLiteDatabase openOrCreateDatabase(String path,SQLiteDatabase.CursorFactory factory)：打开或者创建path文件所代表的SQLite数据库 在程序中获取了SQLiteDatabase对象后，调用如下方法来操作数据库： execSQL(String sql,Object[] bindArgs)：执行带占位符的sql语句 execSQL(String sql)：执行sql语句 insert(String table,String nullColumnHack,ContentValues values)：向指定表中插入数据 update(String table,ContentValues values,String whereClause,String[] whereArgs)：更新指定表中的特定数据 delete(String table,String whereClause,String[] whereArgs)：删除指定表中的特定数据 Cursor query(String tabel,String[] columns,String whereClause,String[] whereArgs,String groupBy,String having,String orderBy)：对指定数据表执行查询 Cursor query(String tabel,String[] columns,String whereClause,String[] whereArgs,String groupBy,String having,String orderBy,String limit)：对指定数据表执行查询。limit参数控制最多查询几条记录（用于控制分页的参数） Cursor query(boolean distinct,String tabel,String[] columns,String whereClause,String[] whereArgs,String groupBy,String having,String orderBy,String limit)：对指定数据表执行查询；第一个参数是控制是否除去重复值 rawQuery(String sql,String[] selectionArgs)：执行带占位符的sql查询 beginTransaction()：开始事务 endTransaction()：结束事务 PS：whereArgs用于为wherClause自居传入参数。whereClause是执行数据库方法需要满足的条件 上面的查询方法都返回一个Cursor对象，类似JDBC中的Resultset，Cursor提供了如下方法来移动查询结果的记录指针。 move(int offset)：将记录指针向上（正数）或向下移动指定行数 boolean moveToFirst()：将记录指定移动到第一行 boolean moveToLast()：移动到最后 boolean moveToNext()：移动到下一行 boolean moveToPosition(int position)：将记录指针移动到指定行 boolean moveToPrevious()：移动到上一行 用SQLiteDatabase进行数据库操作的步骤：1.获取SQLiteDatabase对象，它代表了与数据库的连接。2.调用SQLiteDatabase的方法执行SQL语句。3.操作SQL语句的执行结果，比如用SimpleCursorAdapter封装Cursor4.关闭SQLiteDatabase，回收资源。 SQLiteOpenHelper类在实际项目中更常用SQLiteOpenHelper开发子类，并通过子类的getReadableDatabase(),getWritableDatabase()方法打开数据库。 SQLiteOpenHelper包含如下常用的方法： synchronized SQLiteDatabase getReadableDatabase():以读写的方式打开数据库对应的SQLiteDatabase对象 synchronized SQLiteDatabase getWritableDatabase():以写的方式打开数据库对应的SQLiteDatabase对象 abstract void onCreate(SQLiteDatabase db):第一次创建数据库回调该方法 abstract void onUpgrade(SQLiteDatabase db,int oldVersion,int newVersion):当数据库版本更新回调该方法 synchronized void close():关闭所有打开的SQLiteDatabase对象 重写抽象方法： onCreate(SQLiteDatabase db):生成数据库表结构 onUpgrade(SQLiteDatabase db,int oldVersion,int new Version):当用户创建SQLiteOpenHelper对象时，必须指定一个version参数，该参数就是所使用的数据库版本。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>SQLite数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（三十二之Android数据存储与IO）]]></title>
    <url>%2F2018%2F08%2F18%2F8.18.2%2F</url>
    <content type="text"><![CDATA[安卓基础使用SharedPreferences应用程序少量的数据保存，这些数据的格式很简单，都是很普通的字符串、标量类型的值等，对于这种数据，Android提供了SharedPreferences进行保存 SharedPreferences与Editor简介SharedPreferences保存的数据主要是简单类型的key-value对。SharedPreferences接口主要负责读取应用程序的Preferences数据，它提供了如下方法： boolean contains(String key)：判断SharedPreferences是否包含特定key的数据 abstract Map&lt;String,?&gt; getAll()：获取SharedPreferences数据里全部的key-value对 boolean getXxx(String key,xxx defValue)：获取SharedPreferences数据里指定key对应的value。如果key不存在，返回默认值defValue。其中xxx可以是boolean、float、int、long、String等各种基本类型的值。 通过SharedPreferences的内部接口，SharedPreferences调用edit()方法即可获取它所对应的Editor对象。Editor提供了如下方法向SharedPreferences写入数据。 SharedPreferences.Editor clear()：清空SharedPreferences中所有数据 SharedPreferences.Editor putXxx(String key,xxx value)：向SharedPreferences存入指定key对应的数据 SharedPreferences.Editor remove(String key)：删除SharedPreferences里指定key对应的数据项 boolean commit()：当Editor编辑完成后，调用该方法提交修改 程序无法直接创建SharedPreferences实例，只能通过Context提供的getSharedPreferences(String name,int mode)方法获取SharedPreferences实例（SharedPreferences是一个接口） File存储Android支持用FileInputStream、FileOutputStream这些IO流访问手机存储器上的文件。 ### openFileOutput和openFileInput Context提供热如下两个方法打开应用程序的数据文件夹里的文件IO流。 FileInputStream openFileInput(String name)：打开应用程序的数据文件夹下的name文件对应的输入流 FileOutputStream openFileOutput(String name,int mode)：打开应用程序的数据文件夹下的name文件对应的输出流 读写SD卡上的文件步骤： 调用Environment的getExternalStorageState()方法判断是否插入内存卡Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)如果返回true即是插入了SD卡 调用getExternalStorageDirectory()方法来获取外部存储器 使用FileInputStream,FileOutputStream,FileReader,FileWriter读写SD卡里的文件 必须插入SD卡，模拟器需要创建通过mskdcard 在AndroidManifest.xml中添加读写SD卡的权限，创建与删除文件权限：&lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;写入数据权限uses-premission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; ps：File.getCanonicalPath（）方法用来获取文件（文件夹）路径；使用时需要进行try/catch抛出IOException异常]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>使用SharedPreferences</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（三十一之Android应用的资源）]]></title>
    <url>%2F2018%2F08%2F18%2F8.18%2F</url>
    <content type="text"><![CDATA[安卓基础属性动画资源（Property Animation)它只是一个抽象类，通常使用它的子类：AnimatorSet、ValueAnimator、ObjectAnimator、TimeAnimator。定义属性动画的XML资源文件用以下三个元素中的任意一个作为根元素。 &lt;set../&gt;：它是父元素，可以用于包含这三种元素作为子元素 &lt;objectAnimator…/&gt;：用于定义ObjectAnimator动画 &lt;animator…/&gt;：用于定义ValueAnimator动画 ObjectAnimator colorAnim = (ObjectAnimator) AnimatorInflater.loadAnimator(MainActivity.this,R.animator.color_anima使用AnimatorInflater工具类加载了指定动画资源文件，并将该动画资源文件转化为ObjectAnimator对象。 使用原始XML资源Android应用推荐用XML文件保存一些初始化的配置信息、应用相关的数据资源。这种资源就叫原始XML资源。 定义原始XML资源原始XML资源一般保存在/res/xml/路径下，需要开发者手动创建xml子目录。为了在Java代码中获取实际的XML文档，可以通过Resource的如下两个方法实现： XmlResourceParser getXml(int id)：获取XML文档，并使用一个XmlPullParser来解析该XML文档，该方法返回一个解析器对象。（XmlResourceParser是XmlPullParser的子类） InputStream openRawResource(int id)：获取XML文档对应的输入流 使用原始XML文件使用布局（Layout）资源使用菜单（Menu）资源样式（Style）和主题（Theme）资源样式资源Android的样式资源文件在/res/values/目录下，根元素是&lt;resources…/&gt;元素，该元素内可包含多个&lt;style../&gt;子元素，每个&lt;style…/&gt;子元素定义一个样式。 &lt;style../&gt;元素内可包含多个&lt;item../&gt;子元素，每个&lt;item../&gt;子元素定义一个格式项。 主题资源它的XML文件也通常放在/res/values/目录下，主题资源的XML文件同样以&lt;resources…/&gt;元素作为根元素，同样使用&lt;style../&gt;元素来定义主题。主题与样式的区别主要体现在： 主题不能作用于单个的View组件，主体应该对整个应用中的所有Activity起作用，或对指定的Activity起作用 主题定义的格式应该是改变窗口外观的格式，例如窗口标题，窗口边框等 如果想让应用中全部窗口使用该主题，那么只要在AndroidManifest.xml文件中&lt;application../&gt;元素加android:theme属性即可。如果只想让程序中的某个Activity拥有这个主题，那么可以修改&lt;activity…/&gt;元素，同样通过android:theme指定主题即可。 Android提供的几种内置的主题资源，同样支持继承。 属性(Attribute)资源它的XML文件也通常放在/res/values/目录下，主题资源的XML文件同样以&lt;resources…/&gt;元素作为根元素，该元素包含如下两个子元素： attr子元素：定义一个属性 declare-styleable子元素：定义一个styleable对象，每个styleable对象就是一组attr属性的集合 使用原始资源Android的原始资源可以放在如下两个地方： 位于/res/raw/目录下，Android SDK会处理该目录下的原始资源，Android SDK会在R清单类中为该目录下的资源生成一个索引项 位于/assets/目录下，该目录下的资源是一个更彻底的原始资源。Android应用通过AssetManager来管理该目录下的原始资源 AssetManager是一个专门管理/assets/目录下原始资源的管理器类，AssetManager提供了如下两个常用方法来访问Assets资源。 InputStream open(String fileName)：根据文件名来获取原始资源对应的输入流 AssetFileDescriptor openFd(String fileName)：根据文件名来获取原始资源对应的AssetFileDesciptor。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>应用资源概述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（三十之Android应用的资源）]]></title>
    <url>%2F2018%2F08%2F17%2F8.17%2F</url>
    <content type="text"><![CDATA[安卓基础数组资源(Array)Andriod采用位于/res/values目录下的arrays.xml文件来定义数组资源，定义数组也是用&lt;resources…/&gt;，该元素可包含如下三种子元素： &lt;array…/&gt;：普通类型的数组 &lt;string-array…/&gt;：字符串数组 &lt;integer-array…/&gt;：整型数组 图片资源为了在程序中获得实际的Drawable对象，Resources提供了Drawable getDrawable(int id)方法，该方法根据Drawable资源在R资源清单中的ID来获取实际的Drawable对象 StateListDrawable资源StateListDrawable可以包含多个Drawable对象，主要用来根据组件状态变化，展现Drawable变化 StateListDrawable对象的XML文件的根元素为&lt;selector…/&gt;，该元素可以包含多个&lt;item…/&gt;元素，该元素有如下属性： android:color,android:drawable android:state-xxx：指定一个特定状态，如：active,checkable可勾选,checked已选择,enabled,first开始状态,focused已得到焦点,last结束状态,middle中间状态,pressed,selected已被选中状态,window_focused LayerDrawable资源也可以包含一个Drawable数组，系统按索引最大的Drawable对象绘制在最上面。LayerDrawable对象的XML文件的根元素为&lt;layer-list…/&gt; 可以利用这个资源来绘制拖动条，将索引大的覆盖索引小的。 ShapeDrawable资源用来定义一个基本的几何图形。定义ShapeDrawable的XML文件的根元素是&lt;shape…/&gt;元素，该元素可以指定如下属性： android:shape=[“rectangle”|”oval”|”line”|”ring”]：指定哪种类型的几何图形 ClipDrawable资源代表从其他位图上截取的一个“图片片段”。在XML文件中定义ClipDrawable对象使用&lt;clip…/&gt;元素。 可指定如下三个属性： android:drawable：指定截取的源Drawable对象 android:clipOrientation：指定截取方向，可设置水平截取或垂直截取 android:gravity：指定截取时的对齐方式 使用ClipDrawable对象时，调用setLevel(int level)方法来设置截取的区域大小，当Level为0时，截取的图片片段为空；当level为10000时，截取整个图片。 AnimationDrawable资源它代表一个动画，有逐帧动画和补间动画。定义补间动画的XML资源文件以&lt;set…/&gt;元素作为根元素，该元素可以指定如下4个元素： alpha：设置透明度的改变 scale：设置图片进行缩放变化 translate：设置图片进行位移变化 rotate：设置图片进行旋转 定义动画的XML文件放在/res/anmi/路径下，需要开发者自行创建 定义补间动画的思路：先设置一张图片的开始状态，并设置该图片的结束状态，再设置动画的持续时间。 AnimationDrawable对象的元素都可以指定一个android:interpolator属性，该属性指定动画的变化速度，如： linear_interpolator：匀速变化 accelerate_interpolator：加速变化 decelerate_interpolator：减速变化 如果程序想让&lt;set…/&gt;元素下所有的变化效果使用相同的动画速度，则可指定android：shareInterpolator=”true” 为了在Java代码中获取实际的Animation对象，可调用AnimationUtils的方法：loadAnimation(Context ctx,int resId)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>应用资源概述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（三十之Android应用的资源）]]></title>
    <url>%2F2018%2F08%2F16%2F8.16.2%2F</url>
    <content type="text"><![CDATA[安卓基础## 应用资源概述 安卓应用资源分为两类 无法通过R资源清单访问的原生资源，保存在assets目录下 可通过R资源清单访问的资源，保存在res目录下 资源的类型及存储方式使用资源 在Java代码中使用资源清单项 在Java代码中访问实际资源 通过资源清单项获取实际资源 getXxx(int id)：根据资源清单ID来获取实际资源 getAssets() ：获取访问/assets/目录下资源的AssetManager对象 在XML文件中使用资源 字符串、颜色、尺寸资源字符串资源、颜色资源、尺寸资源，它们对应的XML文件都将位于/res/values/目录下 颜色值的定义Android颜色值支持常见的4种形式 #RGB #ARGB #RRGGBB #AARRGGBB 上面4种形式中，A、R、G、B都代表一个十六进制的数 定义字符串、颜色、尺寸资源文件]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>应用资源概述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（二十九之使用Intent和IntentFilter进行通信）]]></title>
    <url>%2F2018%2F08%2F15%2F8.16%2F</url>
    <content type="text"><![CDATA[安卓基础Intent对象简述使用Intent启动不同组件的方法： 组件类型 启动方法 Activity startActivity(Intent intent) startActivityForResult(Intent intent,int requestCode) Service ComponentName startService(Intent service) boolean bindService(Intent service,ServiceConnection conn,int flags) BroadcastReceiver sendBroadcast(Intent intent) sendBroadcast(Intent intent,String receiverPermission) sendOrderedBroadcast(Intent intent,String receiverPermission,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras) sendOrderedBroadcast(Intent intent,String receiverPermission) BroadcastReceiver sendStickyBroadcast(Intent intent) sendStickyOrderedBroadcast(Intent intent,BroadcastReceiver resultReceiver,Handler scheduler,int initialCode,String initialData,Bundle initialExtras) Intent对象大致包含Component、Action、Category、Data、Type、Extra、Flag这7种属性，其中Component用于明确指定需要启动的目标组件，而Extra则用于“携带”需要交换的数据 Intent的属性及Intent-filter配置启动组件，取决于Intent的各属性 Component属性指定了Component属性的Intent是显式Intent，没有指定的是隐式Intent——隐式Intent没有指出明确的对象，只要是符合筛选条件就行。 Intent的Component属性需要接受一个ComponentName对象。 当程序通过Intent的Component属性（明确指定了启动哪个组件）启动特定组件时，被启动组件几乎不需要使用&lt;intent_filter…/&gt;元素进行配置 Action、Category属性与intent-filter配置&lt;intent-filter…/&gt;元素是AndroidManifest.xml文件中&lt;activity…/&gt;元素的子元素，&lt;activity…/&gt;元素用于为应用程序配置Activity，&lt;activity../&gt;的&lt;intent-filter…/&gt;子元素则用于配置该Activity所能“响应”的Intent。 当&lt;activity../&gt;元素的&lt;intent-filter…/&gt;子元素里包含多个&lt;action../&gt;子元素时，就表明该Activity能响应Action属性值为其中任意一个字符串的Intent。 一个Intent对象最多只能包含一个Action属性，程序调用Intent的setAction(String str)方法设置Action属性值；一个Intent对象可以包括多个Category属性，程序调用Intent的addCategory(String str)方法来为Intent添加Category属性。 Activity到底启动哪个Activity，需要看&lt;intent-filter…/&gt;中元素的配置。（可以想成启动符合条件的Activity） 指定Action、Category调用ActivityIntent不仅可以启动本应用程序内程序组件，也可以启动Android系统的其他应用的程序组件。 Data、Type属性与intent-filter配置Data属性通常用于向Action属性提供操作的数据。Type属性用于指定该Data属性所指定Uri对应的MIME的类型。 Data属性与Type属性会相互覆盖： Intent先设置Data属性，那么Type属性将会覆盖Data属性 Intent先设置Type属性，那么Data属性将会覆盖Type属性 如果希望Intent有两种属性，调用Intent的setDataAndType()方法 在AndroidManifest.xml中为组件声明Data、Type属性都通过&lt;data../&gt;元素 使用Intent创建Tab页使用TabActivity创建Activity布局，添加Tab页使用了TabHost.TabSpec提供的如下方法： setContent(int viewId)：直接将指定View组件设置成Tab页的Content setContent(Intent intent)：直接将指定Intent对应的Activity设置成Tab页的Content]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Intent对象简述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（二十八之Activity的生命周期与加载模式）]]></title>
    <url>%2F2018%2F08%2F15%2F8.15.2%2F</url>
    <content type="text"><![CDATA[安卓基础Activity在Android应用中，以Activity栈形式管理，当前运行的Activity位于栈顶。随着不同应用的运行，每个Activity都有可能从活动状态转变为非活动状态，也可能从非活动状态转为活动状态。 Activity的生命周期Activity大致会经历下面4种状态： 运行状态：当前Activity位于前台，用户可见，可以获得焦点 暂停状态：其他Activity位于前台，该Activity依然可见，只是不能获得焦点 停止状态：该Activity不可见，失去焦点 销毁状态：该Activity结束，或Activity所在的进程被结束 Activity与Servlet的相似性和区别相似性： Activity,Servlet的职责都是向用户呈现界面 开发者开发Activity和Servlet都继承系统的基类 Activity、Servlet开发出来都需要配置 Activity开发用于Android、Servlet用于Web 开发者无须创建Activity和Servlet的实例，无须调用它们的方法。它们的方法都由系统以回调的方式来调用 Activity、Servlet都有各自的生命周期，他们的生命周期都由外部负责管理 Activity、Servlet都不会直接相互调用，因此都不能直接进行数据交换。Servlet的数据交换需要借助于Web应用提供的requestScope、sessionScope等。Activity之间的数据交换借助于Bundle。 差别： Activity是Android窗口的容器，因此Activity最终以窗口形式显示出来。而Servlet并不会生成应用界面，只是向浏览者生成文本响应 Activity运行于Android应用中，因此Activity的本质还是通过各种界面组件来搭建界面；而Servlet则主要以IO流向浏览者生成文本响应，浏览者看到的界面其实是由浏览器负责生成的 Activity之间的跳转主要通过Intent对象来控制；而Servlet之间的跳转主要由用户的请求来控制 ## Fragment 把Fragment理解成Activity片段。Fragment拥有自己的生命周期，也可以接受它自己的输入事件 Fragment概述Fragment必须被“嵌入”Activity中使用，因此，虽然Fragment也拥有自己的生命周期，但Fragment的生命周期会受它所在的Activity的生命周期控制。例如：当Activity暂停时，在Activity中的Fragment都会被暂停；当Activity被销毁时，在Activity中的Fragment都会被销毁。只有当该Activity处于活动状态时，程序员才可以通过方法独立地操作Fragment。 Fragment有如下特征: Fragment总是作为Activity界面的组成部分。Fragment调用getActivity（）方法获取它所在的Activity，Activity调用FragmentManager的findFragmentById（）或findFragmentByTag（）方法获取Fragment 在Activity运行过程中，可调用FragmentManager的add（）、remove（）、replace（）方法动态地添加、删除或者替换Fragment 一个Activity可以同时组合多个Fragment，一个Fragment也可以被多个Activity复用 Fragment可以响应自己的输入事件，并拥有自己的生命周期，但他们的生命周期直接被其所属的Activity的生命周期控制 创建Fragment需要实现如下三个方法： onCreate（）：系统创建Fragment对象后回调该方法，在实现代码中只初始化想要在Fragment中保持的必要组件，当Fragment被暂停或停止后可以恢复 onCreateView（）：当Fragment绘制界面组件时会回调该方法。该方法必须返回一个View，该View也就是该Fragment所显示的View onPause（）：当用户离开该Fragment时将会回调该方法 Fragment的生命周期与Activity类似，Fragment的生命周期也存在与Activity一样的4个状态。 Fragment与Activity对比生命周期：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Activity的生命周期</tag>
        <tag>Activity与Servlet</tag>
        <tag>Fragment概述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（二十七）]]></title>
    <url>%2F2018%2F08%2F15%2F8.15%2F</url>
    <content type="text"><![CDATA[安卓基础启动、关闭ActivityActivity启动其他Activity有两种方法： startActivity(Intent intent)：启动其他的Activity startActivityForResult(Intent intent,int requestCode)：以指定的请求码（requestCode）启动Activity，而且程序将会获取新启动的Activity返回的结果（通过重写onActivityResult(..)方法来获取） 一个Activity通过Intent来表达自己“意图”——想要启动哪个组件，被启动的组件既可以是Activity组件，也可以是Service组件。 Android关闭Activity准备了如下两种方法： finish()：结束当前Activity finishActivity(int requestCode)：结束以startActivityForResult(Intent intent,int requestCode)方法启动的Activity ps：finish()方法是将Activity移出栈，onDestroy()方法是销毁Activity。 使用Bundle在Activity之间交换数据当一个Activity启动另一个Activity时，需要传一些数据进去，这就像Servlet跳转另一个Servlet时，习惯把需要交换的数据放入requestScope、sessionScope中。对于Activity之间交换数据，我们主要将需要交换的数据放入Intent中即可。Intent提供了多个重载的方法来“携带”额外的数据： putExtras(Bundle data)：向Intent中放入需要“携带”的数据包 Bundle getExtras()：取出Intent中所“携带”的数据包 putExtra(String name,Xxx value)：向Intent中按Key-value对的形式存入数据 getXxxExtra(String name)：从Intent中按Key取出指定类型的数据 上面方法中Bundle就是一个简单的数据携带包，该Bundle对象包含了多个方法来存入数据。 putXxx(String key,Xxx data)：向Bundle中放入Int、Long等各种类型的数据 putSerializable(String key,Serializable data)：向Bundle中放入一个可序列化的对象。 为了取出Bundle数据携带包里的数据，Bundle提供了如下方法： getXxx(String key)：从Bundle中取出Int、Long等各种类型的数据。 getSerializable(String key,Serializable data)：从Bundle中取出一个可序列化的对象。 ps： @Override public void onCreate(Bundle savedInstanceState, PersistableBundle persistentState) { super.onCreate(savedInstanceState, persistentState); } 与 @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); } 有两个参数的方法不能关联到Layout界面。既不能显示布局，也不能完成Intent跳转。 启动其他Activity并返回结果这种请求用于：应用程序的第一个界面需要用户进行选择——但需要选择的列表数据比较复杂，必须启动另一个Activity让用户选择。当用户在第二个Activity中选择完成后，程序返回第一个Activity，第一个Activity必须能显示用户在第二个Activity中选择的结果。在这种场景下，也是用Bundle进行数据交换的。 为了获取被启动的Activity所返回的结果： 当前Activity需要重写onActivityResult(int requestCode,int resultCode,Intent intent)，而被启动的Activity返回结果时，该方法触发，其中requestCode和resultCode分别是请求码和结果码 被启动的Activity需要调用setResult()方法设置处理结果 Activity的回调机制在开发通用性质的应用框架时，程序架构完成整个应用的通用功能、流程，但在某个特定的点上，需要一段业务相关的代码——通用的程序架构无法实现这段代码，那么程序架构会在这个点上留一个“空”。对于Java程序来说，程序架构在某个点上留下的“空”，可以以如下两种方式存在。 以接口形式存在 以抽象方法（非抽象的方法）的形式存在：这就是Activity的实现方式。开发者直接重写已经被定义的方法，通用的程序架构就会回调该方法来完成业务相关的处理]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>启动、关闭Activity</tag>
        <tag>使用Bundle在Activity之间交换数据</tag>
        <tag>启动其他Activity并返回结果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（二十六之深入理解Activity与Fragment）]]></title>
    <url>%2F2018%2F08%2F14%2F8.14.2%2F</url>
    <content type="text"><![CDATA[安卓基础Activity是Android应用中最重要的组成单元之一(其他三个是Service、BroadcastReceiver和ContentProvider)，而Activity是Android应用最常见的组件之一。在实际应用中，往往包括多个Activity，不同的Activity向用户呈现了不同的操作界面。Android应用的多个Activity组成Activity栈，当前活动的Activity位于栈顶。实际上Activity对于Android应用的作用有点类似于Servlet对于Web应用的作用——一个Web应用通常需要N个Servlet组成（JSP的本质依然是Servlet）；那么一个Android应用通常也需要N个Activity组成。对于Web应用而言，Servlet（把JSP也统一成Servlet）主要负责与用户交互，并向用户呈现应用状态；对于Android应用而言，Activity大致也具有相同的功能。 建立、配置和使用ActivityActivity与开发Servlet类似，开发Activity也需要继承Activity基类。有时也要继承Activity的子类。创建一个Activity也需要实现一个或多个方法，其中最常见的就是实现onCreate（Bundle status）方法，该方法会在Activity被创建时被回调；setContentView（View view）方法来显示要展示的View；findViewById（int id）方法来获取程序界面中的组件。 实例：用LauncherActivity开发启动Activity的列表ListActivity是用来界面中只显示一个列表，LauncherActivity继承了ListActivity，它开发出来的列表界面与普通列表界面有所不同。它开发出来的列表界面中的每个列表项都对应于一个Intent，因此当用户单击不同的列表项时，应用程序会自动启动对应的Activity。使用LauncherActivity时，需要为它设置Adapter——ArrayAdapter、SimpleAdapter、BaseAdapter。与使用普通的ListActivity不同的是，继承LauncherActivity时通常应该重写Intent intentForPosition(int position)方法，该方法根据不同列表项返回不同的Intent（用于启动不同的Activity）。 123456789101112131415161718192021222324252627package com.example.otheractivity;import androidx.appcompat.app.AppCompatActivity;import android.app.LauncherActivity;import android.content.Intent;import android.os.Bundle;import android.widget.ArrayAdapter;public class MainActivity extends LauncherActivity &#123; //定义两个Activity的名称 String[] names = &#123;&quot;设置程序参数&quot;,&quot;查看英雄&quot;&#125;; //定义两个Activity的实现类 Class&lt;?&gt;[] clazzs = &#123;PreferenceActivityTest.class,ExpandableListActivityTest.class&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_expandable_list_item_1,names); //设置窗口显示的列表所需的Adapter setListAdapter(adapter); &#125; //根据列表项返回指定Activity对应的Intent @Override protected Intent intentForPosition(int position) &#123; return new Intent(MainActivity.this,clazzs[position]); &#125;&#125; 实例：使用ExpandableListActivity实现可扩展开的Activity为继承自ExpandableListActivity的Activity传入一个ExpandableListAdapter对象，ExpandableListActivity将会生成一个显示可扩展开列表的窗口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.example.otheractivity;import android.app.ExpandableListActivity;import android.os.Bundle;import android.os.PersistableBundle;import android.view.Gravity;import android.view.View;import android.view.ViewGroup;import android.widget.AbsListView;import android.widget.BaseExpandableListAdapter;import android.widget.ExpandableListAdapter;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.TextView;public class ExpandableListActivityTest extends ExpandableListActivity &#123; @Override public void onCreate(Bundle savedInstanceState, PersistableBundle persistentState) &#123; super.onCreate(savedInstanceState, persistentState); ExpandableListAdapter adapter = new BaseExpandableListAdapter() &#123; int[] logos = new int[]&#123;R.drawable.adc,R.drawable.ap,R.drawable.top&#125;; private String[] armTypes = new String[]&#123;&quot;薇恩&quot;,&quot;泽拉斯&quot;,&quot;菲奥娜&quot;&#125;; private String[][] armSkins =new String[][]&#123;&#123;&quot;原画&quot;,&quot;猎天使魔女&quot;,&quot;苍穹之光&quot;,&quot;摄魂猎手&quot;&#125;, &#123;&quot;原画&quot;,&quot;圣金巫灵&quot;&#125;, &#123;&quot;原画&quot;,&quot;夜鸦&quot;,&quot;皇家守卫&quot;,&quot;女校长&quot;,&quot;泳池派对&quot;&#125;&#125;; @Override public int getGroupCount() &#123; return armTypes.length; &#125; @Override public int getChildrenCount(int i) &#123; return armSkins[i].length; &#125; //获取指定组位置处的组数据 @Override public Object getGroup(int i) &#123; return armTypes[i]; &#125; //获取指定组位置、指定子列表项处的子列表项数据 @Override public Object getChild(int i, int i1) &#123; return armSkins[i][i1]; &#125; @Override public long getGroupId(int i) &#123; return i; &#125; @Override public long getChildId(int i, int i1) &#123; return i1; &#125; @Override public boolean hasStableIds() &#123; return true; &#125; //该方法决定每个组选项的外观 @Override public View getGroupView(int i, boolean b, View view, ViewGroup viewGroup) &#123; LinearLayout ll = new LinearLayout(ExpandableListActivityTest.this); ll.setOrientation(LinearLayout.HORIZONTAL); ImageView logo = new ImageView(ExpandableListActivityTest.this); logo.setImageResource(logos[i]); ll.addView(logo); TextView textView = getTextView(); textView.setText(getGroup(i).toString()); ll.addView(textView); return ll; &#125; //该方法决定每个子选项的外观 @Override public View getChildView(int i, int i1, boolean b, View view, ViewGroup viewGroup) &#123; TextView textView = getTextView(); textView.setText(getChild(i,i1).toString()); return textView; &#125; @Override public boolean isChildSelectable(int i, int i1) &#123; return true; &#125; private TextView getTextView()&#123; AbsListView.LayoutParams lp = new AbsListView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,64); TextView textView = new TextView(ExpandableListActivityTest.this); textView.setLayoutParams(lp); textView.setGravity(Gravity.CENTER_VERTICAL|Gravity.LEFT); textView.setPadding(36,0,0,0); return textView; &#125; &#125;; //设置该窗口显示列表 setListAdapter(adapter); &#125;&#125; 实例：PreferenceActivity结合PreferenceFragment实现参数设置界面当我们开发一个Android应用程序时，不可避免地需要进行选项设置，这些选项设置会以参数的形式保存，习惯上我们会用Preference进行保存。一旦Activity继承了PreferenceActivity，那么该Activity完全不需要自己控制Preferences的读写，PreferenceActivity会为我们处理一切。PreferenceActivity与普通Activity不同，它不再使用普通的界面布局文件，而是使用选项设置的布局文件。选项设置的布局文件以PreferenceScreen作为根元素——它表明定义一个参数设置的界面布局。Android不再推荐直接让PreferenceActivity加载选项设置的布局文件，而是建议将PreferenceActivity与PreferenceFragment结合使用，其中PreferenceActivity只负责加载选项设置列表的布局文件，PreferenceFragment才负责加载选项设置的布局文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.example.otheractivity;import android.os.Bundle;import android.os.PersistableBundle;import android.preference.PreferenceActivity;import android.preference.PreferenceFragment;import android.widget.Button;import android.widget.Toast;import java.util.List;public class PreferenceActivityTest extends PreferenceActivity &#123; @Override public void onCreate(Bundle savedInstanceState, PersistableBundle persistentState) &#123; super.onCreate(savedInstanceState, persistentState); //该方法应用于为该界面设置一个标题按钮 if (hasHeaders())&#123; Button button = new Button(this); button.setText(&quot;设置操作&quot;); //将按钮添加到该界面上 setListFooter(button); &#125; &#125; //重写该方法，负责加载界面布局文件 @Override public void onBuildHeaders(List&lt;Header&gt; target) &#123; //加载选项设置列表的布局文件 loadHeadersFromResource(R.xml.preference_headers,target); &#125; //重写该方法，验证各PreferenceFragment是否有效 @Override protected boolean isValidFragment(String fragmentName) &#123; return true; &#125; public static class Prefs1Fragment extends PreferenceFragment&#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); addPreferencesFromResource(R.xml.preferences); &#125; &#125; public static class Prefs2Fragment extends PreferenceFragment&#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); addPreferencesFromResource(R.xml.display_prefs); //获取传入该Fragment的参数 String website = getArguments().getString(&quot;website&quot;); Toast.makeText(getActivity(),&quot;网站域名是：&quot;+website,Toast.LENGTH_LONG).show(); &#125; &#125;&#125; preference_headers.xml源码 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;preference-headers xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;header android:fragment=&quot;com.example.otheractivity.PreferenceActivityTest$Prefs1Fragment&quot; android:title=&quot;程序选项设置&quot; android:summary=&quot;设置应用相关选项&quot;/&gt; &lt;header android:fragment=&quot;com.example.otheractivity.PreferenceActivityTest$Prefs2Fragment&quot; android:title=&quot;界面选项设置&quot; android:summary=&quot;设置显示界面的相关选项&quot;&gt; &lt;extra android:name=&quot;website&quot; android:value=&quot;www.crazyit.org&quot;/&gt; &lt;/header&gt; &lt;header android:title=&quot;使用Intent&quot; android:summary=&quot;使用Intent启动某个Activity&quot;&gt; &lt;intent android:action=&quot;android.intent.action.VIEW&quot; android:data=&quot;http://www.crazyit.org&quot;/&gt; &lt;/header&gt;&lt;/preference-headers&gt; preferences.xml源码 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;PreferenceScreen xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;RingtonePreference android:ringtoneType=&quot;all&quot; android:title=&quot;设置铃声&quot; android:summary=&quot;选择铃声（测试RingtonePreference）&quot; android:showDefault=&quot;true&quot; android:key=&quot;ring_key&quot; android:showSilent=&quot;true&quot;&gt; &lt;/RingtonePreference&gt; &lt;PreferenceCategory android:title=&quot;个人信息设置组&quot;&gt; &lt;EditTextPreference android:key=&quot;name&quot; android:title=&quot;填写用户名&quot; android:summary=&quot;填写您的用户名（测试EditTextPreference）&quot; android:dialogTitle=&quot;您所使用的用户名为：&quot;/&gt; &lt;ListPreference android:key=&quot;gender&quot; android:title=&quot;性别&quot; android:summary=&quot;选择您的性别（测试ListPreference）&quot; android:dialogTitle=&quot;ListPreference&quot; android:entries=&quot;@array/gender_name_list&quot; android:entryValues=&quot;@array/gender_value_list&quot;/&gt; &lt;/PreferenceCategory&gt; &lt;PreferenceCategory android:title=&quot;系统功能设置组&quot;&gt; &lt;CheckBoxPreference android:key=&quot;autoSave&quot; android:summaryOn=&quot;自动保存：开启&quot; android:summaryOff=&quot;自动保存：关闭&quot; android:defaultValue=&quot;true&quot;/&gt; &lt;/PreferenceCategory&gt;&lt;/PreferenceScreen&gt; display_prefs.xml源码 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;PreferenceScreen xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;PreferenceCategory android:title=&quot;背景灯光组&quot;&gt; &lt;ListPreference android:key=&quot;light&quot; android:title=&quot;灯光强度&quot; android:summary=&quot;请选择灯光强度（测试ListPreference）&quot; android:dialogTitle=&quot;请选择灯光强度&quot; android:entryValues=&quot;@array/light_value_list&quot; android:entries=&quot;@array/light_strength_list&quot;/&gt; &lt;/PreferenceCategory&gt; &lt;PreferenceCategory android:title=&quot;文字显示组&quot;&gt; &lt;SwitchPreference android:key=&quot;autoScroll&quot; android:title=&quot;自动滚屏&quot; android:summaryOn=&quot;自动滚屏：开&quot; android:summaryOff=&quot;自动滚屏：关&quot; android:defaultValue=&quot;true&quot;/&gt; &lt;/PreferenceCategory&gt;&lt;/PreferenceScreen&gt; arrays.xml源码 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;string-array name=&quot;gender_name_list&quot;&gt; &lt;item&gt;男&lt;/item&gt; &lt;item&gt;女&lt;/item&gt; &lt;/string-array&gt; &lt;string-array name=&quot;gender_value_list&quot;&gt; &lt;item&gt;男&lt;/item&gt; &lt;item&gt;女&lt;/item&gt; &lt;/string-array&gt; &lt;string-array name=&quot;light_value_list&quot; &gt; &lt;item&gt;50&lt;/item&gt; &lt;item&gt;100&lt;/item&gt; &lt;item&gt;150&lt;/item&gt; &lt;/string-array&gt; &lt;string-array name=&quot;light_strength_list&quot; &gt; &lt;item&gt;50&lt;/item&gt; &lt;item&gt;100&lt;/item&gt; &lt;item&gt;150&lt;/item&gt; &lt;/string-array&gt;&lt;/resources&gt; 其他当在AndroidManifest.xml中配置Activity时，若使用&lt;activity name=””未出现新建的Activity，则观察是否给Activity加了Public class。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>建立、配置和使用Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（二十五之Android的事件处理）]]></title>
    <url>%2F2018%2F08%2F14%2F8.14%2F</url>
    <content type="text"><![CDATA[安卓基础其他实际上不推荐将业务逻辑实现写在事件监听器中，包含业务逻辑的事件监听器将导致程序的显示逻辑和业务逻辑耦合，从而增加程序后期的维护难度。如果确实有多个事件监听器需要实现相同的业务逻辑功能，则可以考虑使用业务逻辑组件来定义逻辑功能，再让事件监听器来调用业务逻辑组件的业务逻辑方法。 Activity本身作为事件监听器类可以直接在Activity类中定义事件处理器的方法。这种形式非常简洁，但这种做法有两个缺点： 造成程序结构的混乱，Activity的主要职责应该是完成界面初始化工作，但此时还需要包含事件处理器方法，从而引起混乱。 如果Activity界面类需要实现监听器接口，让人感觉比较怪异。 匿名内部类作为事件监听器大部分事件监听器只是临时使用一次，所以使用匿名内部类最为合适。 直接绑定到标签对于很多Android界面组件标签而言，他们都支持onClick属性，该属性的属性值就是一个形如xxx（View source）方法的方法名。 基于回调的事件处理从模型来看，基于回调的事件处理模型更加简单 回调机制和监听机制对于基于监听的事件处理模型来说，事件源和事件监听器是分离的，当事件源上发生特定事件时，该事件交给事件监听器负责处理；对于基于回调的事件处理模型来说，事件源和事件监听器是统一的，当事件源发生特定事件时，该事件还是由事件源本身负责处理。 基于回调的事件传播几乎所有基于回调的事件处理方法都有一个boolean类型的返回值，该返回值用于标识该方法是否能完全处理该事件。 如果处理事件的回调方法返回true，表明该处理方法已完全处理该事件，该事件不会传播出去 如果处理事件的回调方法返回false，表明该处理方法并未完全处理该事件，该事件会传播出去 返回值全为false时，当组件上发生某个按键被按下的事件时，Android系统最先触发的是该按键上绑定的事件监听器，然后才触发该组件上提供的事件回调方法，最后还会传播到该组件的Activity。 其他通过为View提供事件处理的回调方法，可以很好地把事件处理方法封装在该View内部，从而提高程序的内聚性——基于回调的事件处理更适合应付那种事件处理逻辑比较固定的View，比如跟随手指的View。 响应系统设置的事件在开发Android应用时，有时候可能需要让应用程序随系统设置而进行调整，比如判断系统的屏幕方向、判断系统方向的方向导航设备等。 Configuration类简介Configuration类专门用于描述手机设备上的配置信息，这些配置信息既包括用户特定的配置项，也包括系统的动态设备配置。程序可调用Activity的如下方法来获取系统的Configuration对象：Configuration cfg = getResources().getConfiguration(); 重写onConfigurationChanged方法响应系统设置更改如果程序需要监听系统设置的更改，则可以考虑重写Activity的onConfigurationChanged(Configuration newConfig)方法，该方法是一个基于回调的事件处理方法：当系统设置发生更改时，该方法会被自动触发。 实例：监听屏幕方向的改变（该界面就只有一个按钮，用来动态的修改系统屏幕的方向）MainActivity.java源码 1234567891011121314151617181920212223242526272829303132333435package com.example.changecfg;import androidx.appcompat.app.AppCompatActivity;import android.content.pm.ActivityInfo;import android.content.res.Configuration;import android.os.Bundle;import android.view.View;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void ChangeCfg(View view) &#123; Configuration config = getResources().getConfiguration(); if (config.orientation == Configuration.ORIENTATION_LANDSCAPE)&#123; MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); &#125; if (config.orientation == Configuration.ORIENTATION_PORTRAIT)&#123; MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE); &#125; &#125; @Override public void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); String screen = newConfig.orientation == Configuration.ORIENTATION_PORTRAIT?&quot;竖屏&quot;:&quot;横屏&quot;; Toast.makeText(this,&quot;系统的屏幕方向发生改变&quot;+&quot;\n修改后的屏幕方向为：&quot;+screen,Toast.LENGTH_LONG).show(); &#125;&#125; AndroidManifest.xml增加的源码 12&lt;activity android:name=&quot;.MainActivity&quot; android:configChanges=&quot;orientation|screenSize&quot;&gt; 在AndroidManifest中的配置代码指定了Activity可以监听屏幕方向改变的事件，当程序改变手机屏幕时，Activity中的onConfigurationChanged()方法就会被回调。 Handler消息传递机制出于性能优化考虑，Android的UI操作并不是线程安全的，这意味着如果有多个线程并发操作UI组件，则可能导致线程安全问题。为了解决这个问题，Android中制定了一条规则：只允许UI线程修改Activity里的UI组件。 当一个程序第一次启动时，Android会同时启动一条主线程（Main Thread），主线程主要负责处理与UI相关的事件，如用户的按键事件、用户接触屏幕的事件及屏幕绘图事件，并把相关的事件分发到对应的组件进行处理。所以，主线程通常又被叫做UI线程。 Android的消息传递机制是另一种形式的“事件处理”，这种机制主要是为了解决Android应用的多线程问题——Android平台只允许UI线程修改Activity里的UI组件，这样就会导致新启动的线程无法动态改变界面组件的属性值。但在实际Android应用开发中，尤其是涉及动画的游戏开发中，需要让新启动的线程周期性地改变界面组件的属性值，这就需要借助于Handler的消息传递机制了。 Handler类简介Handler类的主要作用有两个： 在新启动的线程中发送消息 在主线程中获取、处理消息 为了让主线程能“适时”地处理新启动的线程所发送的消息，显然只能通过回调的方式来实现——开发者只要重写Handler类中处理消息的方法，当新启动的线程发送消息时，消息会发送到与之关联的MessageQueue，而Handler会不断地从MessageQueue中获取并处理消息——这将导致Handler类中处理消息的方法被回调。 在自动播放图片实例中，定时器通过Timer周期性地执行指定任务，Timer可调度TimerTask对象，TimerTask对象的本质就是启动一条新线程，由于Android不允许在新线程中访问Activity里的界面组件，因此程序只能在新线程中发送一条消息，通知系统更新ImageView组件。 Handler、Loop、MessageQueue的工作原理Looper、MessageQueue、Handler各自的作用如下： Looper：每个线程只有一个Looper，它负责管理MessageQueue，会不断地从MessageQueue中取出消息，并将消息分给对应的Handler处理 MessageQueue：由Looper负责管理。它采用先进先出的方式来管理Message Handler：它能把消息发送给Looper管理的MessageQueue，并负责处理Looper分给它的消息 在线程中使用Handler的步骤如下： 调用Looper的prepare（）方法为当前线程创建Looper对象，创建Looper对象时，它的构造器会创建与之配套的MessageQueue 有了Looper之后，创建Handler子类的实例，重写handleMessage（）方法，该方法负责处理来自其他线程的消息 调用Looper的Loop（）方法启动Looper 实例：使用新线程计算质数 Ps：尽量避免在UI线程中执行耗时操作，因为这样可能导致一个“著名”的异常：ANR异常。只要在UI线程中执行需要消耗大量时间的操作，都会引发ANR，因为这会导致Android应用程序无法响应输入事件和Broadcast。 由于在新线程中创建Handler时必须先创建Looper因此程序先调用Looper的prepare（）方法为当前线程创建了一个Looper实例，并创建了配套的MessageQueue。新线程中有了Looper对象之后，接下来程序创建了一个Handler对象，该Handler可以处理其他线程发送过来的消息。程序最后还调用了Looper的loop（）方法。 异步任务（AsyncTask）为了避免UI线程失去响应的问题，Android建议将耗时操作放在新线程中完成，但新线程也可能需要动态更新UI组件，比如需要从网上获取一个网页，然后在TextView中将其源码显示出来，此时就应该将连接网络、获取网络数据的操作放在新线程中完成。但获取网络数据之后，新线程不允许直接更新UI组件。为了解决新线程不能更新UI组件的问题，Android提供了如下几种方法： 使用Handler实现线程之间的通信 Activity.runOnUiThread(Runnable) View.post(Runnable) View.postDelayed(Runnable,long) 后面三种方式比较烦琐，异步任务可以简化操作。异步任务，不需要借助线程和Handler即可实现。AsyncTask&lt;Params,Progress,Result&gt;是一个抽象类，通常用于被继承，继承时要指定如下三个泛型参数： Params：启动任务执行的输入参数的类型 Progress：后台任务完成的进度值的类型 Result：后台执行任务完成后返回结果的类型 使用AsyncTask只要如下三步即可： 创建AsyncTask的子类，并为三个泛型参数指定类型。如果某个泛型参数不需要指定类型，则可将它指定为Void 实现AsyncTask的如下方法 doInBackground(params)：重写该方法就是后台线程将要完成的任务。该方法可以调用publishProgress（Progress.. values）方法更新任务的执行进度 onProgressUpdate(progress.. values)：在doInBackground（）方法中调用publishProgress（）方法更新任务的执行进度后，将会触发该方法 onPreExceute()：该方法将在执行后台耗时操作前被调用。通常该方法用于完成一些初始化的准备工作，比如在界面上显示任务进度条等 onPostExecute(Result result)：当doInBackground（）完成后，系统会自动调用onPostExecute（）方法，并将doInBackground（）方法的返回值传给该方法 调用AsyncTask子类的实例的excute(Params.. params)开始执行耗时任务 使用AsyncTask时必须遵守如下规则 必须在UI线程中创建AsyncTask的实例 必须在UI线程中调用AsyncTask的execute（）方法 AsyncTask的onPreExecute(),onPostExecute(Result result),doInBackground(Params.. params),onProgressUpdate(Progress.. values)方法，不应该由程序员代码调用，而是由Andriod系统负责调用 每个AsyncTask只能被执行一次，多次调用将会引发异常 实现AsyncTask的子类，实现该子类时出现的如下4个方法： doInBackground()：完成实际的下载任务 onPreExecute()：在下载开始的时候显示一个进度条 onProgressUpdate()：随着下载进度的改变更新进度条的进度值 onPostExecute()：当下载完成之后，将下载的代码显示出来]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android事件处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（二十四）]]></title>
    <url>%2F2018%2F08%2F13%2F8.13.2%2F</url>
    <content type="text"><![CDATA[安卓基础Android事件处理概述Android提供了两套事件处理机制： 基于监听的事件处理 基于回调的事件处理 对于Android基于监听的事件崔而言，主要做法就是为Android界面组件绑定特定的事件监听器。ps：Android还允许用户在界面布局文件中为UI组件的android:onClick属性指定事件监听方法，通过这种方式指定事件监听方法时，开发者需要在Activity中定义该事件监听方法（该方法必须有一个View类型的形参，该形参代表被单击的UI组件），当用户单击该UI组件时，系统将会激发android:onClick属性所指定的方法。对于Android基于回调的事件处理而言，主要做法就是重写Android组件特定的回调方法，或者重写Activity的回调方法。一般来说，基于回调的事件处理可以用于一些具有通用性的事件，基于回调的事件处理代码会显得比较简洁。 基于监听的事件处理基于监听的事件处理是一种更“面向对象”的事件处理，这种处理方式与Java的AWT、Swing的处理方式几乎完全相同。 监听的处理模型在事件监听的处理模型中，主要涉及如下三类对象。 Event Source（事件源）：事件发生的场所，通常就是各个组件 Event（事件）：事件封装了界面组件上发生的特定事情（通常就是一次用户操作）。如果程序需要获得界面组件上所发生事件的相关信息，一般通过Event对象取得 Event Listener（事件监听器）：负责监听时间原所发生的事件，并对各种事件做出相应的响应 Java是面向对象的语言，方法不能独立存在，方法用来组织起来事件响应的动作，所以必须以类的形式组织这些方法，所以事件监听器的核心就是它所包含的方法-这些方法也被称为事件处理器（Event Handler）。 每个组件均可以针对特定的事件指定一个事件监听器，每个事件监听器也可监听一个或多个事件源。 用于监听的事件处理模型的步骤是： 获取普通界面组件（事件源），也就是被监听的对象 实现事件监听器类，该监听器类是一个特殊的Java类，必须实现一个XxxListener接口 调用事件源的setXxxListener方法将事件监听器对象注册给一个普通组件（事件源） Android为不同的界面组件提供了不同的事件监听器接口，这些接口通常以内部类的形式存在。以View为例，它包含如下几个内部接口： View.OnClickListener：单击 View.OnCreateContextMenuListener：创建上下文菜单 View.OnFocusChangeListener：焦点改变事件 View.OnKeyListener：按键事件 View.OnLongClickListener：长按事件 View.OnTouchListener：触摸事件]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android事件处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（二十三）]]></title>
    <url>%2F2018%2F08%2F13%2F8.13.1%2F</url>
    <content type="text"><![CDATA[安卓基础使用ActionBar显示选项菜单项Android不再要求手机必须提供MENU按键，这样可能导致用户无法打开选项菜单。为了解决这个问题，Android已经提供了ActionBar作为解决方案，ActionBar可以将选项菜单显示成Action Item。Menuitem新增了如下方法： setShowAsAction(int actionEnum)：该方法设置是否将该菜单项显示在ActionBar上，作为Action Item。 该方法支持如下参数值： SHOW_AS_ACTION_ALWAYS：总是将该MenuItem显示在ActionBar上 SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW：将该Action View折叠成普通菜单项 SHOW_AS_ACTION_IF_ROOM：当ActionBar位置足够时才显示MenuItem SHOW_AS_ACTION_NEVER：不将该MenuItem显示在ActionBar上 SHOW_AS_ACTION_WITH_TEXT：将该MenuItem显示在ActionBar上，并且显示该菜单项的文本 Android允许在XML菜单资源文件中为&lt;item…/&gt;元素指定如下属性 android：showAsAction：该属性的作用类似于setShowAsAction(int actionEnum)方法。因此该属性也能支持类似上面的属性值。 启用程序图标导航为了将应用程序图标转变为可以点击的图标，可以调用ActionBar的如下方法： setDisplayHomeAsUpEnable(boolean showHomeAsUp)：设置是否将应用程序图标转变为可点击的图标，并在图标上添加一个向左的箭头 setDisplayOptions(int options)：通过传入int类型常量来控制该ActionBar的显示选项 setDisplayShowHomeEnabled(boolean showHome)：设置是否显示应用程序图标 setHomeButtonEnabled(boolean enabled)：设置是否将应用程序图标变为可点击的按钮 添加Action ViewActionBar上除了可以显示普通的Action Item之外，还可以显示普通的UI组件。为了在ActionBar上添加Action View，可以用来如下两种方式。 定义Action Item时使用android:actionViewClass属性指定Action View的实现类 定义Action Item时使用android:actionLayout属性指定ActionView对应的视图资源 使用ActionBar实现Tab导航为了使用ActionBar实现Tab导航，按如下步骤进行即可 调用ActionBar的setNavigationMode(ActionBar.NAVIGATION_MODE_TABS)方法设置使用Tab导航方式 调用ActionBar的addTab()方法添加多个标签，并为每个Tab标签添加事件监听器 在实际项目中为了更好地展现Tab导航效果，ActionBar通常会与Fragment结合使用。 FragmentFragment是Android3.0新增的API，Fragment相当于Activity片段，通常我们使用单独的Activity组合多个Fragment，这样即可在一个Activity中创建多个用户界面。除此之外，也可以让多个Activity复用同一个Fragment。总之，Fragment相当于Activity的模块化区域。（多对多）Fragment拥有自己的生命周期，它可以接收、处理属于它自己的事件，并允许Activity运行期间动态地添加、删除Fragment。Fragment允许定义自己的布局，也可以通过生命周期回调定义自己的行为。与开发Activity类似的是，开发者自定义的Fragment也需要继承Fragment，并重写它的生命周期方法，通常会重写Fragment的onCreatView()生命周期方法。ps：viewPager用来给Fragment添加滑动功能；可以使用下面这个方法viewPager.setOffscreenPageLimit(3)设置缓存view 的个数为3。通常我们的ViewPager只会缓存当前页面的前后俩个页面，如果我切换到最后一个页面，则只会缓存前面的一个页面，会导致页面数据的重新加载。我们可以通过上面第三行的方法设置缓存页面的个数。当然，这只使用与页面较少的情况。 Android3.0以前的Fragment支持该Fragment不是继承android.app.Fragment，而是继承android.support.v4.app.Fragment。除此之外，Android还为该android.support.v4.app.Fragment提供了如下配套类。 FragmentActivity：只有该类提供的getSupportFragmentManager()方法才能获取Fragment管理器 ViewPager：它是Fragment容器，可以同时管理多个Fragment，并允许多个Fragment切换时提供动画效果 FragmentPagerAdapter：Adapter类，用于为ViewPager提供多个Fragment。通常用于被扩展 PagerTitleStrip：与ViewPager结合使用，用于在ViewPager上显示“导航条”。 使用ActionBar实现下拉式导航为了使用ActionBar实现下拉式导航，按如下步骤进行即可 调用ActionBar的actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_LIST)方法设置使用下拉列表的导航方式。 调用ActionBar的setListNavigationCallbacks(SpinnerAdapter adapter,ActionBar.OnNavigationListener callback)方法添加多个列表项，并为每个列表项设置事件监听器。其中第一个参数Adapter负责提供多个列表项，第二个参数为事件监听器。 其他AnalogClock在XML中是虚拟时钟。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ActionBar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（二十二）]]></title>
    <url>%2F2018%2F08%2F05%2F8.5.1%2F</url>
    <content type="text"><![CDATA[安卓基础使用活动条(ActionBar)活动条（ActionBar）是Android3.0的重要更新之一。ActionBar显示在屏幕的顶部。ActionBar可显示应用的图标和Activity标题。除此之外，ActionBar的右边还可以显示活动项（Action Item）。 ActionBar提供了如下功能： 显示选项菜单的菜单项（将菜单项显示成ActionItem） 使用程序图标作为返回Home主屏或向上的导航操作 提供交互式View作为ActionView 提供基于Tab的导航方式，可用于切换多个Fragment 提供基于下拉的导航方式 启用ActionBar最新的Android版本已经默认启用了ActionBar。因此只要在AndroidManifest.xml文件的SDK配置中指定该应用的目标版本高于11（Android3.0的版本号），默认就会启用ActionBar。 如果希望关闭ActionBar，则可以设置该应用的主题为Xxx.NoActionBar。在实际项目中，通常推荐使用代码控制ActionBar的显示、隐藏。ActionBar提供了如下方法来控制显示、隐藏。 show()：显示ActionBar hide()：隐藏ActionBar 下面是一个简单的实例，通过点击按钮实现显示或者隐藏：MainActivity.java源代码：123456789101112131415161718192021222324package com.example.actionbartest;import android.os.Bundle;import android.view.View;import androidx.appcompat.app.ActionBar;import androidx.appcompat.app.AppCompatActivity;public class MainActivity extends AppCompatActivity &#123; ActionBar actionBar; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); actionBar=getSupportActionBar(); &#125; public void showActionBar(View view) &#123; actionBar.show(); &#125; public void hideActionBar(View view) &#123; actionBar.hide(); &#125;&#125; ps：activity_main.xml比较简单就不给源代码了。在MainActivity.java中，尤其要注意MainActivity继承AppCompatActivity，使得actionBar对象必须通过getSupportActionBar()来实例化。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ActionBar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（二十一）]]></title>
    <url>%2F2018%2F08%2F05%2F8.5%2F</url>
    <content type="text"><![CDATA[安卓基础菜单Android应用中的菜单默认是看不见的，只有当用户按下手机上的“MENU”键时，系统才会显示该应用关联的菜单，这种菜单叫选项菜单（Option Menu）。从3.0系统开始，Android推荐ActionBar来代替菜单。 选项菜单和子菜单（SubMenu）Android系统的菜单支持主要通过4个接口来体现；Menu接口只是一个父接口，该接口下有如下两个接口。 SubMenu：它代表一个子菜单。可以包含1~N个MenuItem（形成菜单项） ContextMenu：它代表一个上下文菜单。可以包含1~N个MenuItem（形成菜单项） Android的不同菜单有如下特征： 选项菜单：选项菜单不支持勾选标记，并且只显示菜单的“浓缩（condensed）”标题 子菜单（SubMenu）：不支持菜单项图标，不支持嵌套子菜单 上下文菜单（ContextMenu）：不支持菜单快捷键和图标 Menu接口定义了如下方法来添加子菜单或菜单项 MenuItem add(int titleRes)：添加一个新的菜单项 MenuItem add(int groupId,int itemId,int order,int titleRes)：添加一个新的处于groupId组的菜单项 MenuItem add(int groupId,int itemId,int order,CharSequence title)：添加一个新的处于groupId组的菜单项 MenuItem add(CharSequence title)：添加一个新的菜单项 SubMenu addSubMenu(int titleRes)：添加一个新的子菜单 SubMenu addSubMenu(int groupId,int itemId,int order,int titleRes)：添加一个新的处于groupId组的子菜单 SubMenu addSubMenu(CharSequence title)：添加一个新的子菜单 SubMenu addSubMenu(int groupId,int itemId,int order,CharSequence title)：添加一个新的处于groupId组的子菜单 ps：add（）方法用于添加菜单项，addSubMenu（）方法用来添加子菜单 SubMenu继承了Menu，它就代表一个子菜单，额外提供了如下方法 SubMenu setHeaderIcon(Drawable icon)：设置菜单头的图标 SubMenu setHeaderIcon(int iconRes)：设置菜单头的图标 SubMenu setHeaderTitle(int titleRes)：设置菜单头的标题 SubMenu setHeaderTitle(CharSequence title)：设置菜单头的标题 SubMenu setHeaderView(View view)：使用View来设置菜单头 通过Menu、SubMenu、MenuItem来为Android应用添加菜单或子菜单。添加的步骤如下： 重写Activity中onCreateOptionsMenu(Menu menu)方法，在该方法里调用Menu对象的方法来添加菜单项或子菜单 如果希望应用程序能响应菜单项的单击事件，那么重写onOptionsItemSelected(MenuItem mi)方法即可。 下面给出一个为Android应用添加菜单和子菜单的例子的源码：activity_main.xml的源码： 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:gravity=&quot;center_horizontal&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;试试菜单项&quot;/&gt; &lt;EditText android:id=&quot;@+id/txt&quot; android:gravity=&quot;center_horizontal&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;输入测试文字&quot;/&gt;&lt;/LinearLayout&gt; MainActivity的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.example.menutest;import androidx.appcompat.app.AppCompatActivity;import android.graphics.Color;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.view.SubMenu;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; //定义“字体大小”的菜单项 final int FONT_10 = 0x111; final int FONT_12 = 0x112; final int FONT_14 = 0x113; final int FONT_16 = 0x114; final int FONT_18 = 0x115; //定义“恢复默认”的菜单项 final int PLAIN_ITEM = 0x11b; //定义“字体颜色”的菜单项 final int FONT_RED = 0x116; final int FONT_BLUE = 0x117; final int FONT_GREEN = 0x118; private EditText txt; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); txt = (EditText)findViewById(R.id.txt); &#125; @Override //当用户点击MENU键时触发该方法 public boolean onCreateOptionsMenu(Menu menu) &#123; //实例化一个菜单项对象 SubMenu fontMenu = menu.addSubMenu(&quot;字体大小&quot;); fontMenu.setIcon(R.drawable.ic_launcher_background); fontMenu.setHeaderIcon(R.drawable.ic_launcher_background); //设置菜单头的标题 fontMenu.setHeaderTitle(&quot;设置字体大小&quot;); //给菜单项添加子菜单 fontMenu.add(0,FONT_10,0,&quot;10号字体&quot;); fontMenu.add(0,FONT_12,0,&quot;12号字体&quot;); fontMenu.add(0,FONT_14,0,&quot;14号字体&quot;); fontMenu.add(0,FONT_16,0,&quot;16号字体&quot;); fontMenu.add(0,FONT_18,0,&quot;18号字体&quot;); //给menu添加一个菜单项 menu.addSubMenu(0,PLAIN_ITEM,0,&quot;恢复默认&quot;); SubMenu colorMenu = menu.addSubMenu(&quot;字体颜色&quot;); colorMenu.setIcon(R.drawable.ic_launcher_background); colorMenu.setHeaderIcon(R.drawable.ic_launcher_background); colorMenu.setHeaderTitle(&quot;设置字体颜色&quot;); colorMenu.add(0,FONT_RED,0,&quot;红色&quot;); colorMenu.add(0,FONT_BLUE,0,&quot;蓝色&quot;); colorMenu.add(0,FONT_GREEN,0,&quot;绿色&quot;); return super.onCreateOptionsMenu(menu); &#125; @Override //选项菜单的菜单项被单击后的回调方法 public boolean onOptionsItemSelected(MenuItem item) &#123; //判断单击的是哪个菜单项，并有针对性地做出响应 switch (item.getItemId())&#123; case FONT_10: txt.setTextSize(10*2); break; case FONT_12: txt.setTextSize(12*2); break; case FONT_14: txt.setTextSize(14*2); break; case FONT_16: txt.setTextSize(16*2); break; case FONT_18: txt.setTextSize(18*2); break; case FONT_RED: txt.setTextColor(Color.RED); break; case FONT_BLUE: txt.setTextColor(Color.BLUE); break; case FONT_GREEN: txt.setTextColor(Color.GREEN); break; case PLAIN_ITEM: Toast.makeText(MainActivity.this,&quot;您点击了恢复默认&quot;,Toast.LENGTH_SHORT).show(); txt.setTextColor(Color.BLACK); txt.setTextSize(18); break; &#125; return true; &#125;&#125; 使用监听器来监听菜单事件为菜单项绑定监听器的方法为： setOnMenuItemClickListener(MenuItem.OnMenuItemClickListener menuItemClickListener)：在这种方式下，我们可以采用简单的方法来添加菜单项，无须为每个菜单项指定ID。 不过这种方式要为每个菜单项绑定监听器，会是代码更加臃肿。 创建多选菜单项和单选菜单项调用如下方法实现： setCheckable(boolean checkable)：设置该菜单项是否可以被勾选，此方法使菜单项默认是多选菜单项 如果希望一组菜单里的菜单项都设为可勾选的菜单项，则可调用如下方法： setGroupCheckable(int group,boolean checkable,boolean exclusive)：设置group组里的所有菜单项是否可勾选；如果将exclusive设为true，那么他们就是一组单选菜单项 除此之外，Android还未MenuItem提供了如下方法来设置快捷键 setAlphabeticShortcut(char alphaChar)：设置字母快捷键 setNumericShortcut(char numericChar)：设置数字快捷键 setShortcut(char numericChar,char alphaChar)：同时设置两种快捷键 设置与菜单项关联的Activity有些时候，应用程序需要单击某个菜单项时启动其他Activity（包括其他Service）。对于这种需求，Android甚至不需要开发者编写任何事件处理代码，只要调用MenuItem的setIntent(Intent intent)方法即可——该方法将该菜单项与指定Intent关联在一起，当用户单击该菜单项时，该Intent所代表的组件将会被启动。 上下文菜单（ContextMenu）开发上下文菜单需要重写onCreateContextMenu(ContextMenu menu,View source,ContextMenu.ContextMenuInfo menuInfo)方法。其中source参数代表触发上下文菜单的组件。 开发上下文菜单的步骤如下： 重写Activity的onCreateContextMenu(ContextMenu menu,View source,ContextMenu.ContextMenuInfo menuInfo)方法 调用Activity的registerForContextMenu(View view)方法为view组件注册上下文菜单 如果希望应用程序能为菜单项提供响应，则可以重写onContextItemSelected(MenuItem mi)方法，或为指定菜单项绑定事件监听器 实例一个为一个TextView添加上下文菜单源码（长按View弹出菜单）：activity_main.xml: 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/txt&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!可通过上下文菜单修改背景色&quot; android:textSize=&quot;20sp&quot; android:background=&quot;@color/colorAccent&quot;/&gt;&lt;/LinearLayout&gt; MainActivity.java源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.example.contextmenutest;import androidx.appcompat.app.AppCompatActivity;import android.graphics.Color;import android.os.Bundle;import android.view.ContextMenu;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; final int MENU1 = 0x111; final int MENU2 = 0x112; final int MENU3 = 0x113; private TextView txt; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); txt = (TextView)findViewById(R.id.txt); registerForContextMenu(txt); &#125; @Override public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) &#123; menu.add(0,MENU1,0,&quot;红色&quot;); menu.add(0,MENU2,0,&quot;蓝色&quot;); menu.add(0,MENU3,0,&quot;绿色&quot;); menu.setGroupCheckable(0,true,true); menu.setHeaderIcon(R.mipmap.ic_launcher); menu.setHeaderTitle(&quot;选择背景色&quot;); &#125; @Override public boolean onContextItemSelected(MenuItem item) &#123; switch (item.getItemId())&#123; case MENU1: txt.setBackgroundColor(Color.RED); break; case MENU2: txt.setBackgroundColor(Color.BLUE); break; case MENU3: txt.setBackgroundColor(Color.GREEN); break; &#125; return true; &#125;&#125; 使用XML文件定义菜单Android提供了两种创建菜单的方式，一种是在Java代码中创建，一种是使用XML资源文件定义。在Java中定义菜单有如下不足： 在Java代码中定义菜单、菜单项，必然导致程序代码臃肿 需要程序员采用硬编码方式为每个菜单项分配ID，为每个菜单组分配ID，这种方式将导致应用可扩展性、可维护性降低。 使用XML资源文件来定义，这种方式可以提供更好的解耦。 菜单资源文件一般在res目录下新建的menu子目录，并在该子目录下提供menu_main.xml菜单资源文件。菜单资源的根元素通常是&lt;menu…/&gt;,&lt;menu…/&gt;元素无须指定任何属性。&lt;menu…/&gt;元素内可包含如下子元素。 &lt;item…/&gt;元素：定义菜单项 &lt;group…/&gt;子元素：将多个&lt;item…/&gt;定义的菜单项包装成一个菜单组 &lt;group…/&gt;子元素用于控制整租菜单的行为，该元素可指定如下常用属性。 checkableBehavior：指定该组菜单的选择行为。可指定为none（不可选）、all（多选）和single（单选）三个值 在程序中定义了资源文件后，接下来还是重写onCreateOptionsMenu(用于创建选项菜单)、onCreateContextMenu(用于创建上下文菜单)方法，在这些方法中调用MenuInflater对象的inflate方法加载指定资源对应的菜单即可。 下面的实例是将前面开发的菜单示例程序改为XML资源文件定义菜单。activity_main.xml源码： 123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;请输入测试文字!&quot; android:gravity=&quot;center_horizontal&quot; /&gt; &lt;EditText android:id=&quot;@+id/et&quot; android:gravity=&quot;center_horizontal&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;测试文字&quot;/&gt; &lt;TextView android:id=&quot;@+id/txt&quot; android:gravity=&quot;center_horizontal&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!可通过上下文菜单修改背景色&quot; android:textSize=&quot;20sp&quot; android:background=&quot;@color/colorAccent&quot;/&gt;&lt;/LinearLayout&gt; menu_main.xml源码（菜单项）： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:title=&quot;@string/font_size&quot;&gt; &lt;menu&gt; &lt;group android:checkableBehavior=&quot;single&quot;&gt; &lt;item android:title=&quot;@string/font_10&quot; android:id=&quot;@+id/font_10&quot;/&gt; &lt;item android:title=&quot;@string/font_12&quot; android:id=&quot;@+id/font_12&quot;/&gt; &lt;item android:title=&quot;@string/font_14&quot; android:id=&quot;@+id/font_14&quot;/&gt; &lt;item android:title=&quot;@string/font_16&quot; android:id=&quot;@+id/font_16&quot;/&gt; &lt;item android:title=&quot;@string/font_18&quot; android:id=&quot;@+id/font_18&quot;/&gt; &lt;/group&gt; &lt;/menu&gt; &lt;/item&gt; &lt;item android:title=&quot;@string/font_default&quot; android:id=&quot;@+id/font_default&quot;&gt; &lt;/item&gt; &lt;item android:id=&quot;@+id/font_color&quot; android:title=&quot;@string/font_color&quot;&gt; &lt;menu&gt; &lt;group android:checkableBehavior=&quot;single&quot;&gt; &lt;item android:id=&quot;@+id/red_font&quot; android:title=&quot;@string/red_font&quot;/&gt; &lt;item android:id=&quot;@+id/blue_font&quot; android:title=&quot;@string/blue_font&quot;/&gt; &lt;item android:id=&quot;@+id/green_font&quot; android:title=&quot;@string/green_font&quot;/&gt; &lt;/group&gt; &lt;/menu&gt; &lt;/item&gt;&lt;/menu&gt; context.xml源码（上下文菜单选项）： 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;group android:checkableBehavior=&quot;single&quot;&gt; &lt;item android:id=&quot;@+id/red&quot; android:title=&quot;@string/red&quot; android:alphabeticShortcut=&quot;r&quot;/&gt; &lt;item android:id=&quot;@+id/blue&quot; android:title=&quot;@string/blue&quot; android:alphabeticShortcut=&quot;b&quot;/&gt; &lt;item android:id=&quot;@+id/green&quot; android:title=&quot;@string/green&quot; android:alphabeticShortcut=&quot;g&quot;/&gt; &lt;/group&gt;&lt;/menu&gt; strings.xml资源文件： 1234567891011121314151617&lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;MenuResTest&lt;/string&gt; &lt;string name=&quot;font_size&quot;&gt;字体大小&lt;/string&gt; &lt;string name=&quot;font_default&quot;&gt;恢复默认&lt;/string&gt; &lt;string name=&quot;font_color&quot;&gt;字体颜色&lt;/string&gt; &lt;string name=&quot;font_10&quot;&gt;10号字体&lt;/string&gt; &lt;string name=&quot;font_12&quot;&gt;12号字体&lt;/string&gt; &lt;string name=&quot;font_14&quot;&gt;14号字体&lt;/string&gt; &lt;string name=&quot;font_16&quot;&gt;16号字体&lt;/string&gt; &lt;string name=&quot;font_18&quot;&gt;18号字体&lt;/string&gt; &lt;string name=&quot;red_font&quot;&gt;红色字体&lt;/string&gt; &lt;string name=&quot;blue_font&quot;&gt;蓝色字体&lt;/string&gt; &lt;string name=&quot;green_font&quot;&gt;绿色字体&lt;/string&gt; &lt;string name=&quot;red&quot;&gt;红色背景&lt;/string&gt; &lt;string name=&quot;blue&quot;&gt;蓝色背景&lt;/string&gt; &lt;string name=&quot;green&quot;&gt;绿色背景&lt;/string&gt;&lt;/resources&gt; MainActivity.java源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.example.menurestest;import androidx.appcompat.app.AppCompatActivity;import android.graphics.Color;import android.os.Bundle;import android.view.ContextMenu;import android.view.Menu;import android.view.MenuInflater;import android.view.MenuItem;import android.view.View;import android.widget.EditText;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; private TextView txt; private EditText et; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); et = (EditText)findViewById(R.id.et); txt = (TextView)findViewById(R.id.txt); registerForContextMenu(txt); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; MenuInflater inflater = new MenuInflater(this); inflater.inflate(R.menu.menu_main,menu); return super.onCreateOptionsMenu(menu); &#125; @Override public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) &#123; MenuInflater inflater = new MenuInflater(this); inflater.inflate(R.menu.context,menu); menu.setHeaderTitle(&quot;选择背景色&quot;); menu.setHeaderIcon(R.mipmap.ic_launcher); &#125; @Override public boolean onContextItemSelected(MenuItem item) &#123; item.setChecked(true); switch (item.getItemId())&#123; case R.id.red: txt.setBackgroundColor(Color.RED); break; case R.id.blue: txt.setBackgroundColor(Color.BLUE); break; case R.id.green: txt.setBackgroundColor(Color.GREEN); break; &#125; return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; if (item.isCheckable())&#123; item.setChecked(false); &#125; switch (item.getItemId())&#123; case R.id.font_10: item.setChecked(true); et.setTextSize(10*2); break; case R.id.font_12: item.setChecked(true); et.setTextSize(12*2); break; case R.id.font_14: item.setChecked(true); et.setTextSize(14*2); break; case R.id.font_16: item.setChecked(true); et.setTextSize(16*2); break; case R.id.font_18: item.setChecked(true); et.setTextSize(18*2); break; case R.id.red_font: item.setChecked(true); et.setTextColor(Color.RED); break; case R.id.blue_font: item.setChecked(true); et.setTextColor(Color.BLUE); break; case R.id.green_font: item.setChecked(true); et.setTextColor(Color.GREEN); break; case R.id.font_default: et.setTextColor(Color.BLACK); et.setTextSize(18); break; &#125; return true; &#125;&#125; 使用XML资源文件定义菜单有如下两个好处： XML资源文件不仅负责定义应用界面，也负责定义菜单，这样可把所有界面相关的内容交给XML文件管理，而Java代码的功能更集中。 后期更新、维护应用时，如果需要更新、维护菜单，打开、编辑XML文件即可，避免对Java文件的修改。 使用PopupMenu创建弹出式菜单PopupMenu代表弹出式菜单，它会在指定组件上弹出PopupMenu，在默认情况下，PopupMenu会显示在该组件的下方或者上方。PopupMenu可增加多个菜单项，并可为菜单项增加子菜单。 使用PopupMenu创建菜单的步骤如下： 调用new PopupMenu(Context context,View anchor)创建下拉菜单，anchor代表要激发该弹出菜单的组件。 调用MenuInflater的inflate()方法将菜单资源填充到PopupMenu中。 调用PopupMenu的show()方法显示弹出式菜单。 下面给出一个Button的PopupMenu的源码：activity_main.xml的源码： 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center_horizontal&quot; tools:context=&quot;.MainActivity&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;onPopupButtonClick&quot; android:text=&quot;点击试试&quot;/&gt;&lt;/LinearLayout&gt; menu文件夹中的popup_menu.xml资源文件源码： 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;item android:title=&quot;@string/query&quot; android:id=&quot;@+id/query&quot;/&gt; &lt;item android:title=&quot;@string/add&quot; android:id=&quot;@+id/add&quot;/&gt; &lt;item android:title=&quot;@string/edit&quot; android:id=&quot;@+id/edit&quot;/&gt; &lt;item android:title=&quot;@string/hide&quot; android:id=&quot;@+id/hide&quot;/&gt;&lt;/menu&gt; strings.xml资源文件源码： 1234567&lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;PopupMenuTest&lt;/string&gt; &lt;string name=&quot;query&quot;&gt;查找&lt;/string&gt; &lt;string name=&quot;add&quot;&gt;添加&lt;/string&gt; &lt;string name=&quot;edit&quot;&gt;编辑&lt;/string&gt; &lt;string name=&quot;hide&quot;&gt;隐藏菜单&lt;/string&gt;&lt;/resources&gt; MainActivity.java源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.example.popupmenutest;import androidx.appcompat.app.AppCompatActivity;import android.app.Activity;import android.os.Bundle;import android.view.MenuItem;import android.view.View;import android.widget.PopupMenu;import android.widget.Toast;public class MainActivity extends Activity &#123; PopupMenu popup = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void onPopupButtonClick(View view) &#123; //创建PopupMenu对象 popup = new PopupMenu(this,view); //将R.menu.popup_menu.xml菜单资源加载到popup菜单中 getMenuInflater().inflate(R.menu.popup_menu,popup.getMenu()); //为popup菜单的菜单项单击事件绑定事件监听器 popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() &#123; @Override public boolean onMenuItemClick(MenuItem menuItem) &#123; switch (menuItem.getItemId())&#123; case R.id.query: Toast.makeText(MainActivity.this,&quot;你点击了&quot;+menuItem.getTitle()+&quot;菜单项&quot;,Toast.LENGTH_SHORT).show(); break; case R.id.hide: //隐藏该对话框 popup.dismiss(); Toast.makeText(MainActivity.this,&quot;你点击了&quot;+menuItem.getTitle()+&quot;菜单项&quot;,Toast.LENGTH_SHORT).show(); break; case R.id.add: Toast.makeText(MainActivity.this,&quot;你点击了&quot;+menuItem.getTitle()+&quot;菜单项&quot;,Toast.LENGTH_SHORT).show(); break; case R.id.edit: Toast.makeText(MainActivity.this,&quot;你点击了&quot;+menuItem.getTitle()+&quot;菜单项&quot;,Toast.LENGTH_SHORT).show(); break; &#125; return true; &#125; &#125;); popup.show(); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>SubMenu</tag>
        <tag>ContextMenu</tag>
        <tag>PopupMenu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（二十）]]></title>
    <url>%2F2018%2F08%2F04%2F8.4.1%2F</url>
    <content type="text"><![CDATA[安卓基础对话框Android有如下4种常用的对话框： AlertDialog：功能丰富、最实际的对话框 ProgressDialog：进度对话框，这个对话框只是对进度条的包装 DatePickerDialog:日期选择对话框，这个对话框只是对DatePicker的包装 TimePickerDialog:时间选择对话框，这个对话框只是对TimePicker的包装 使用AlertDialog创建对话框AlertDialog生成的对话框有4部分： 图标区 标题区 内容区 按钮区 从对话框的结构来看，有下列几步创建对话框： 创建AlerDialog.Builder对象 调用AlertDialog.Builder的setTitle()或setCustomTitle()方法设置标题 调用AlertDialog.Builder的setIcon()方法设置图标 调用AlertDialog.Builder的相关设置方法设置对话框内容 调用AlertDialog.Builder的setPositiveButton()、setNegativeButton()、setNeutralButton()方法添加多个按钮 调用AlertDialog.Builder的creat()方法创建AlertDialog对象，再调用AlertDialog对象的show()方法将该对话框显示出来 其中第4步是最灵活的，AlertDialog允许创建各种内容的对话框。AlertDialog提供了如下6中方法来指定对话框的内容。 setMessage()：设置对话框内容为简单文本 setItems()：设置对话框内容为简单列表项 setSingleChoiceItems()：设置对话框内容为单选列表项 setMultiChoiceItems()：设置对话框内容为多选列表项 setAdapter()：设置对话框内容为自定义列表项 setView()：设置对话框内容为自定义的View ps： 调用setSingleChoiceItems()方法时既可以传入数组作为参数，也可传入Cursor（相当于数据库查询结果集）作为参数，还可传入ListAdapter作为参数。如果传入ListAdapter作为参数，则由ListAdapter来提供多个列表项组件。 调用setMultiChoiceItems()方法添加多选列表项时，需要传入一个boolean[]参数，该参数有两个作用：①设置初始化时选中哪些列表项；②该boolean[]类型的参数还可用于动态地获取多选列表中列表项的选中状态。 setAdapter()方法需要传入一个Adapter参数 setView()方法可以接受一个View组件，通过这种方式，开发者可以定制对话框的内容因为在Android界面编程中，一切都是View。 如下是使用setView()方法的实例：activity_main.xml文件代码： 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;自定义View对话框&quot; android:onClick=&quot;ViewBtn&quot;/&gt;&lt;/LinearLayout&gt; MainActivity.java代码： 1234567891011121314151617181920212223242526public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void ViewBtn(View view) &#123; LinearLayout login = (LinearLayout)getLayoutInflater().inflate(R.layout.layout,null); new AlertDialog.Builder(this).setIcon(R.mipmap.ic_launcher) .setTitle(&quot;乱写一通&quot;) .setView(login) .setPositiveButton(&quot;是个瓜皮&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; Toast.makeText(MainActivity.this,&quot;是个瓜娃子&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;).setNegativeButton(&quot;dsaf&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; Toast.makeText(MainActivity.this,&quot;sdfadfas&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;).create().show(); &#125;&#125; 新建的一个layout代码（提供一个View）： 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:id=&quot;@+id/login&quot;&gt; &lt;TextView android:layout_gravity=&quot;center_horizontal&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;asdfafdsadfsafdsfd&quot;/&gt; &lt;EditText android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;adsfasdfafdasfasfdsaf&quot; /&gt;&lt;/LinearLayout&gt; 对话框风格的窗口只是把显示窗口的Activity的风格设为对话框风格。 使用PopupWindow只用如下两步创建对话框风格的窗口： 调用PopupWindow的构造器创建PopupWindow对象 调用PopupWindow的showAsDropDown(View v)将PopupWindow作为v组件的下拉组件显示出来；或者调用PopupWindow的showAtLocation()方法将PopupWindow在指定位置显示出来 PopupWindow.dismiss()方法用来销毁，隐藏PopupWindow对象。 使用DatePickerDialog、TimePickerDialogDatePickerDialog和TimePickerDialog的用法需要下面两步： 通过new关键词创建DatePickerDialog、TimePickerDialog实例，调用它们的show()方法即可将日期选择对话框、时间选择对话框显示出来。 为DatePickerDialog和TimePickerDialog绑定监听器，这样可以保证用户通过DatePickerDialog和TimePickerDialog设置时间时触发监听器，从而通过监听器获得用户设置的时间。 使用ProgressDialog创建进度对话框ProgressDialog代表了进度对话框，程序只要创建ProgressDialog实例，并将它显示出来就是一个进度对话框。使用ProgressDialog创建进度对话框有如下两种方式。 如果只是创建简单的进度对话框，那么调用ProgressDialog提供的静态方法show()方法显示对话框即可 创建ProgressDialog，然后调用方法对话框里的进度条进行设置，设置完成后将对话框显示出来即可 为了对进度对话框里的进度条进行设置，ProgressDialog包含了如下常用的方法： setIndeterminate(boolean indeterminate)：设置对话框里的进度条不显示进度值 setMax(int max)：设置对话框里进度条的最大值 setMessage(CharSequence message)：设置对话框里显示的消息 setProgress(int value)：设置对话框里进度条的进度值 setProgressStyle(int style)：设置对话框里进度条的风格 ps:下面给出三种进度对话框源代码：activity_main.xml源代码： 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;环形进度条&quot; android:onClick=&quot;showSpinner&quot;/&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;不显示进度的进度条&quot; android:onClick=&quot;showIndeterminate&quot;/&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;显示进度的进度条&quot; android:onClick=&quot;showProgress&quot;/&gt;&lt;/LinearLayout&gt; MainActivity.java源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class MainActivity extends AppCompatActivity &#123; final static int MAX_PROGRESS = 100; private int[] data =new int[50]; int progressStatus =0; int hasData =0; ProgressDialog pd1,pd2; //定义负责更新进度的Handler Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; //表明消息是由程序发送的 if (msg.what==0x123)&#123; pd2.setProgress(progressStatus); &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void showSpinner(View view) &#123; //调用静态方法显示环形进度条 ProgressDialog.show(this,&quot;任务执行中&quot;,&quot;等一哈&quot;,false,true); &#125; public void showIndeterminate(View view) &#123; pd1 = new ProgressDialog(MainActivity.this); pd1.setTitle(&quot;任务执行中&quot;); //设置对话框显示的neir pd1.setMessage(&quot;还未完成，请等待&quot;); //设置对话框能用“返回”按钮关闭 pd1.setCancelable(true); //设置对话框的进度条风格 pd1.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL); //设置对话框的进度条是否显示进度；true表示不显示进度 pd1.setIndeterminate(true); pd1.show(); &#125; public void showProgress(View view) &#123; progressStatus = 0; hasData = 0; pd2 = new ProgressDialog(MainActivity.this); pd2.setMax(MAX_PROGRESS); pd2.setTitle(&quot;任务完成百分比&quot;); pd2.setMessage(&quot;耗时完成任务百分比&quot;); //设置对话框不能用“返回”按钮关闭 pd2.setCancelable(false); pd2.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL); //设置对话框的进度条是否显示进度；true表示不显示进度 pd2.setIndeterminate(false); pd2.show(); new Thread()&#123; @Override public void run() &#123; while (progressStatus &lt; MAX_PROGRESS)&#123; //获取耗时操作完成的百分比 progressStatus = MAX_PROGRESS * doWork() /data.length; handler.sendEmptyMessage(0x123); &#125; //如果任务完成 if (progressStatus&gt;= MAX_PROGRESS)&#123; //关闭对话框 pd2.dismiss(); &#125; &#125; &#125;.start(); &#125; private int doWork() &#123; //为数组元素赋值 data[hasData++] = (int)(Math.random()*100); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //返回数组的“第几” return hasData; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>AlertDialog</tag>
        <tag>PopupWindow</tag>
        <tag>DatePickerDialog</tag>
        <tag>TimePickerDialog</tag>
        <tag>ProgressDialog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（十九）]]></title>
    <url>%2F2018%2F08%2F04%2F8.4%2F</url>
    <content type="text"><![CDATA[安卓基础Notification的功能和用法Notification是显示在手机状态栏的通知。Notification所代表的是一种具有全局效果的通知，程序一般通过NotificationManager服务发送Notification。应用可通过NotificationManager向系统全局发送通知。 Android为Notification增加了Notification.Builder类，通过该类允许开发者更轻松地创建Notification对象。Notification.Builder提供了如下常用方法。 setDefaults()：设置通知LED灯、音乐、振动等 setAutoCancel()：设置点击通知后，状态栏自动删除通知 setContentTitle()：设置通知标题 setContentText()：设置通知内容 setSmallcon()：为通知设置图标 setLargelcon()：为通知设置大图标 setTick()：设置通知在状态栏的提示文本 setContentlntent()：设置点击通知后将要启动的程序组件对应的PendingIntent。 发送Notification有如下步骤： 调用getSystemService(NOTIFICATION_SERVICE)方法获取系统的NotificationManager服务。 通过构造器创建一个Notification对象 为Notification设置各种属性 通过NotificationManager发送Notification 下面是一个简单的通知实例：MainActivity.java中代码: 12345678910111213141516171819202122232425262728293031323334public class MainActivity extends AppCompatActivity &#123; static final int NOTIFICATION_ID = 0x123; NotificationManager nm; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); nm = (NotificationManager)getSystemService(NOTIFICATION_SERVICE); &#125; public void send(View view) &#123; Intent intent = new Intent(MainActivity.this,OtherActivity.class); PendingIntent pi =PendingIntent.getActivity(MainActivity.this,0,intent,0); //下面方法中的setDefaults()中有三种参数Notification.DEFAULT_SOUNDS,DEFAULT_VIBRATE,DEFAULT_LIGHTS。 // DEFAULT_ALL表示三个都默认。如果只是选择其中两个参数用 \ 符号连接。 Notification notification = new Notification.Builder(this) .setAutoCancel(true).setTicker(&quot;新消息&quot;) .setSmallIcon(R.mipmap.ic_launcher) .setContentTitle(&quot;一条新通知&quot;) .setContentText(&quot;您中奖了！&quot;) .setDefaults(Notification.DEFAULT_ALL) .setWhen(System.currentTimeMillis()) .setContentIntent(pi) .build(); //发送通知 nm.notify(NOTIFICATION_ID,notification); &#125; public void del(View view) &#123; //取消通知 nm.cancel(NOTIFICATION_ID); &#125;&#125; activity_main.xml中的代码： 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:id=&quot;@+id/send&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;发送&quot; android:onClick=&quot;send&quot;/&gt; &lt;Button android:id=&quot;@+id/del&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;取消&quot; android:onClick=&quot;del&quot;/&gt;&lt;/LinearLayout&gt; AndroidManifest.xml文件中代码： 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.notification&quot;&gt; &lt;!--添加操作闪光灯的权限--&gt; &lt;uses-permission android:name=&quot;android.permission.FLASHLIGHT&quot;/&gt; &lt;!--添加手机振动的权限--&gt; &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot;/&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!--声明新建的Activity，此Activity必须继承AppCompatActivity--&gt; &lt;activity android:name=&quot;.OtherActivity&quot;/&gt; &lt;/application&gt;&lt;/manifest&gt; PendingIntent详解Intent是一个意图，一个描述了想要启动一个Activity、Broadcast或是Service的意图。它主要持有的信息是它想要启动的组件（Activity、Broadcast或是Service），在开发操作中，需要通过 startActivity，startService 或sendBroadcast 方法来启动这个意图执行某些操作！！ PendingIntent可以认为是对Intent的包装，实际上就是，供当前App或之外的其他App调用，而常见的是供外部App使用，外部App执行这个PendingIntent时，间接地调用里面的Intent,即外部App延时执行PendingIntent中描述的Intent及其最终行为,PendingIntent主要持有的信息是它所包装的Intent和当前AppContext，即使当前App已经不存在了，也能通过存在于PendingIntent里的Context来执行Intent。当你把PendingIntent递交给别的程序进行处理时,PendingIntent仍然拥有PendingIntent原程序所拥有的权限，当你从系统取得一个PendingIntent时，一定要非常小心才行，比如，通常，如果Intent目的地是你自己的component（Activity/Service/BroadcastReceiver）的话，你最好采用在Intent中显示指定目的component名字的方式，以确保Intent最终能发到目的，否则Intent最后可能不知道发到哪里了。 可以这样理解：当你想在A activity中启动另一个B activity,那么你可以选择两种情况[立即启动或延时启动]： 通过intent配置需要启动的B activity，然后调用startActivity()方法，让他立即执行启动操作，跳转过去 另一种情况是，你虽然想启动另一个B activity，可是你并不想马上跳转到Bactivity页面，你想静等5分钟之后再跳转到Bactivity，那么你可以通过PendingIntent来实现[当然实现方式有很多啦，这里仅是想说明PendingIntent与intent的区别]，PendingIntent可以包装第1步中的intent，然后通过AlarmManager这个定时器，定制5分钟之后启PendingIntent，实现这种延时操作，如果你还是听着似懂非懂，一头雾水，我表示很有压力了，我该怎么说你才能清楚呢，理论终究是抽象的，后见将会通过一个程序说明一下，程序中是启动一个BroadcastReceiver，其实原理都是一样的！！ 如何获得一个PendingIntent呢？其实很简单： 你可以通过getActivity(Context context, int requestCode, Intent intent, int flags)系列方法从系统取得一个用于启动一个Activity的PendingIntent对象 可以通过getService(Context context, int requestCode, Intent intent, int flags)方法从系统取得一个用于启动一个Service的PendingIntent对象 可以通过getBroadcast(Context context, int requestCode, Intent intent, int flags)方法从系统取得一个用于向BroadcastReceiver的发送广播的PendingIntent对象 PendingIntent几个常量： FLAG_CANCEL_CURRENT：如果AlarmManager管理的PendingIntent已经存在，那么将会取消当前的PendingIntent，从而创建一个新的PendingIntent FLAG_UPDATE_CURRENT：如果AlarmManager管理的PendingIntent已经存在，可以让新的Intent更新之前PendingIntent中的Intent对象数据，例如更新Intent中的Extras，另外，我们也可以在PendingIntent的原进程中调用PendingIntent的cancel ()把其从系统中移除掉 FLAG_NO_CREATE：如果AlarmManager管理的PendingIntent已经存在，那么将不进行任何操作，直接返回已经存在的PendingIntent，如果PendingIntent不存在了，那么返回null]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Notification</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（十八）]]></title>
    <url>%2F2018%2F08%2F02%2F8.2%2F</url>
    <content type="text"><![CDATA[安卓基础滚动视图（ScrollView）的功能和用法ScrollView由FrameLayout派生而出，他就是一个用于为普通组件添加滚动条的组件。ScrollView里最多只能包含一个组件，而ScrollView的作用就是为该组件添加垂直滚动条。ScrollView的作用和Swing编程中的JScrollPane十分相似，它们甚至不能被称为真正的容器，它们只是为其他容器添加滚动条。如果应用需要添加水平滚动条，则可借助于另一个滚动视图——HorizontalScrollView来实现。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ScrollView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（十七）]]></title>
    <url>%2F2018%2F08%2F01%2F8.1%2F</url>
    <content type="text"><![CDATA[安卓基础选项卡（TabHost）的功能和用法TabHost是一种非常实用的组件，TabHost可以很方便地在窗口上放置多个标签，每个标签页相当于获得了一个与外部容器相同大小的组件摆放区域。通过这种方式，就可以在一个容器里放置更多组件。 与TabHost结合使用的还有如下组件： TabWidget：代表选项卡的标题条 TabSpec：代表选项卡的一个Tab页面。TabHost仅仅是一个简单的容器，它提供了如下两个方法来创建、添加标签页 newTabSpec(String tag)：创建选项卡 addTab(TabHost.TabSpec tabSpec)：添加选项卡 使用TabHost的一般步骤如下： 在界面布局文件中定义TabHost组件，并为该组件定义该选项卡的内容 Activity应该继承TabActivity 通过TabActivity的getTabHost（）方法获取TabHost对象 通过TabHost对象的方法来创建、添加选项卡 ps：布局文件中的ID有如下要求： TabHost的ID是@android:id/tabhost TabWidget的ID应该为@android:id/tabs FrameLayout的ID应该为@android:id/tabcontent 上面这三个ID并不是开发者自己定义的，而是引用了Android系统已有的ID。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>TabHost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（十六）]]></title>
    <url>%2F2018%2F07%2F31%2F7.31%2F</url>
    <content type="text"><![CDATA[安卓基础日期、时间选择器（DatePicker和TimePicker）的功能和用法DatePicker和TimePicker是两个比较易用的组件，它们都是从FrameLayout派生而来；DatePicker用来选择日期，TimePicker用来选择时间。 如果程序需要获取用户选择的日期、时间，则可通过为DatePicker添加OnDateChangedListener进行监听、为TimePicker添加OnTimeChangeListener进行监听来实现。 使用DatePicker时可指定XML属性如下： android:calendarViewShown：设置该日期选择器是否显示CalendarView组件 android:endYear：设置日期选择器允许选择的最后一年 android:maxDate：设置该日期选择器支持的最大日期。以mm/dd/yyyy格式指定最大日期 andorid:minDate：设置该日期选择器支持的最小日期。以mm/dd/yyyy格式指定最大日期 android:spinnerShown：设置该日期选择器是否显示Spinner日期选择组件 android:startYear：设置日期选择器允许选择的第一年 NumberPicker数值选择器的功能和用法数值选择器用于让用户输入数值，用户既可以通过键盘输入数值，也可以通过拖动来选择数值，使用该组件常用如下三个方法： setMinValue(int minVal)：设置该组件支持的最小值 setMaxValue(int maxVal)：设置该组件支持的最大值 setValue(int value)：设置该组件的当前值 搜索框（SearchView）的功能和用法SearchView是搜索框组件，它可以让用户在文本框内输入文字，并允许通过监听器监控用户输入，当用户输入完成后提交搜索时，也可通过监听器执行实际的搜索。 setIconifiedByDefault(boolean iconified):设置该搜索框默认是否自动缩小为图标 setSubmitButtonEnabled(boolean enabled)：设置是否显示搜索按钮 setQueryHint(CharSequence hint)：设置搜索框内默认显示的提示文本 setOnQueryTextListener(SearchView.OnQueryTextListener listener)：为该搜索框设置事件监听器]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>DatePicker</tag>
        <tag>TimePicker</tag>
        <tag>NumberPicker</tag>
        <tag>SearchView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（十五）]]></title>
    <url>%2F2018%2F07%2F30%2F7.30%2F</url>
    <content type="text"><![CDATA[安卓基础昨天未解决问题的补充解决在XML布局Layout文件中，如果要为当前组件添加一个点击事件，使用android:onClick=”….”方法时，需要在MainActivity中生成。使用Alt+Enter，直接生成，避免无法关联？因为又可能会无法关联上，产生Could not find method next(View) in a parent or ancestor Context for android错误。 ViewFlipper的功能与用法ViewFlipper组件继承了ViewAnimator，它可调用addView(View v)添加多个组件。可以使用动画控制多个组件之间的切换效果。 ViewFlipper与前面的AdapterViewFlipper有较大相似性，它们可以控制组件切换的动画效果。它们的区别是：ViewFlipper需要开发者通过addView(View v)方法添加多个View，而AdapterViewFlipper则只要传入一个Adaper，Adapter将会负责提供多个View。ViewFlipper可以指定与AdapterViewFlipper相同的XML属性。 使用Toast显示提示信息Toast有两个特点：Toast提示信息不会获得焦点；提示信息过一段时间会自动消失。 使用Toast的步骤： 调用Toast的构造器或makeText()静态方法创建一个Toast对象 调用Toast的方法来设置该消息提示的对齐方式、页边距等 调用Toast的show()方法将它显示出来 Toast的功能和用法都比较简单，大部分时候它只能显示简单的文本提示；如果应用需要显示诸如图片、列表之类的复杂提示，一般建议使用对话框来完成；如果开发者确实想通过Toast来完成，也是可以的，此时就需要调用Toast构造器创建实例，再调用setView()方法设置该Toast显示的View组件。此方法允许开发者自己定义Toast显示的内容。 日历视图（CalendarView）组件的功能和用法日历视图可用于显示和选择日期，用户既可以选择一个日期，也可通过触摸来滚动日历。如果希望监控该组件的日期改变，则可调用CalendarView的setOnDateChangeListener()方法为此组件的点击事件添加事件监听器。 使用CalendarView时常见的XML属性： android:dateTextAppearance：设置该日历视图的日期文字的样式 android:firstDayOfWeek：设置每周的第一天，允许设置周一到周日任意一天作为每周的第一天 android:focusedMonthDateColor：设置获得焦点的月份的日期文字的颜色 android:maxDate：设置日历组件支持的最大日期。以mm/dd/yyyy格式指定最大日期 android:minDate：设置该日历组件支持的最小日期。同上设置 android:selectedDateVerticalBar：设置绘制在选中日期两边的竖线对应的Drawable android:selectedWeekBackgroundColor：设置被选中周的背景色 android:showWeekNumber：设置是否显示第几周 android:shownWeekCount：设置该日历组件总共显示几个星期 android:unfocusedMonthDateColor：设置没有焦点的月份的日期文字的颜色 android:weekDayTextAppearance：设置星期几的文字样式 android:weekNumberColor：设置显示周编号的颜色 android:weekSeparatorLineColor：设置周分割线的颜色]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ViewFlipper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（十四）]]></title>
    <url>%2F2018%2F07%2F29%2F7.29%2F</url>
    <content type="text"><![CDATA[安卓基础ViewAnimator及其子类ViewAnimator继承了FrameLayout，因此它表现出FrameLayout的特征，可以将多个View组件叠在一起，ViewAnimator可以在View切换时表现出动画效果。 ViewAnimator的XML属性如下： android:animateFirstView：设置ViewAnimator显示第一个View组件时是否使用动画 android:inAnimation：设置ViewAnimator显示组件时所使用的动画 android:outAnimation：设置ViewAnimator隐藏组件时所使用的动画 ViewSwitcher的功能及用法ViewSwitcher代表了视图切换组件，因此可以将多个View层叠在一起，每次只显示一个组件。当程序控制从一个View切换到另一个View时，ViewSwitcher支持指定动画效果。 为了给ViewSwitcher添加多个组件，一般通过调用ViewSwitcher的setFactory(ViewSwitcher.ViewFactory)方法为之设置ViewFactory，并由该ViewFactory为之创建View即可。 图像切换器（ImageSwitcher）的功能和用法ImageSwitcher继承了ViewSwitcher，并重写了ViewSwitcher的showNext()和showPrevious()方法，因此ImageSwitcher使用起来更简单。使用ImageSwitcher只需如下两步： 为ImageSwitcher提供一个ViewFactory，该ViewFactory生成的View组件必须是ImageView。 需要切换图片时，只要调用ImageSwitcher的setImageDrawable(Drawable drawable)、setImageResource(int resid)和setImageURI(Uri uri)方法切换图片。 ImageSwitcher效果更炫，他可以指定图片切换时的动画效果。 文本切换器（TextSwitcher）的功能和用法TextSwitcher继承了ViewSwitcher，因此它具有与ViewSwitcher相同的特征：可以在在切换View组件时使用动画效果。它也需要设置一个ViewFactory，它的ViewFactory的makeView()方法必须返回一个TextView组件。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ViewSwitcher</tag>
        <tag>ImageSwitcher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（十三）]]></title>
    <url>%2F2018%2F07%2F28%2F7.28%2F</url>
    <content type="text"><![CDATA[安卓基础拖动条（SeekBar）的功能与用法SeekBar继承了ProgressBar，因此ProgressBar所支持的XML属性和方法完全适用于SeekBar。 SeekBar允许用户改变拖动条的滑块外观，改变滑块外观通过如下属性来指定。 android：thumb：指定一个Drawable对象，该对象将作为自定义滑块。 为了让程序响应滑块位置的改变，程序可以考虑为他绑定一个OnSeekBarChangeListener监听器。 星级评分条（RatingBar）的功能和用法星级评分条和拖动条有相同的父类：AbsSeekBar，因此它们相似；它们的区别就是RatingBar通过星星来表示进度。 下面是RatingBar所支持的常见XML属性： android:isIndicator：设置该星级评分条是否允许用户改变（true为不允许修改） android:numStars：设置该星级评分条总共有多少个星级 android:rating：设置该星级评分条默认的星级 android:stepSize：设置每次最少需要改变多少个星级 为了让程序能响应星级评分条评分的改变，可以考虑为它绑定一个OnRatingBarChangeListener监听器。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>SeekBar</tag>
        <tag>RatingBar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（十二）]]></title>
    <url>%2F2018%2F07%2F27%2F7.27%2F</url>
    <content type="text"><![CDATA[安卓基础ProgressBar及其子类ProgressBar本身代表了进度条组件，它还派生出了两个常用组件:SeekBar和RatingBar。ProgressBar及其子类在用法上十分相似，只是显示有一定的区别。（主要是用来动态地显示进度，提高用户界面的友好性） Android支持多种风格的进度条，通过style属性可以为ProgressBar指定风格。该属性可支持如下几个属性值： @android:style/Widget.ProgressBar.Horizontal：水平进度条 @android:style/Widget.ProgressBar.Inverse：普通大小的环形进度条 @android:style/Widget.ProgressBar.Large：大环形进度条 @android:style/Widget.ProgressBar.Large.Inverse：大环形进度条 @android:style/Widget.ProgressBar.Small：小环形进度条 @android:style/Widget.ProgressBar.Small.Inverse：小环形进度条 ProgressBar支持的XML属性： android:max：设置该进度条的最大值 android:progress：设置该进度条的已完成进度值 android:progressDrawable：设置该进度条对应的Drawable对象 android:indeterminate：该属性设为true，设置进度条不精确显示进度 android:indeterminateDrawable：设置绘制不显示进度条的Drawable对象 android:indeterminateDuration：设置不精确显示进度的持续时间 ProgressBar提供了如下方法来操作进度 setProgress（int）：设置进度的完成百分比 incrementProgressBy（int）：设置进度条的进度增加或减小。当参数为正数时进度增加，为负数时进度减小。 ps：Handler用来发送信息，当msg.what==0x111表示消息是由该程序发送的。math.random()函数是取从0至1之间的随机数,乘100以后就是取0到100之间的随机数 显示在标题上的进度条有一种进度条，可以直接在窗口标题上显示，这种进度条甚至不需要使用ProgressBar组件，它是直接由Activity的方法启用的。为了在窗口标题上显示进度条，需要经过下列两步： 调用Activity的requestWindowFeature（）方法，该方法根据传入的参数可启用特定的窗口特征。例如：传入Window.FEATURE_INDETERMINATE_PROGRESS在窗口标题上显示不带进度的进度条；传入Window.FEATURE_PROGRESS则显示带进度的进度条。 调用Activity的setProgressBarVisibility(boolean)或setProgressBarIndeterminate Visibility(boolean)方法即可控制进度条的显示和隐藏。 ps：Android5.0默认的主题：Material看不到标题上的进度条；因此要显示标题上的进度条需要将该应用主题设置为Holo。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ProgressBar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（十一）]]></title>
    <url>%2F2018%2F07%2F26%2F7.26%2F</url>
    <content type="text"><![CDATA[安卓基础Spinner的功能和用法Spinner就是一个列表选择框，相当于弹出一个菜单供用户选择。Spinner与Gallery都继承了AbsSpinner，AbsSpinner继承了AdapterView。因此它也表现出AdapterView的特征：只要为AdapterView提供Adapter即可。Spinner支持的常用XML属性及相关方法如下： android:entries：使用数组资源设置该下拉列表框的列表项 android:dropDownHorizontalOffest：设置列表选择框的水平偏移距 android:dropDownVerticalOffest：设置列表选择框的垂直偏移距 android:dropDownWidth：设置列表选择框的宽度 android:popupBackground：设置列表选择框的背景色 android:prompt：设置该列表选择框的提示信息 android：entries属性不是Spinner定义的，而是在AbsSpinner中定义的，因此Gallery也支持该XML属性。 如果开发者在使用Spinner时已经确定了列表选择框里的列表项，只要为Spinner指定android:entries属性即可；如果程序需要在运行时动态地决定Spinner的列表项，或者程序需要对Spinner的列表项进行定制，则可使用Adapter为Spinner提供列表项。 Spinner与Gallery都继承了AbsSpinner，表明Gallery和Spinner都是一个列表选择框。它们的区别是在于，Spinner显示的是一个垂直的列表选择框，而Gallery显示的是一个水平的列表选择框；Spinner的作用是供用户选择，而Gallery则允许用户通过拖动来查看上一个、下一个列表项。如果程序需要监控到Gallery选择项的改变，通过为Gallery添加OnItemSelectedListener监听器即可实现。 Android现在已经不推荐使用Gallery，而是用HorizontalScrollView和ViewPager来代替Gallery组件。 AdapterViewFlipper的功能与用法AdapterViewFlipper继承了AdapterViewAnimator，它也会显示Adapter提供的多个View组件，但它每次只能显示一个View组件，可通过showPrevious()和showNext()方法控制该组件显示上一个、下一个组件。 AdapterViewFilpper可以在多个View切换过程中使用渐隐渐显的动画效果。除此之外，还可以调用该组件的startFlippering()控制它“自动播放”下一个View组件。 AdapterViewAnimator支持的XML属性如下： android:animateFirstView：设置显示该组件的第一个View时是否使用动画 android:inAnimation：设置组件显示时使用的动画 android:loopViews：设置循环到最后一个组件后是否自动“转头”到第一个组件 android:outAnimation：设置组件隐藏时使用的动画 AdapterViewFilpper额外支持的XML属性： android:autoStart：设置显示该组件是否自动播放 android:flipInterval：设置自动播放的时间间隔 StackView的功能与用法StackView也是AdapterViewAnimator的子类，它也用于显示Adapter提供的一系列View。StackView将会以“堆叠(Stack)”的方式来显示多个列表项。StackView提供了下面两种控制方式： 拖走StackView中处于顶端的View，下一个View将会显示出来。将上一个View拖进StackView，将使之显示出来。 通过调用StackView的showNext()、showPrevious()控制显示下一个、上一个组件。 ps：定义的图片数组中元素位置靠前的在程序运行结果的最上方。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Spinner</tag>
        <tag>AdapterViewFlipper</tag>
        <tag>StackView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（十）]]></title>
    <url>%2F2018%2F07%2F25%2F7.25%2F</url>
    <content type="text"><![CDATA[安卓基础GridView（网格视图）GridView用于在界面上按行、列分布的方式显示多个组件。GridView和ListView都是AbsListView的子类，它们都有列表项。它们的区别就是：GridView能显示多列，ListView只能显示一列。GridView也需要通过Adapter来提供显示的数据。GridView提供的常用XML属性及相关方法如下： android:columnWidth:设置列的宽度 android:gravity:设置对齐方式 android:horizontalSpacing:设置各元素之间的水平间距 android:numColums:设置列数 android:stretchMode:设置拉伸模式 android:verticalSpacing:设置各元素之间的垂直间距 其中的android:stretchMode属性支持下列几个属性值： NO_STRETCH：不拉伸 STRETCH_SPACING：仅拉伸元素之间的间距 STRETCH_SPACING_UNIFORM：表格元素本身、元素之间的间距一起拉伸 STRETCH_COLUMN_WIDTH仅拉伸表格元素本身 GridView包含的多少行由Adapter决定。 ExpandableListView可展开的列表组件ExpandableListView时ListView的子类，它在普通ListView基础上进行了扩展，它把列表项分为几组，每组里又可包含多个列表项。ExpandableListView的用法与普通的ListView的用法十分相似，只是ExpandableListView所显示的列表项应该由ExpandableListAdapter提供，ExpandableListView也是一个接口。ExpandableListView额外支持的常用XML属性： android:childDivider：指定各组内各子列表项之间的分隔条 android:childIndicator：显示在子列表项旁边的Drawable对象 android:groupIndicator：显示在组列表项旁边的Drawable对象 扩展BaseExpandableListAdapter来实现ExpandableListAdapter，当扩展BaseExpandableListAdapter时，关键是实现如下4个方法： getGroupCount():该方法返回包含的组列表项的数量 getGroupView():该方法返回的View对象作为组列表项 getChildCount():该方法返回特定组所包含的子列表项的数量 getChildView():该方法返回的View对象将作为特定组、特定位置的子列表项]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GridView</tag>
        <tag>ExpandableListView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（九）]]></title>
    <url>%2F2018%2F07%2F24%2F7.24%2F</url>
    <content type="text"><![CDATA[安卓基础Adapter接口及实现类Adapter本身只是一个接口，它派生了ListAdapter和SpinnerAdapter两个子接口，其中ListAdapter为AbsListView提供列表项，而SpinnerAdapter为AbsSpinner提供列表项。Adapter常用的实现类： ArrayAdapter：简单、易用的Adapter。通常用于将数组或List集合的多个值包装成多个列表项 SimpleAdapter：并不简单、功能强大的Adapter，可以用于将List集合的多个对象包装成多个列表项 SimpleCursorAdapter：与SimpleAdapter基本相似，只是用于包装Cursor提供的数据 BaseAdapter：通常用于被扩展。扩展BaseAdapter可以对各列表项进行最大限度的定制 ArrayAdapter在布局文件中，定义ListView，但都没有指定android：entries属性，需要通过Adapter来提供列表项。Activity为两个ListView提供Adapter，Adapter决定ListView所显示的列表项。 1234ListView list = (ListView)findViewById(R.id.list)String[] arr1 = &#123;&quot;孙悟空&quot;,&quot;猪八戒&quot;,&quot;沙悟净&quot;&#125;;ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this,R.Layout.array_item,arr1);list.setAdapter(adapter); 其中ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this,R.Layout.array_item,arr1);中的参数： Context：代表访问整个Android应用的接口。几乎创建所有组件都需要传入Context对象。 textViewResourceId：一个资源ID，代表一个TextView，该TextView组件将作为ArrayAdapter的列表项组件 数组或List：负责为多个列表项提供数据 第二个参数控制每个列表项的组件，第三个负责为列表项提供数据。 如果程序的窗口仅需要显示一个列表，则可以直接让Activity继承ListActivity来实现，无需调用setContentView()方法显示一个界面，而是可以直接传入一个内容Adapter，ListActivity的子类就呈现出一个列表。如： 123String[] arr = &#123;&quot;孙悟空&quot;,&quot;猪八戒&quot;,&quot;沙悟净&quot;&#125;;ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this,R.Layout.simple_list_item_multiple_choice,arr);setAdapter(adapter); 使用Android提供的R.Layout.simple_list_item_multiple_choice布局文件作为列表项组件。 SimpleAdapter创建ListView通过ArrayAdapter实现Adapter虽然简单、易用，但是ArrayAdapter功能比较有限，它的每个列表项只能是TextView。如果想要实现更复杂的列表项，可以考虑使用SimpleAdapter。 123456789101112//创建一个List集合，List集合的元素是MapList&lt;Map&lt;String,Object&gt;&gt; listItems = new ArrayList&lt;Map&lt;String,Object&gt;&gt;();for(int i=0;i&lt; names.length;i++)&#123; Map&lt;String,Object&gt; listItem=new HashMap&lt;String,Object&gt;(); listItem.put(&quot;header&quot;,imageIds[i]); listItem.put(&quot;personName&quot;,names[i]); listItem.put(&quot;desc&quot;,descs[i]); listItems.add(listItem);&#125;//创建一个SimpleAdapterSimpleAdapter simpleAdapter = new SimpleAdapter(this,listItems,R.layout.simple_item,new String[] &#123;&quot;personName&quot;,&quot;header&quot;,&quot;desc&quot;&#125;,new int[] &#123;R.id.name,R.id.header,R.id.desc&#125;);list.setAdapter(simpleAdapter); 使用SimpleAdapter的难点在于创建SimpleAdapter对象，它需要5个参数，其中后四个最关键。 第二个参数：该参数应该是一个List&lt;?extends Map&lt;String,?&gt;&gt;类型的集合对象，该集合中每个Map&lt;String,?&gt;对象生成一个列表项。 第三个参数：该参数指定一个界面布局的ID。 第四个参数：该参数应该是一个String[]类型的参数，该参数决定提取Map&lt;String,?&gt;对象中那些key对应的value来生成列表项。 第五个参数：该参数应该是一个int[]类型的参数，该参数决定填充哪些组件。 如果需要监听用户单击、选中某个列表项的事件，可以通过AdapterView的setOnItemClickListener()方法为单击事件添加监听器，或者通过setOnItemSelectedListener()方法为列表项的选中事件添加监听器。在Activity中为ListView通过如下代码绑定监听器 123456//为ListView的列表项的单击事件绑定事件监听器list.setOnItemClickListener(new OnItemClickListener()&#123;&#125;);//为ListView的列表项的选中事件绑定事件监听器list.setOnItemSelectedListener(new OnItemSelectedListener()&#123;&#125;); 这种事件处理机制完全适用于AdapterView的其他子类 BaseAdapter通过扩展BaseAdapter来实现Adapter，扩展BaseAdapter可以取得对Adapter的最大控制权；程序要创建多少个列表项、每个列表项的组件都由开发者决定。 1234567891011121314151617181920BaseAdapter adapter = new BaseAdapter()&#123; @Override public int getCount()&#123;//指定一共包含多少个选项 return **;&#125; @Override public Object getItem(int position)&#123; return null;&#125;//重写该方法，该方法返回值将作为列表项的ID @Override public long getItemId(int position)&#123; return position;&#125;//重写该方法，该方法返回的View将作为列表框 @Override public View getView(int position,View convertView,ViewGroup parent)&#123;&#125;&#125; getCount():该方法的返回值控制该Adapter将会包含多少个列表项。 getItem(int position)：该方法的返回值决定第position处的列表项的内容。 getItemId(int position)：该方法的返回值决定第position处的列表项的ID。 getView(int position,View convertView,ViewGroup parent)：该方法的返回值决定第position处的列表项组件。 上面4个方法中最重要的是第一个和第四个。 AutoCompleteTextView自动完成文本框自动完成文本框（AutoCompleteTextView）从EditText派生而出，当用户输入一定字符之后，自动完成文本框会显示一个下拉菜单，供用户选择，当用户选择某个菜单项之后，AutoCompleteTextView按用户选择自动填充该文本框。AutoCompleteTextView除了可以使用EditText提供的XML属性和方法之外，还支持以下的常用XML属性： android:completionHint：设置下拉菜单中的提示标题 android:completionHintView：设置下拉菜单中提示标题的视图 android:completionThreshold：设置用户至少要输入几个字符才会显示提示 android:dropDownHeight：设置下拉菜单的高度 android:dropDownHorizontalOffset：设置下拉菜单与文本框之间的水平偏移。下拉菜单默认与文本框左对齐 android:dropDownVerticalOffset：设置下拉菜单与文本框之间的垂直偏移。下拉菜单默认紧跟文本框 android:dropDownWidth：设置下拉菜单的宽度 android:popupBackground：设置下拉菜单的背景 Markdow语法注意使用`标记代码块时，不要再它前后打空格，只要回车换行，留出空行就行。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Adapter</tag>
        <tag>ArrayAdapter</tag>
        <tag>SimpleAdapter</tag>
        <tag>BaseAdapter</tag>
        <tag>AutoCompleteTextView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（八）]]></title>
    <url>%2F2018%2F07%2F23%2F7.23%2F</url>
    <content type="text"><![CDATA[安卓基础 AdapterViewAdapterView是一组重要的组件，AdapterView是一个抽象基类。AdapterView具有如下特征 AdapterView继承了ViewGroup，它的本质是容器。 AdapterView可以包括多个“列表项”，并将多个“列表项”以合适的形式显示出来。 AdapterView显示的多个“列表项”由Adapter提供。调用AdapterView的setAdapter(Adapter)方法设置Adapter即可。 AdapterView派生了三个子类：AbsListView、AbsSpinner、AdapterViewAnimator，这三个子类依然是抽象的，实际使用过程中往往采用他们的子类。 列表视图(ListView)和ListActivityListView它以垂直列表的形式显示所有列表项。生成列表视图有如下两种方式： 直接使用ListView创建 让Activity继承ListActivity(相当于该Activity显示的组件为ListView) 一旦在程序中获得了ListView之后，接下来就需要为ListView设置它要显示的列表项。在这一点上，ListView显示出AdapterView的特征：通过setAdapter(Adapter)方法为之提供Adapter，并且由Adapter提供列表项即可。 ListView、GridView、Spinner、Gallery等AdapterView都是容器，而Adapter负责提供每个“列表项”组件，AdapterView则负责采用合适的方式显示这些列表项。 ListView提供的常用XML属性如下： android:divider：设置List列表项的分隔条（可用颜色分隔，也可用Drawable分隔） android:dividerHeight：设置分隔条的高度 android:entries：指定一个数组源，Android将根据该数组资源来生成ListView android:footerDividersEnabled：如果设置为false，则不再footerView之前绘制分隔条 android:headerDividersEnabled：如果设置为false，则不在headerView之后绘制分隔条]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ListView</tag>
        <tag>ListActivity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（七）]]></title>
    <url>%2F2018%2F07%2F22%2F7.22%2F</url>
    <content type="text"><![CDATA[安卓基础 ImageViewImageView继承View，主要用来显示图片，它能显示的不仅仅是图片，任何Drawable对象都可以使用ImageView来显示。ImageView支持的XML属性： android:adjustViewBounds设置ImageView是否调整自己的边界来保持所显示图片的长宽比 android:cropToPadding如果将该属性设置为true，该组件将会被裁剪到保留该ImageView的padding android:scaleType设置所显示的图片如何缩放或移动以适应ImageView的大小 android:src设置ImageView所显示的图片的ID android:scaleType支持的属性值： matrix:使用matrix方式进行缩放 fitXY对图片、纵向独立缩放 fitStart保持纵横比缩放图片 fitCenter保持纵横比缩放图片，缩放后放在ImageView中央 fitEnd保持纵横比缩放图片，缩放后放在ImageView的右下角 center放在ImageView中央 centerCrop保持纵横比缩放图片，只要图片的最短边能显示出来即可 centerInside保持纵横比缩放图片，ImageView能完全显示该图片 为了控制ImageView显示的图片，ImageView提供了如下方法 setImageBitmap(Bitmap bit):使用Bitmap位图设置图片 setImageDrawable(Drawable drawable)：使用Drawable对象设置图片 setImageResource(int resId)：使用图片资源ID设置图片 setImageURI(Uri uri)：使用图片的URI设置该ImageView显示设置的图片 ps：如果要实现放大图片的局部 1234有两个ImageView，第一个放原图Image1，第二个放发大的部分图片Image2。第一步：获取原图与放大部分的比例，即double scale = 1.0*Image1.getHeight()/Image2.getHeight()。第二步：获取需要显示的图片的起始位置:int X=(int)(event.getX()*scale);int Y=(int)(event.getY()*scale);还要注意在原图中右边和下边的宽度大于Image2的，必须固定起始位置为Image1.getWidth()-Image2.getWidth()。 ImageButtonImageButton派生了一个ZoomButton，ZoomButton可以代表“放大”“缩小”两个按钮，ZoomButton的行为基本类似于ImageButtonZoomControls组件，该组件相当于同时组合了“放大”“缩小”两个按钮，并允许分别为两个按钮绑定不同的事件监听器。 使用QuickContactBadge关联联系人QuickContactBadge继承了ImageView，因此它的本质也是图片按钮，也可以通过android:src来指定它显示的图片。它额外增加的功能是：该图片可以关联到手机中指定联系人，当用户单机该图片时，系统将会打开相应联系人的联系方式界面。可以调用如下方法： assignContactFromEmail(String emailAddapp\src\main\ress,boolean lazyLookup):将该图片关联到指定E-mail地址对应的联系人 assignContactFromPhone(String phoneNumber,boolean lazyLookup):将该图片关联到指定电话号码对应的联系人 assignContactUri(Uri contactUri):将图片关联到特定Uri对应的联系人杂项改变查看图片的透明度，可以调用ImageView的setImageAlpha()方法来实现i+=a 就是i=i+a]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ImageView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（六）]]></title>
    <url>%2F2018%2F07%2F21%2F7.21%2F</url>
    <content type="text"><![CDATA[安卓基础TextView默认情况下，TextView是不带边框的，如果想为TextView添加边框，可以考虑为TextView设置一个背景Drawable，该Drawable只是一个边框（是一个XML文件，放在drawable文件夹内）。由于TextView是EditText和Button的父类，因此对TextView控制的属性，同样适用于EditText与Button。 EditTextEditText最重要的属性是inputType，该属性相当于HTML的&lt;input…/&gt;元素的type属性，用于将EditText设置为指定类型的输入组件。android:inputType属性（系统自动显示哪种类型的输入键盘）： numberPassword：表示只能接受数字密码（使用安卓系统自带安全的数字输入法） number：表示是数字输入框（使用输入法的数字输入法） date：表示是日期输入框（使用输入法的数字输入法） phone：表示是输入电话号码的输入框（使用输入法的数字输入法） android:selectAllOnFocu属性 =true为如果文本框的内容能选择，设置是否当它获得焦点时自动选中所有文本。 =false不选中。 ButtonButton继承了TextView，主要是生成一个按钮，该按钮能提供被用户点击时触发一个onClick事件。如果需要让按钮的背景颜色、背景图片随用户动作动态改变，考虑使用自定义Drawable实现。 Button常用属性： android:shadowColor设置文本框内文本的阴影颜色 android:shadowRadius设置阴影的模糊程度，该值越大越模糊 android:shadowDx阴影在水平方向的偏移 android:shadowDy阴影在垂直方向的偏移 Button的android:background=””属性，可以用XML实现，在XMl中可以用state_pressed=”true”表示按钮按下，state_pressed=”false”表示按钮松开，并且利用android:drawable=””表示背景。 使用9Patch图片作为背景当按钮的内容太多时，Android会自动缩放整张图片，以保证背景图片能覆盖整个按钮。但是这种缩放的效果并不好。为了实现只缩放图片中某个部分，借助9Patch图片实现。左侧和上侧的直线共同决定图片的缩放区域右侧和下侧的直线共同决定图片的内容显示区域 RadioButton和CheckBox两个都有一个可选中的功能，不过一组RadioButton只能选择其中一个，所以RadioButton通常要与RadioGroup一起使用，用于定于一组单选钮；CheckBox可以复选。都可额外指定一个android:checked属性，该属性用于指定RadioButton、checkBox初始时是否被选中。如果在XML布局文件中默认勾选了某个单选钮，则必须为该组单选钮的每个按钮指定android：id属性值；否则这组单选钮不能正常工作 状态开关按钮（ToggleButton）和开关（Switch）两个都是Button派生出来的，本质也是按钮。ToggleButton和Switch通常用于切换程序中的某种状态。ToggleButton支持的XML属性： android:checked设置该按钮是否被选中 android:textOff设置当按钮的状态关闭时显示的文本 android:textOn设置当按钮的状态打开时显示的文本 Switch支持的XML属性： android:checked设置该按钮是否被选中 android:textOff设置当按钮的状态关闭时显示的文本 android:textOn设置当按钮的状态打开时显示的文本 android:switchTextAppearnce设置该开关图标上的文本样式 android:textStyle设置该开关的文本风格 android:thumb指定使用自定义Drawable绘制该开关按钮 android:track指定使用自定义Drawable绘制该开关的开关轨迹 android:typeface设置该开关的文本的字体风格 时钟（AnalogClock和TextClock）TextClock是数字时钟，继承了TextView，不能设置android:text。它的属性： android:format12Hour设置该时钟的12小时制的格式字符串 android:format24Hour设置该时钟的24小时制的格式字符串 android:timeZone设置该时钟的时区 AnalogClock是模拟时钟，继承了View，重写了View的OnDraw方法。它的属性： android:dial设置该模拟时钟的表盘使用的图片 android:hand_hour设置该模拟时钟的时针使用的图片 android:hand_minute设置该模拟时钟的分针使用的图片 计时器(Chronometer)Chronometer继承TextView，但是它不会显示当前时间，它显示的是从某一个起始时间开始，一共过去了多长时间。Chronometer的方法： setBase(long base)：设置计时器的起始时间 setFormat(String format)：设置显示时间的格式 start()：开始计时 stop()：停止计时 setOnChronometerTickListener(Chronometer.OnChronometerTickListener listener)：绑定事件监听器，当事件改变时触发该监听器 SystemClock.elapsedRealtime()，系统启动至今的时间/计算某个时间经历了多长时间有意义 零碎知识点String words = checkId == R.id.male ? &quot;你的性别是男性&quot;:&quot;你的性别是女性&quot;这句代表如果RadioButton的checkId值是等于R.id.male就把”你的性别是男性”赋给words。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>TextView</tag>
        <tag>EditText</tag>
        <tag>Button</tag>
        <tag>使用9Patch图片作为背景</tag>
        <tag>RadioButton和CheckBox</tag>
        <tag>状态开关按钮（ToggleButton）和开关（Switch）</tag>
        <tag>时钟（AnalogClock和TextClock）</tag>
        <tag>计时器(Chronometer)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[长征]]></title>
    <url>%2F2018%2F07%2F20%2F7.20%2F</url>
    <content type="text"><![CDATA[回顾历史长征土地革命战争时期，中国工农红军主力撤离长江南北各苏区，转战两年，到达陕甘苏区的战略转移行动。1934年10月，第五次反围剿失败后，中央主力红军为摆脱国民党军队的包围追击，被迫实行战略性转移，退出中央根据地，进行长征。长征是人类历史上的伟大奇迹，中央红军共进行了380余次战斗，攻占700多座县城，红军牺牲了营以上干部多达430余人，平均年龄不到30岁，共击溃国民党军数百个团，其间共经过14个省，翻越18座大山，跨过24条大河，走过荒草地，翻过雪山，行程约二万五千里，红一方面军于1935年10月到达陕北，与陕北红军胜利会师。1936年10月，红二、四方面军到达甘肃会宁地区，同红一方面军会师。红军三大主力会师，标志着万里长征的胜利结束。 基本路线瑞金→突破敌四道防线→强渡乌江→占领遵义→四渡赤水→巧渡金沙江→强渡大渡河→飞夺泸定桥→翻雪山→过草地→陕北吴起会师(1935年10月)→甘肃会宁会师(1936年10月)，宣告长征的胜利结束。 各阶段长征准备阶段（1934年7月7日～1934年10月10日）长征失利阶段（1934年10月10日～1935年1月15日）长征转折阶段（1935年1月15日～1935年6月14日）坚持北上和南下分裂阶段（1935年6月14日～1935年10月19日）发展巩固和南下受挫阶段（1935年10月19日～1936年7月1日）大会师阶段（1936年7月1日～1936年12月12日） 各部队第一支是中央红军（后改称红一方面军），于1934年10月10日由福建的长汀等地出发，1935年10月19日到达陕西的吴起镇（今吴起县），行程达二万五千里；第二支是红二十五军（后编入红一方面军），于1934年11月16日由河南罗山何家冲出发，1935年9月15日到达陕西延川永坪镇，同陕甘红军会师，合编为红十五军团，行程近万里，最早到达陕北的一支红军 。第三支是红四方面军，于1935年5月初放弃川陕苏区，由彰明、中坝、青川、平武等地出发，向岷江地区西进，1936年10月9日到达甘肃会宁，与红一方面军会师，行程一万余里；第四支是红二、红六军团（后同红一方面军第三十二军合编为红二方面军），于1935年11月19日由湖南桑植刘家坪等地出发，1936年10月22日到达会宁以东的将台堡，同红一方面军会师，行程两万余里。]]></content>
      <categories>
        <category>历史</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android学习（五）]]></title>
    <url>%2F2018%2F07%2F19%2F7.19%2F</url>
    <content type="text"><![CDATA[安卓基础相对布局RelativeLayout可支持的两个Xml属性 android:gravity设置该布局容器内各子组件的对齐方式 android:ignoreGravity设置哪个组件不受gravity属性影响 为了扩展RelativeLayout中各子组件的分布布局，RelativeLayout提供了一个内部类：RelativeLayout.LayoutParams，该类提供了大量的Xml属性来控制子组件的布局分布。 相对布局子组件的布局分布里只能设置true或false的XML属性。 android:layout_centerHorizontal控制该子组件是否位于布局容器的水平居中 android:layout_centerVertical控制该子组件是否位于布局容器的垂直居中 android:layout_centerInParent控制该子组件是否位于布局容器的中央位置 android:layout_alignParentBottom控制该子组件是否与布局容器的底端对齐 android:layout_alignParentLeft控制该子组件是否与布局容器的左端对齐 android:layout_alignParentRight控制该子组件是否与布局容器的右端对齐 android:layout_alignParentTop控制该子组件是否与布局容器的顶端对齐 相对布局子组件的布局分布里属性值为其他UI组件ID的XML属性。 android:layout_toRightOf控制该子组件位于给出ID组件的右侧 android:layout_toLeftOf控制该子组件位于给出ID组件的左侧 android:layout_above控制该子组件位于给出ID组件的上方 android:layout_below控制该子组件位于给出ID组件的下方 android:layout_alignTop控制该子组件与给出ID组件的上边界对齐 android:layout_alignBottom控制该子组件与给出ID组件的下边界对齐 android:layout_alignLeft控制该子组件与给出ID组件的左边界对齐 android:layout_alignRight控制该子组件与给出ID组件的右边界对齐 ps：align对齐，to在什么侧 GridLayoutGridLayout的作用类似于HTML中的table标签，它将整个容器划分为rows*columns个网格，每个网格可以放置一个组件。除此之外，也可以设置一个组件横跨多少列、一个组件纵跨多少行。GridLayout常用的XML属性： android:alignmentMode设置该布局管理器采用的对齐模式 android:columnCount设置该网格的列数量 android:columnOrderPreserved设置该网格容器是否保留序号 android:rowCount设置该网格的行数量 android:rowOrderPreserved设置该网格容器是否保留行序号 android:useDefaultMargins设置该布局管理器是否使用默认的页边距 ps：Margins边距，column列，row行为了控制GridLayout布局容器中各子组件的布局分布，GridLayout提供了一个内部类：GridLayout.LayoutParams，该类提供了大量的XML属性来控制网格布局中子组件的布局分布。GridLayout.LayoutParams常用的XML属性： android:layout_column设置该子组件在GridLayout的第几列 android:layout_columnSpan设置该子组件在GridLayout横向上跨几列 android:layout_gravity设置该子组件采用何种方式占据该网格的空间 android:layout_row设置该子组件在GridLayout的第几行 android:layout_rowSpan设置该子组件在GridLayout纵向上跨几行 ps：column列，row行，span跨越setpadding(a,b,c,d)设置四周的空白区域 绝对布局绝对布局由AbsoluteLayout所代表。就像Java中AWT编程中的空布局，Android不提供任何布局控制，而是由开发人员自己通过X、Y坐标来控制组件的位置，布局容器不再管理子组件的位置、大小。（绝对布局已经过时了） layout_x:子组件的X坐标 layout_y:子组件的Y坐标 安卓布局中常用的距离单位px：每个px对应屏幕上的一个点dip或dp（设备独立像素，device independent pixels）：一种基于屏幕密度的抽象单位。在每英寸160点的显示器上，1dip=1px。但随着屏幕密度的改变，dip与px的换算会发生改变。sp（比例像素，scaled pixels）：主要是处理字体的大小，可以根据用户的字体大小首选项进行缩放。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>View</tag>
        <tag>Relativelayout</tag>
        <tag>GridLayout</tag>
        <tag>AbsoluteLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（四）]]></title>
    <url>%2F2018%2F07%2F18%2F7.18%2F</url>
    <content type="text"><![CDATA[安卓基础表格布局TableLayout继承了LinearLayout，TableLayout通过添加TableRow、其他组件来控制表格的行数和列数。每次向TableLayout中添加一个TableRow，该TableRow就是一个表格行，TableRow也是容器，因此它也可以不断地添加其他组件，每添加一个子组件该表格就增加一行。如果直接向TableLayout中添加组件，那么这个组件将直接占用一行。在TableLayout中，列的宽度由最宽的TableRow决定，整个表格布局的宽度由父容器决定。Shrinkable：一个TableRow中，列的单元格宽度可以收缩。从0开始计数Stretchable：一个TableRow中，列的单元格宽度可以拉伸。从0开始计数 帧布局帧布局由FrameLayout所代表，FrameLayout直接继承了ViewGroup组件。帧布局容器为每个加入其中的组件创建一个空白的区域(一帧)，每个子组件占据一帧，这些帧都会根据gravity属性执行自动对齐。把组件一个个叠加在一起，后加的组件覆盖前面加的组件。FrameLayout包含的子元素也可指定Layout_gravity。安卓不允许开发者启动线程访问用户界面的UI组件。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>View</tag>
        <tag>Tablelayout</tag>
        <tag>FrameLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（三）]]></title>
    <url>%2F2018%2F07%2F16%2F7.16%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[安卓基础开发自定义ViewView组件只是一个空白区域，没有任何内容。对于Android应用的其他UI组件来说，它们都继承了View组件，然后再View组件提供的空白区域绘制外观。当Android系统提供的UI组件不足以满足项目需要时，开发者可以通过继承View来派生自定义组件。当开发者打算派生自己的UI组件时，首先要定义一个继承View基类的子类，然后重写View类的一个或多个方法。 线性布局Android的线性布局不会换行，当组件一个挨着一个排列到头之后，剩下的组件将不会被显示出来。Linearlayout的常用XML属性及相关方法的说明： android:divider 设置处置布局时两个按钮之间的分隔条 android:gravity 设置布局管理器内组件的对齐方式。可以同时指定多种对齐方式的组合，例如：left|center_vertical代表出现在屏幕左边，而且垂直居中。 android:orientation 设置布局管理器内组件的排列方式。有horizontal水平排列，vertical垂直排列。 Linearlayout包含的所有子元素都受Linearlayout.layoutParams控制，因此Linearlayout包含的子元素可以额外指定如下的属性： android:layout_gravity 指定该子元素在Linearlayout中的对齐方式 android:layout_weight 指定该子元素在Linearlayout中所占的权重 ps：许多布局内子元素支持指定android:layout_ gravity属性，该属性设置该子元素在父容器中的对齐方式。与android:layout_gravity相似的属性还有android:gravity属性（一般是容器才支持指定该属性），android:gravity属性用于控制它所包含的子元素的对齐方式。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>View</tag>
        <tag>Linearlayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i++与++i的区别]]></title>
    <url>%2F2018%2F07%2F15%2F7.15.2%2F</url>
    <content type="text"><![CDATA[这个问题过一段时间就老是忘记i++与++i的区别简单的说i++与++i在单独使用的时候，就是i=i+1。而a=++i，相当于i=i+1；a=i；（先i=i+1，再使用i的值）而a=i++，相当于a=i；i=i+1；（先使用i的值，再i=i+1） 0对任何数求余结果都是0例如：0%2就是0.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>i++与++i</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（二）]]></title>
    <url>%2F2018%2F07%2F15%2F7-15%2F</url>
    <content type="text"><![CDATA[安卓基础Activity和ViewActivity只能通过setContentView(View)来显示指定组件。setContentView()的参数有两种： view对象 布局管理器的id值，即R.layout.main等等 ServiceService也代表一个单独的Android组件。Service与Activity的区别在于：Service通常位于后台运行，它一般不需要与用户交互，因而Service没有图形用户界面。Service组件需要继承Service基类，Service被运行起来之后，它将拥有自己独立的生命周期，Service组件通常用于为其他组件提供后台服务或监控其他组件的运行状态。 BroadcastReceiverBroadcastReceiver也是Android应用中的组件，代表广播消息接收器。BroadcastReceiver非常类似于事件编程中的监听器，与普通事件监听器不同的是，普通事件监听器监听的事件源是程序中的对象；而BroadcastReceiver监听的事件源是Android应用中的其他组件。使用BroadcastReceiver组件接受广播消息比较简单，开发者只需要实现自己的BroadcastReceiver子类，并重写onReceive(Context context,Intent intent)方法即可。当其他组件通过sendBroadcast(),sendStickyBroadcast(),sendOrderedBroadcast()方法发送广播消息时，如果该BroadcastReceiver也对该消息感兴趣（通过IntentFilter配置），BroadcastReceiver的onReceive(Context context,Intent intent)方法将会被触发。开发者实现了BroadcastReceiver后，通常有两种方式来注册这个系统级的“事件监听器”。 在Java代码中通过Context.registReceiver()方法注册BroadcastReceiver. 在AndroidManifest.xml文件中使用&lt;receiver…/&gt;元素完成注册。 ContentProviderAndroid应用运行在各自独立的进程中，如果这些Android应用之间需要实现实时的数据交换——例如，我们开发了一个发送短信的程序，当发送短信时需要从联系人管理应用中读取指定联系人的数据——这就需要多个应用程序之间进行数据交换，开发者可以编写自己的ContentProvider来实现数据交换。开发者需要实现如下的抽象方法： insert(Uri,ContentValues)：向ContentProvider插入数据 delete(Uri,ContentValues)：删除ContentProvider中指定数据 update(Uri,ContentValues,String,String[])：更新ContentProvider中指定数据 query(Uri,String[],String,String[],String)：从ContentProvider查询数据 通常与ContentProvider结合使用的时ContentResolver，一个应用程序使用ContentProvider暴露自己的数据，而另一个应用程序则通过ContentResolver来访问数据。 Intent和IntentFilterIntent可以启动另一个Activity，也可以启动一个Service组件，还可以发送一条广播消息来触发系统中的BroadcastRecevier。也就说这三种组件之间的通信都以Intent作为载体。 当需要启动一个Activity时，可以调用Context的startActivity(Intent intent)或startActivityForResult(Intent intent,int requestCode)方法，这两个方法中intent中封装了需要启动的Activity的信息。 启动Service时，调用Context的startService(Intent intent)方法或者bindService(Intent service,ServiceConnection conn,int flags)方法，这两个方法中intent封装了需要启动的目标service的信息。 当需要触发一个BroadcastReceiver时，可调用Context的sendBroadcast(Intent intent),sendStickyBroadcast(Intent intent)或sendOrderedBroadcast(Intent intent,String receiverPermission)方法来发送广播消息，这三个方法中Intent参数封装了需要触发的目标BroadcastReceiver的信息。 当一个组件通过Intent表示了启动或触发另一个组件的“意图”之后，这个意图可以分为两类。 显式Intent：显式Intent明确指定需要启动或者触发的组件的类名。 隐式Intent：隐式Intent只是指定需要启动或者触发的组件应满足怎样的条件。 被调用的组件通过IntentFilter来声明自己所满足的条件——也就是声明自己到底能处理哪些隐式Intent。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Activity</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习（一）]]></title>
    <url>%2F2018%2F07%2F14%2F7.14%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Android应用清单文件AndroidManifest.xmlAndroidManifest.xml清单文件通常包含如下信息： 应用程序包名 应用程序所包含的组件，如Activity、Service、BroadcastReceiver和ContentProvider等 应用程序兼容的最低版本 应用程序使用系统所需的权限声明 其他程序访问该程序所需的权限声明 应用程序权限说明1.声明运行该应用本身所需要的权限通过为&lt;Manifest…/&gt;元素添加&lt;uses-permission…/&gt;子元素即可为程序本身声明权限。例如：&lt;! –声明该应用本身需要打电话的权限 –&gt;&lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;/&gt;2.声明调用该应用所需的权限通过为应用的各组件元素，如&lt;activity…/&gt;元素添加&lt;uses-permission…/&gt;子元素即可声明调用该程序所需的权限。例如：&lt;! –声明该应用本身需要发送短信的权限 –&gt; &lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot;&gt;常用权限如下表： 权限 说明 ACCESS_NETWORK_STATE 允许应用程序获取网络状态信息的权限 ACCESS_WIFI_STATE 允许应用程序获取Wi-Fi网络状态信息的权限 BATTERY_STATS 允许应用程序获取电池状态信息的权限 BLUETOOTH 允许应用程序连接匹配的蓝牙设备的权限 BLUETOOTH_ADMIN 允许应用程序发现匹配的蓝牙设备的权限 BROADCAST_SMS 允许应用程序广播收到短信提醒的权限 CALL_PHONE 允许应用程序拨打电话的权限 CAMERA 允许应用程序使用照相机的权限 CHANGE_NETWORK_STATE 允许应用程序改变网络连接状态的权限 CHANGE_WIFI_STATE 允许应用程序改变wifi网络连接状态的权限 DELETE_CACHE_FILES 允许应用程序删除缓存文件的权限 DELETE_PACKAGES 允许应用程序删除安装包的权限 FLASHLIGHT 允许应用程序访问闪光灯的权限 INTERNET 允许应用程序打开网络Socket的权限 MODIFY_AUDIO_SETTINGS 允许应用程序修改全局声音设置的权限 PROCESS_OUTGOING_CALLS 允许应用程序监听、控制、取消呼出电话的权限 READ_CONTACTS 允许应用程序读取用户的联系人数据的权限 READ_HISTORY_BOOKMARKS 允许应用程序读取历史书签的权限 READ_OWNER_DATA 允许应用程序读取用户数据的权限 READ_PHONE_STATE 允许应用程序读取电话状态的权限 READ_PHONE_SMS 允许应用程序读取短信的权限 REBOOT 允许应用程序重启系统的权限 RECEIVE_MMS 允许应用程序接收、监控、处理彩信的权限 RECEIVE_SMS 允许应用程序接收、监控、处理短信的权限 RECORD_AUDIO 允许应用程序录音的权限 SEND_SMS 允许应用程序发送短信的权限 SET_ORIENTATION 允许应用程序旋转屏幕的权限 SET_TIME 允许应用程序设置时间的权限 SET_TIME_ZONE 允许应用程序设置时区的权限 SET_WALLPAPER 允许应用程序设置桌面壁纸的权限 VIBRATE 允许应用程序控制振动器的权限 WRITE_CONTACTS 允许应用程序写入用户联系人的权限 WRITE_HISTORY_BOOKMARKS 允许应用程序写历史书签的权限 WRITE_OWNER_DATA 允许应用程序写用户数据的权限 WRITE_SMS 允许应用程序写短信的权限]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>AndroidManifest.xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统概述]]></title>
    <url>%2F2018%2F07%2F14%2F7.14%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[1.数据库的4个基本概念数据(data)描述数据的符号记录称为数据。 数据库(DataBase,DB)数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享。 数据库管理系统(DataBase Management System,DBMS)数据库管理系统是位于用户与操作系统之间的一层数据管理软件。数据库管理系统和操作系统一样是计算机的基础软件。主要功能： 数据定义功能 数据组织、存储和管理 数据操纵功能 数据库的事务管理和运行管理 数据库的建立和维护功能 其他 数据库系统(DataBase System,DBS)数据库系统是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员(DataBase Administrator,DBA)组成的存储、管理、处理和维护数据的系统。 2.数据管理技术的发展 人工管理阶段 文件系统阶段 数据库系统阶段 3.数据模型两类数据模型 概念模型 按照用户的观点来对数据建模，用于数据库设计 逻辑模型和物理模型 包括层次模型、网状模型、关系模型等等，它是按照计算机系统观点对数据建模，用于数据库管理系统的实现。 数据模型的组成要素 数据结构 数据操作 数据的完整性约束条件]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[博客编写注意事项（2）]]></title>
    <url>%2F2018%2F07%2F13%2F7.13%2F</url>
    <content type="text"><![CDATA[浅谈Markdown语法在GitHub博客中的应用 第二个注意事项markdown语句书写细节在诸如#,:等特殊符号后，应添加空格，以保证语句在编译时的正确性。 ‘标亮’的使用在输入法为英文的情况下，我们使用的tab键正上方的那个键来表示标亮。例如：你好，我是标亮符号的表现形式。 ‘加粗’的使用我们仅仅只需要在需要加粗的文本前后各加2个*就可以实现。例如： 你好我是加粗的表现形式。 ‘无序列表项’的使用列表项通过“-/*/+ 文本描述”引号其中的表达方式实现。二级无序列表项只需要在缩进符号前，加一个空格。例如：（此处需要空一行才可以实现无序列表） 无序列表项1 无序列表项1.1 无序列表项2 无序列表项3 ‘有序列表项’的使用有序列表项通过“1.”引号其中的数字+一个英文句点实现。例如： 有序列表项1 有序列表项2 有序列表项3 ‘列表缩进’的使用缩进的符号用“*/+/-”都可以实现，在缩进符号后面紧跟一个空格或者tab制表符。在文本中的换行用两个空格即可实现。例如： 蜀相丞相祠堂何处寻，锦官城外白森森。映阶碧草自春色，隔叶黄鹂空好音。三顾频烦天下计，两朝开济老臣心。出事未捷身先死，长使英雄泪满襟。 ‘图片，超链接，视频’在博客中的插入12[剑门关](https://baike.baidu.com/item/%E5%89%91%E9%97%A8%E5%85%B3%E9%A3%8E%E6%99%AF%E5%8C%BA/1356420?fromtitle=%E5%89%91%E9%97%A8%E5%85%B3&amp;fromid=31219&amp;fr=aladdin) ![image](https://dimg05.c-ctrip.com/images/fd/tg/g2/M0B/8B/64/CghzgFWw3KKAThWhACtMPja6o6E510_R_1600_10000_Mtg_7.jpg) 剑门关ps：在网页中的图片，只需要右击鼠标，点击复制图片地址，再插入博客中，图片插入的网址粘贴上就行。 ‘代码块’的插入在英文键盘输入的模式下,使用tab键上面的键，文本首尾连按三次就行。例如： 12345public class Speak()&#123; public static void main(String args[])&#123; System.out.println(&quot;你好&quot;); &#125;&#125; ‘表格’的插入推荐一个能生成多种列表的网址：http://www.tablesgenerator.com/markdown_tables#点此进入 ‘tags’多标签实现通过在tags的叙述中使用“- 标签1- 标签2”来实现，标签1与2之间需要换行。例如：123tags: - Activity - View >的使用 实验室服务于全体学生，用于科技创新和国家比赛，承担公司项目开发 -–的使用-–代表一条横线 - []的使用- []用来代表是否选中]]></content>
      <categories>
        <category>MarkDown语法</category>
      </categories>
      <tags>
        <tag>博客编写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客编写格式注意（1）]]></title>
    <url>%2F2018%2F07%2F12%2F7.12%2F</url>
    <content type="text"><![CDATA[浅谈GitHub博客的本地Markdown文件书写的语法及注意事项 第一个注意事项title标题 “—”title: 博客编写格式注意categories: MarkDown语法tags: 博客编写“—”浅谈GitHub博客的本地Markdown文件书写的语法及注意事项 在这段md语句中title的“—” “—”包裹需要在第二个—后面加一段文字性描述；否则GitHub博客上不会识别出这个md文件的标题，博客上显示的标题是未命名，且title下面的分类、标签都没有加上，变成了文字性的描述了。 ‘&gt;’引用的使用‘&gt;’的结尾需要回车打出一个空白行来结束引用。]]></content>
      <categories>
        <category>MarkDown语法</category>
      </categories>
      <tags>
        <tag>博客编写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读三国]]></title>
    <url>%2F2018%2F07%2F11%2F%E4%B8%80%E5%8F%A3%E6%B0%94%E8%AF%BB%E4%B8%89%E5%9B%BD1%2F</url>
    <content type="text"><![CDATA[总结一下三国演义中出现的关键人物及事迹 读三国（一）汉室倾颓，讨伐董卓刘关张桃园三结义、曹孟德献七星宝刀、虎牢关三英战吕布、董卓火烧洛阳、王允利用貂蝉美人计离间吕布董卓 群雄逐鹿，吕布覆灭曹操挟天子以令诸侯、孙策小霸王平定江东八十一县、吕布白门楼殒命 内阁密诏，千里独行刘备曹操青梅煮酒论英雄、董承联合众汉臣密谋杀曹操、关云长千里走单骑、刘玄德赵子龙相见情义比桃园]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>三国</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewPager的认识]]></title>
    <url>%2F2018%2F07%2F10%2FViewPager%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[ViewPager的认识ViewPager是怎么样的一个控件 它是一个用于页面切换的组件，我们可以向它的布局内填充多个View，我们可以通过在触摸屏上左右滑动来切换不同的View。我们需要一个适配器Adapter，将要显示的View和我们的ViewPager进行绑定。ViewPager有自己的Adapter——PagerAdapter。其中，Google建议使用Fragment来填充ViewPager的，这样可以更加方便的生成每个Page以及管理每个Page的生命周期，就是FragmentPageAdapter和FragmentStatePagerAdapter两个不同的Adapter。除此之外，ViewPager会缓存当前页，前一页，以及后一页，比如有1，2，3，4这四个页面，当我们处于第一页：缓存1，2；当我们处于第二页：缓存1，2，3；当我们处于第三页：缓存2，3，4；当我们处于第四页缓存3，4。 PagerAdapter使用重写方法：getCount()：获得viewpager中有多少个viewdestroyItem()：移除一个给定位置的页面。适配器有责任从容器中删除这个视图。这是为了确保在finishUpdate(ViewGroup)返回时视图能被移除。instantiateItem()：①将给定位置的view添加到ViewGroup(容器)中，创建并显示出来②返回一个代表新增页面的Object(key),通常都是直接返回view本身就可以了。当然也可以自己自定义key，但是key和每一个view要一一对应。isViewFromObject()：判断instantiateItem(ViewGroup,int)函数所返回的key与一个页面视图是否是代表的同一个视图(即它俩是否是对应，对应的表示同一个View)，通常我们直接写return view ==object；就可以了。貌似因为ViewPager中有个存储view状态信息的ArrayList，根据View取出对应信息。ps：不一定要重写所有方法。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown练习]]></title>
    <url>%2F2018%2F07%2F09%2FMarkdown%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述 宗旨 Markdown的目标是实现易读易写。 可读性，无论如何，都是最重要的。一份使用Markdown格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown语法受到一些既有text-to-HTML格式的影响，包括Setext、atx、Textile、reStructuredText、Grutatext和EtText，而最大灵感来源其实是纯文本电子邮件的格式。 总之，Markdown的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像强调。Markdown的列表看起来，嗯，就是列表。Markdown的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用hexo+github搭建免费博客]]></title>
    <url>%2F2018%2F07%2F08%2F%E5%88%A9%E7%94%A8hexo%2Bgithub%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一、准备工作： 注册一个github账号 ：支持高亮代码块、LaTeX 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手； 安装node.js ：下载链接https://pan.baidu.com/s/1xTBWJ-FFqe6_UfpYezuBtA 安装git ：下载链接https://pan.baidu.com/s/1FdgU2wjgF4RXQc5JRXrxbw 安装node.js和git ：只需要按默认next就ok了。 node.js环境配置：参考链接中的步骤https://www.jianshu.com/p/03a76b2e7e00 二、开始： 创建blog文件夹、并安装hexo、创建github仓库：在你的某个盘符下根目录创建一个blog空文件夹，操作步骤参考下面链接中的步骤3和4https://www.cnblogs.com/fengxiongZz/p/7707219.html 配置SSH key：参考下面链接中的步骤3https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html和参考下面链接中的步骤5https://www.cnblogs.com/fengxiongZz/p/7707219.html 博客环境配置时的问题nodejs环境配置当nodejs安装的目录不在C盘下时： 需要在nodejs文件夹下创建两个文件夹： node_global node_cache 在cmd命令窗口下，输入两条命令（文件夹目录改成新建的文件夹）： npm config set prefix “D:\nodejs\node_global” npm config set cache “D:\nodejs\node_cache” 环境变量配置： 系统变量：NODE_PATH;输入【D:\nodejs\node_global\node_modules】 用户变量:path;修改为【D:\nodejs\node_global】 github上创建仓库命名注意一下就行了；创建一个仓库：用户名.github.io 最后的在博客目录下不能进行hexo -d命令 如果输入hexo -g后git没有反应。那么在git push命令行下输入：1npm install hexo-deployer-git --save 这是用来安装插件的； 如果部署不到github上的仓库。那么在博客根目录下的_config.xml中deploy部分，改为如下：1234deploy: type: git repository: git@github.com:用户名/用户名.github.io.git branch: master 或者将repository设为:https://github.com/Luotianhao343/Luotianhao343.github.io.git 系统重装之后的使用现有blog目录继续更新1.先安装nodejs和git，两个软件都直接默认选项安装即可。2. 如果nodejs没有安装在c盘下，使用上面的nodejs环境配置。配置系统变量时，不用自己在node_global下创建node_modules文件夹；但是配置系统变量路径时要写上。3.配置好nodejs后，直接使用npm install hexo -g来安装hexo框架，这个框架是安装在nodejs\node_global\node_modules。并没有安装在blog这个文件夹下。4.在配置好hexo后，能在gitbush中使用hexo -v看到相关hexo框架信息的时候，便代表hexo配置完成。5.最后需要在gitbush中配置github上的用户名和邮箱，然后还要生成ssh密匙，并在github上设置好ssh。git config --global user.name &quot;Luotianhao343&quot; git config --user.email &quot;768758693@qq.com&quot; 使用cd ~/.ssh进入，再输入ssh-keygen -t rsa -C “768758693@qq.com“,连续回车即可;再输入eval &quot;$(ssh-agent -s)&quot;，添加密匙到ssh-agent;再输入ssh-add ~/.ssh/id_rsa,添加生成的ssh key到ssh-agent。然后再github上设置好id_rsa.pub文件内容复制上去。]]></content>
      <categories>
        <category>MarkDown语法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于SQLite本地数据库查询]]></title>
    <url>%2F2018%2F07%2F08%2Fsqlite%2F</url>
    <content type="text"><![CDATA[关于SQLite本地数据库查询1 本地数据库是存在于软件自安装至卸载的生命周期。2 sql语句与MySQL的数据库操作语句一样。3 通过用户注册的时候，获取当前用户的id（主键），通过Intent传值到最终需要用sqlite创建数据表的Activity中，Intent传值是要一个Activity接一个Activity的传（Activity中有点击跳转事件）。4 Intent传值的一些方法：①intent.putExtra(“userid”,result); //将服务器中result的id放入intent。result是一个字符串，通过服务器获取的。②Activity中传“userid”对应的值：String userId = null；Intent intent = getIntent();userId = intent.getStringExtra(“userid”);//取出intent.putExtra(“userid”,userId);//放入]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
